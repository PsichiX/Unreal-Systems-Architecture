<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Systems - Modular and scalable game architecture for orthogonal game logic</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="documentation.html">Documentation</a></li><li class="chapter-item expanded "><a href="book/index.html">Book</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/getting_started.html">Getting started</a></li><li class="chapter-item expanded "><a href="book/architecture/index.html">Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/architecture/world.html">World</a></li><li class="chapter-item expanded "><a href="book/architecture/systems.html">Systems</a></li><li class="chapter-item expanded "><a href="book/architecture/components.html">Components</a></li><li class="chapter-item expanded "><a href="book/architecture/resources.html">Resources</a></li><li class="chapter-item expanded "><a href="book/architecture/subsystem.html">Subsystem</a></li><li class="chapter-item expanded "><a href="book/architecture/pipelines.html">Pipelines</a></li><li class="chapter-item expanded "><a href="book/architecture/iterators.html">Iterators</a></li><li class="chapter-item expanded "><a href="book/architecture/channels.html">Channels</a></li></ol></li><li class="chapter-item expanded "><a href="book/learning_materials/index.html">Learning materials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/learning_materials/tutorial/index.html">Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/learning_materials/tutorial/installation.html">Installation</a></li><li class="chapter-item expanded "><a href="book/learning_materials/tutorial/setup_component.html">Setup component</a></li><li class="chapter-item expanded "><a href="book/learning_materials/tutorial/setup_actor.html">Setup actor</a></li><li class="chapter-item expanded "><a href="book/learning_materials/tutorial/setup_system.html">Setup system</a></li><li class="chapter-item expanded "><a href="book/learning_materials/tutorial/setup_game.html">Setup game</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reference.html">C++ API Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/structs.html">Structs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/structs/FActorsIter.html">FActorsIter</a></li><li class="chapter-item expanded "><a href="reference/structs/FArchetypeSignature.html">FArchetypeSignature</a></li><li class="chapter-item expanded "><a href="reference/structs/FInstallSystemOptions.html">FInstallSystemOptions</a></li><li class="chapter-item expanded "><a href="reference/structs/FMetronome.html">FMetronome</a></li><li class="chapter-item expanded "><a href="reference/structs/FSystemsPipelineComponent.html">FSystemsPipelineComponent</a></li><li class="chapter-item expanded "><a href="reference/structs/FSystemsPipelineResource.html">FSystemsPipelineResource</a></li><li class="chapter-item expanded "><a href="reference/structs/FSystemsPipelineSystem.html">FSystemsPipelineSystem</a></li><li class="chapter-item expanded "><a href="reference/structs/IterSizeHint.html">IterSizeHint</a></li><li class="chapter-item expanded "><a href="reference/structs/TQuery.html">TQuery</a></li><li class="chapter-item expanded "><a href="reference/structs/TReceiverChannel.html">TReceiverChannel</a></li><li class="chapter-item expanded "><a href="reference/structs/TResult.html">TResult</a></li><li class="chapter-item expanded "><a href="reference/structs/TSenderChannel.html">TSenderChannel</a></li><li class="chapter-item expanded "><a href="reference/structs/TTaggedQuery.html">TTaggedQuery</a></li></ol></li><li class="chapter-item expanded "><a href="reference/classes.html">Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/classes/ASystemsActor.html">ASystemsActor</a></li><li class="chapter-item expanded "><a href="reference/classes/ASystemsGameMode.html">ASystemsGameMode</a></li><li class="chapter-item expanded "><a href="reference/classes/ASystemsGameState.html">ASystemsGameState</a></li><li class="chapter-item expanded "><a href="reference/classes/ASystemsPawn.html">ASystemsPawn</a></li><li class="chapter-item expanded "><a href="reference/classes/FSystemsReflection.html">FSystemsReflection</a></li><li class="chapter-item expanded "><a href="reference/classes/UDynamicIterator.html">UDynamicIterator</a></li><li class="chapter-item expanded "><a href="reference/classes/UDynamicQuery.html">UDynamicQuery</a></li><li class="chapter-item expanded "><a href="reference/classes/ULambdaSystem.html">ULambdaSystem</a></li><li class="chapter-item expanded "><a href="reference/classes/UScriptableSystem.html">UScriptableSystem</a></li><li class="chapter-item expanded "><a href="reference/classes/USystem.html">USystem</a></li><li class="chapter-item expanded "><a href="reference/classes/USystemsActorComponent.html">USystemsActorComponent</a></li><li class="chapter-item expanded "><a href="reference/classes/USystemsPipeline.html">USystemsPipeline</a></li><li class="chapter-item expanded "><a href="reference/classes/USystemsReflection.html">USystemsReflection</a></li><li class="chapter-item expanded "><a href="reference/classes/USystemsSceneComponent.html">USystemsSceneComponent</a></li><li class="chapter-item expanded "><a href="reference/classes/USystemsStatics.html">USystemsStatics</a></li><li class="chapter-item expanded "><a href="reference/classes/USystemsSubsystem.html">USystemsSubsystem</a></li><li class="chapter-item expanded "><a href="reference/classes/USystemsWorld.html">USystemsWorld</a></li></ol></li><li class="chapter-item expanded "><a href="reference/functions.html">Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/functions/IterGenerate.html">IterGenerate</a></li><li class="chapter-item expanded "><a href="reference/functions/IterOnce.html">IterOnce</a></li><li class="chapter-item expanded "><a href="reference/functions/IterRange.html">IterRange</a></li><li class="chapter-item expanded "><a href="reference/functions/IterRepeat.html">IterRepeat</a></li><li class="chapter-item expanded "><a href="reference/functions/IterStd.html">IterStd</a></li><li class="chapter-item expanded "><a href="reference/functions/IterStdConst.html">IterStdConst</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Systems - Modular and scalable game architecture for orthogonal game logic</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="systems-architecture-documentation"><a class="header" href="#systems-architecture-documentation">Systems Architecture Documentation</a></h1>
<blockquote>
<p>Systems Architecture is a framework that focuses on modular and scalable game logic.</p>
<p>It rewards using DOD (Data-Oriented-Design) over industry-wide OOP standard for writing
game logic to reduce occurrence of common pitfals when doing OOP wrong, by avoiding it
as much as possible and by that reducing comprehensive complexity to bare minimum.</p>
</blockquote>
<p>In this documentation you will learn best practices for producing modular and scalable
game systems that together make complex game features, yet still doesn't require countless
hours of organization, production and iteration times in the process of making games.</p>
<p>Systems Architecture is refreshingly simple yet powerful tool to make Unreal Engine game
developers <em><strong>Work Smart, Not Hard <sup>TM</sup></strong></em> and we are gonna achieve that by reducing
complexity of codebase and production process to bare minimum!</p>
<p>Ok, enought pretty words - let's dive into how Systems Architecture works and what problems
does it solve.</p>
<h1 id="contents"><a class="header" href="#contents">Contents</a></h1>
<ul>
<li><a href="/Unreal-Systems-Architecture/systems/book/index.html">Book</a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference.html">C++ API Reference</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="book"><a class="header" href="#book">Book</a></h1>
<p>This book covers explanation of Systems Architecture, as well as provides learning materials
such as guidelines with best practices to keep your project healthy and your sanity in check,
it also provides tutorial showing step-by-step how to use Systems Architecture in your game.</p>
<h1 id="pages"><a class="header" href="#pages">Pages</a></h1>
<ul>
<li><a href="book//Unreal-Systems-Architecture/systems/book/getting_started.html">Getting started</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Before we jump into the meat of Systems Architecture, let me quickly show you a
snippet showcasing how working with Systems looks like in a gist:</p>
<details>
<summary><b><i>Click to unfold code snippet</i></b></summary>
<pre><code class="language-cpp">
// Actor componetns are treated as data/tags put on actors, that user reads from
// or writes to, using system queries.
UCLASS(BlueprintType, Blueprintable, Meta = (BlueprintSpawnableComponent))
class EXAMPLE_API UPlayerComponent : public USystemsActorComponent
{
	GENERATED_BODY()
};

UCLASS(BlueprintType, Blueprintable, Meta = (BlueprintSpawnableComponent))
class EXAMPLE_API UEnemyComponent : public USystemsActorComponent
{
	GENERATED_BODY()
};

// System are usually lambdas/functions that process chunks of systems world
// data (it can be querying actor components, managing resources or just
// processing some data - the point is we focus on processing game data, no
// matter its form).
void HuntSystem(USystemsWorld&amp; Systems)
{
	const auto DeltaTime = Systems.GetWorld()-&gt;GetDeltaSeconds();

	// Systems Architecture adds an interface over game world that allows us to
	// treat it as database that we can query, also rather than putting logic
	// into each object, we rather perform batched data processing on a set of
	// requested components.
	Systems
		.Query&lt;UPlayerComponent&gt;()
		// We use powerful lazy-iterators to ease our work on batched data
		// processing. this one is one of many consumer iterators and it's job
		// is to go through all yielded iterator values and make user do
		// something useful with these, just like with regular for-in loops.
		.ForEach(
			[](auto&amp; PlayerData)
			{
				// queries always yield tuple with actor that owns components
				// requested for query, in addition to following components.
				auto* PlayerActor = PlayerData.Get&lt;0&gt;();
				const auto PlayerPosition = PlayerActor-&gt;GetActorLocation();

				const auto Nearest = Systems
										 .Query&lt;UEnemyComponent&gt;()
										 // mapping iterator is one of the most commonly used
										 // types of iterators that transform data from one form
										 // to another, usually to get exact information needed
										 // by next iterators in chain, or to just process it and
										 // collect the result.
										 .Map&lt;TTuple&lt;FVector, float&gt;&gt;(
											 [&amp;](const auto&amp; EnemyData)
											 {
												 const auto* EnemyActor = EnemyData.Get&lt;0&gt;();
												 const auto EnemyPosition = EnemyActor-&gt;GetActorLocation();
												 const auto Distance = FVector::Distance(PlayerPosition, EnemyPosition);

												 return MakeTuple(EnemyPosition, Distance);
											 })
										 // finding the nearest enemy based on distance extracted
										 // in previous iteration step.
										 .ComparedBy(
											 [](const auto&amp; A, const auto&amp; B)
											 {
												 const auto DistanceA = A.Get&lt;1&gt;();
												 const auto DistanceB = B.Get&lt;1&gt;();

												 return DistanceA &lt; DistanceB;
											 });

				if (Nearest.IsSet())
				{
					const auto TargetPosition = Nearest.GetValue().Get&lt;0&gt;();
					const auto Direction = (TargetPosition - PlayerPosition).GetSafeNormal();
					const auto Velocity = Direction * 100.0f * DeltaTime;

					PlayerActor-&gt;SetActorLocation(PlayerPosition + Velocity);
				}
			});
}

UCLASS()
class EXAMPLE_API UExampleGameInstance : public UGameInstance
{
	GENERATED_BODY()

private:
	virtual void Init() override;
};

void UExampleGameInstance::Init()
{
	Super::Init();

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;AcquireSystemsWorld(FName(),
			[&amp;](auto&amp; Systems)
			{
				// Due to how queries are resolved, we need to register all
				// components we might want to query.
				Systems.RegisterComponent&lt;UPlayerComponent&gt;();
				Systems.RegisterComponent&lt;UEnemyComponent&gt;();

				// Persistent systems (ones that will run on every game tick)
				// have to be registered in systems world. There are many types
				// of systems, but commonly used ones are state-less
				// lambda/function systems. System labels
				// (&quot;Hunt&quot;) are used for resolving systems dependency graph
				// (user can provide sets of systems that given one has to run
				// before and after).
				Systems.InstallLambdaSystem(HuntSystem, FInstallSystemOptions(&quot;Hunt&quot;));
			});
	}
}
</code></pre>
</details>
<h1 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h1>
<ul>
<li><a href="book/getting_started.html#systems-architecture-is-not-an-ecs">Systems Architecture is not an ECS!</a></li>
<li><a href="book/getting_started.html#goals">Goals</a>
<ul>
<li><a href="book/getting_started.html#more-data-oriented-design-approach-to-game-logic">More Data-Oriented-Design approach to game logic</a></li>
<li><a href="book/getting_started.html#flat-and-deterministic-flow-of-data">Flat and deterministic flow of data</a></li>
<li><a href="book/getting_started.html#orthogonal-and-compact-game-logic">Orthogonal and compact game logic</a></li>
<li><a href="book/getting_started.html#modularity-and-reusability">Modularity and reusability</a></li>
<li><a href="book/getting_started.html#conclusions">Conclusions</a></li>
</ul>
</li>
</ul>
<h1 id="systems-architecture-is-not-an-ecs"><a class="header" href="#systems-architecture-is-not-an-ecs">Systems Architecture is not an ECS!</a></h1>
<p>This is very important to say upfront:</p>
<blockquote>
<p><strong>Although at first glance Systems Architecture API looks somewhat like ECS, it
definitely is not one.</strong></p>
</blockquote>
<p>There are similarities in both, but ECS do more than treat game as database, and
its design choices revolve around best performance possible for massive worlds and
making improved productivity and reduction of complexity is a side-effect of that,
while Systems Architecture doesn't change much to the Unreal Engine API, rather
resuses its parts (like actors and actor components) and only adds an API to enable
accessing and processing game world in database-like fashion, making Systems
Architecture focusing mostly on ergonomics and reducement of overall complexity.</p>
<p>That doesn't mean Systems Architecture doesn't care about performance - it already
makes its internals do as less work as possible, and more optimizations are gonna
arrive in further development, but the grand goal is and will be always making
Unreal Engine game developers life as easier as possible.</p>
<p>That being said, Systems Architecture took great amount of inspiration from ECS,
mostly from Rust ECS-based libraries and game engines that proven over time that
database-like DOD approach to game logic is not only viable, but also highly
beneficial for faster and easier game development process:</p>
<ul>
<li><a href="https://github.com/Ralith/hecs"><strong><code>hecs</code></strong></a></li>
<li><a href="https://github.com/PsichiX/Oxygengine"><strong><code>Oxygengine</code></strong></a></li>
<li><a href="https://github.com/bevyengine/bevy"><strong><code>Bevy</code></strong></a></li>
</ul>
<p>As well as Rust <a href="https://doc.rust-lang.org/stable/std/iter/index.html"><strong><code>lazy-iterators</code></strong></a>
and <a href="https://doc.rust-lang.org/stable/std/sync/mpsc/index.html"><strong><code>channel</code></strong></a> APIs.</p>
<h1 id="goals"><a class="header" href="#goals">Goals</a></h1>
<h2 id="more-data-oriented-design-approach-to-game-logic"><a class="header" href="#more-data-oriented-design-approach-to-game-logic">More Data-Oriented-Design approach to game logic</a></h2>
<p>Most infromation you can find prasing DOD focuses too much on its benefits to game performance
with huge worlds. I would safely say that this actually shouldn't be the main thing DOD should
be recognized by, there is even more important benefit of thinking in terms of data and data
processing rather than communication between objects (OOP) - <strong>avoiding common pitfalls when
trying to model game systems around <em>Real World Things <sup>TM</sup></em></strong>.</p>
<blockquote>
<p>All game is, is just a bunch of data in memory that gets transformed from one form to another.</p>
</blockquote>
<p>When we realize that, we can better and easier solve problems by designing data and game logic
that works best together and do as less work as possible, instead of adding lots of usually
unnecessary abstraction layers just because we might have a false intuition that representing data
and logic in human-readable real world representation somehow will make us understand it better
and quicker, while after year of development on each game, we find ourselves struggling with
adding, removing or just changing how certain parts of game logic works, slapping hacky solutions
here and there just to meet deadlines (we can't remove deadlines but we can reduce complexity).</p>
<p>We all have been through that, and we all promise ourselves <strong>we are not gonna make same mistakes
again in next project</strong>, we just need to &quot;better design how our objects communicate&quot;, while making
totally new and even more problematic mistakes along the way - we can all agree that this next
project is never actually free from mistakes we did last time, they all share same source.</p>
<blockquote>
<p>That being said DOD isn't a miracle cure that solves all our problems, it brings its own to the
table.</p>
</blockquote>
<p>But all these problems revolve around us still trying to slap our (false) intuition about objects
communication into problems that do not require these in the first place, us not being able to
easily switch our brains from thinking in terms of object communication into thinking in terms of
data transformations.</p>
<p>Yes, this takes time to appreciate data, but it pays off eventually with us being able to solve
problems right way, not creating workarounds here ant there just to follow tons of abstraction
layers requirements.</p>
<p><strong>I hope this book will do its best to speed up switching from OOP to more DOD approach, by showing
how to simplify problems without using tons of design patterns.</strong></p>
<h2 id="flat-and-deterministic-flow-of-data"><a class="header" href="#flat-and-deterministic-flow-of-data">Flat and deterministic flow of data</a></h2>
<p>Events-based logic approach commonly used in Unreal Engine is great for triggering foreign actions
(a.k.a. objects messaging) but has one big flaw - <strong>it's not scalable</strong> as project grows. This happens
because user have very limited control over order of actions happening when using events, and it
grows into even bigger problem as dependency graph between parts of event-based logic grows.</p>
<blockquote>
<p>Dependency graph in events-based game logic is a set of hidden rules of what action requires what
other action to run before and after this one, to make sure objects being communicated have valid and
expected state at each point of action execution. Hidden, because these rules emerge over time without
user noticing them.</p>
</blockquote>
<p>Basically any situation where feature A to run properly, depends on feature B to have a certain data,
but that data is provided by feature C and so on, and there is no clear way to determine the order of
actions that prepare data for any other feature in all code points related to this problem.</p>
<p>Sometimes it gets even worse when features triggers events that receivers triggers their events and
their receivers triggers their events and so on - you can see where i'm going with it, this quickly
turns into <em><strong>The Fuck Cascade <sup>TM</sup></strong></em> of tons of state recalculation along the way in a
single point in time, just to keep all objects always have valid state that depends on other game
features state. This is clearly unmanageable and requires a lot of refactoring to either remove
dependencies between them or to defer operations in time. This is something user usually do not put
much thought into, until a <em>really weird bug happen in some place unrelated to the problem</em>.</p>
<p><strong>Ok, so what we can do about it?</strong></p>
<p>Well, <strong>flatten dependency graph</strong> and put execution of game features in line as much as possible.
With that we reduce cognitive complexity to bare minimum, and user can easily manage exact order of
actions to make sure state is always valid and do not need to recalculate on each change causing
cascade of instant changes in features that depend on it - <strong>TL;DR: user can see exact flow of data
in one place and that makes it easy to reason about, no need for juggling around the whole codebase</strong>.</p>
<p>In case user still wants to send data with events, but keep deterministic events execution, Systems
Architecture provides feature called <a href="book//Unreal-Systems-Architecture/systems/book/architecture/channels.html">channels</a> which uses polling
to get received messages and execute them at the exact moment system needs to, avoiding immediate
message execution when broadcasting messages.</p>
<p>There is also another benefit we gain from flat dependency graph, that we will discuss next:</p>
<h2 id="orthogonal-and-compact-game-logic"><a class="header" href="#orthogonal-and-compact-game-logic">Orthogonal and compact game logic</a></h2>
<p>Quote from Eric Steven Raymond in
<a href="http://www.catb.org/~esr/writings/taoup/html/ch04s02.html#orthogonality">Art of UNIX programming</a>:</p>
<blockquote>
<p>Orthogonality is one of the most important properties that can help make even complex designs
compact. In a purely orthogonal design, operations do not have side effects; each action (whether
it's an API call, a macro invocation, or a language operation) changes just one thing without
affecting others. There is one and only one way to change each property of whatever system you are
controlling.</p>
</blockquote>
<p>What intrests us game developers from this quote is that when we express game logic in a set of
simple work units we can easier reduce (or even remove) dependencies between parts of game logic and
that allows us to easily reason about them (small code) and add/change/remove them without much time
spend on refactoring (next to none dependencies between game logic parts).</p>
<blockquote>
<p>Orthogonal game systems are ones that do not require each other to work (like you remove one and
your game still runs), but they together make up bigger feature.</p>
</blockquote>
<p><strong>How Systems Architecture helps to achieve that?</strong></p>
<p>Well, it helps by forcing user to think about data transformations instead of object communication.
<strong>When we do not have to deal with abstractions, what's left is data and how we process that data.</strong>
That allows to focus on solving actual problem instead of trying to fit it into some design pattern.</p>
<p>Because systems are all about data transformations, and System Architecture provides an ergonomic
way for performing these (such as queries over game world and iterators), each system by the nature
of data it works on, will keep itself doing only the work it needs and not causing hidden cascades of
changes in the world, <strong>making every change explicit and intentional</strong>.</p>
<p>Simple example would be: instead of having per unit movement that handles input, position change and
physics at once, you create separate systems:</p>
<ul>
<li>
<p>input system that collects player input and turns it into input data stored either in a global
resource or in some actor component, it depends on what you want to do with this data later.</p>
<blockquote>
<p>You should always design your data around what it's gonna be used for, not the other way around!</p>
</blockquote>
</li>
<li>
<p>velocity resolve system that reads input data available for given actor and converts these inputs
into velocity change and stores it in velocity component.</p>
</li>
<li>
<p>position change system that reads velocity and applies it to unit position.</p>
</li>
</ul>
<p>You might think: &quot;ok, but this particular example seems to be an easy task that <em>can</em> be just executed
all in one place&quot; - and you couldn't be wrong more.</p>
<p>Look at the bigger picture - few months later you'll need to extend or replace physics, or you would
need to add another physics resolvers that work on unit velocity and at that point this code gets bigger.
You obviously split it into smaller methods, but now designers wants you to let them parameterize or even
disable some of its parts at will - well, hello <strong>Refactor Tractor <sup>TM</sup></strong> my old friend.
If you split these into smaller batched work units, you gain both easy way to toggle each stage of
movement and even be able to quickly change or even remove/replace with brand new ones, not to mention
being able to quickly add parameterization for designers in matter of minutes to hour, not days.</p>
<p>Like i said before:</p>
<blockquote>
<p>Keeping systems small makes it easy to reason about them and that is a one huge productivity booster
that you'll love to still have after year of development on your game.</p>
</blockquote>
<h2 id="modularity-and-reusability"><a class="header" href="#modularity-and-reusability">Modularity and reusability</a></h2>
<p>Modularity, which means we can build complex features from smaller building blocks, gives us an ability
to reuse or even share these modules with other developers (free or paid, on github or marketplace).
In companies it is even more important to share and reuse certain modules between different teams and
products, as demand for making more by doing less grows as company structure and portfolio grows.</p>
<p>Systems Architecture, by its design, allows to put generalized systems and components into separate
modules, with none (or sometimes next to none) dependencies between other parts of the game. Are you
making a simulation game with NPCs wandering around on the map in one project, then in next one you need
to make them too? Put these in a module or just migrate them to another project. Code that doesn't
compile? Fear no more, you have got decoupled systems at the moment you've started making them, there is
next to none work needed after migration, just register systems into pipeline and slap these components
on actors and run the game.</p>
<p><strong>For indies and Unreal Engine plugin creators there are also great news!</strong></p>
<p>Systems Architecture core design, when treated as platform/framework, enables Unreal Engine plugin
developers to finally <strong>create an ecosystem of plugins trully compatible with each other</strong>. Ecosystem
of compatible plugins that do not require a hussle of installation steps, makes plugins more accessible
for users that want game features that <strong>Just Works <sup>TM</sup></strong> and creates opportunity for more
sales for plugin devs - this is a big win for both worlds, users and creators.</p>
<p>And as a bonus:</p>
<blockquote>
<p><strong>System Architecture is and will always remain free</strong> under permissive licenses, for anyone, accepting
reasonable contributions that improve its ergonomics, quality and performance.</p>
</blockquote>
<h1 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h1>
<p>If you should take anything from this, remember:</p>
<blockquote>
<p><strong>When making games, you're basically just processing data and you don't need fancy
distraction-abstractions for that.</strong></p>
</blockquote>
<ul>
<li>Make it <strong>flat</strong></li>
<li>Make it <strong>small</strong></li>
<li>Make it <strong>compact and disconnected from other systems</strong></li>
</ul>
<p>Then you'll keep your sanity after year of development on a single game title.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This section will explain in-depth how Systems Architecture exactly works and how to abuse
it to solve your problems the right way.</p>
<p>Systems Architecture adds a database-like interface over game world to allow ergonomic
queries for game world data processing.</p>
<ul>
<li>
<h2 id="actor-components-should-only-store-data"><a class="header" href="#actor-components-should-only-store-data">Actor components should only store data</a></h2>
<p>Or no data, if they are considered tags, used as markers over actors. Tags such as
<code>UEnemyComponent</code> that enables this actor to be queried in systems that works on enemies.</p>
<p>And sometimes methods, but only these that do not have side effects reaching outside of
this actor component scope - the point is: it's systems job to perform game logic, actor
component methods should at most contain methods that recalculate their internal state,
and these are operations called in more than one place.</p>
<p>This rule gets invalidated for situations like actor component being a bridge to some
Unreal Engine built-in components or third-party code to which handles are stored in
actor components. Just make sure your own actor components do as less work as possible.</p>
</li>
<li>
<h2 id="systems-do-most-if-not-all-game-logic"><a class="header" href="#systems-do-most-if-not-all-game-logic">Systems do most if not all game logic</a></h2>
<p>This means whenever you want to put some commonly used piece of logic in actor component
or (gods forbid) in actor, make a system for it.</p>
<p>It will pay off months later by still having small orthogonal game systems with as less
dependencies as possible, systems that can be easily toggled, changed or even
removed/replaced - no more hours or days of careful code refactoring just because you need
to change or remove some bit of game feature.</p>
</li>
<li>
<h2 id="your-game-world-is-just-a-database"><a class="header" href="#your-game-world-is-just-a-database">Your game world is just a database</a></h2>
<p>Systems Architecture gives you ergonomic tools to ease work on batched sets of actor
components using game world queries.</p>
<pre><code class="language-cpp">UCLASS()
class BOIDS_API UBoidsMovementSystem : public USystem
{
	GENERATED_BODY()

public:
	virtual void Run(USystemsWorld&amp; Systems) override;
};

void UBoidsMovementSystem::Run(USystemsWorld&amp; Systems)
{
	Super::Run(Systems);

	const auto* BoidsSettings = Systems.Resource&lt;UBoidsSettings&gt;();
	if (IsValid(BoidsSettings) == false)
	{
		return;
	}
	const auto TimeScale = BoidsSettings-&gt;TimeScale;
	const auto DeltaTime = Systems.GetWorld()-&gt;GetDeltaSeconds() * TimeScale;

	Systems.Query&lt;UVelocityComponent, UBoidComponent&gt;().ForEach(
		[&amp;](auto&amp; QueryItem)
		{
			auto* Actor = QueryItem.Get&lt;0&gt;();
			const auto* Velocity = QueryItem.Get&lt;1&gt;();
			const auto Position = Actor-&gt;GetActorLocation();

			Actor-&gt;SetActorLocation(Position + Velocity-&gt;Value * DeltaTime);
		});
}
</code></pre>
<p>With queries you have all this system logic in one place - that greatly reduces comprehensive
complexity, no more need to jump around whole codebase just to understand how system works,
and <strong>we make ourselves keep systems small, doing only only the work they need and no other</strong>.</p>
</li>
</ul>
<h1 id="pages-1"><a class="header" href="#pages-1">Pages</a></h1>
<ul>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/world.html">World</a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/systems.html">Systems</a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/components.html">Components</a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/resources.html">Resources</a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/subsystem.html">Subsystem</a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/pipelines.html">Pipelines</a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/iterators.html">Iterators</a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/channels.html">Channels</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="world"><a class="header" href="#world">World</a></h1>
<h1 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h1>
<ul>
<li><a href="book/architecture/world.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/world.html#queries">Queries</a></li>
<li><a href="book/architecture/world.html#archetypes">Archetypes</a></li>
</ul>
</li>
<li><a href="book/architecture/world.html#problems-that-it-solves">Problems that it solves</a></li>
</ul>
<h1 id="explanation"><a class="header" href="#explanation">Explanation</a></h1>
<p><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html"><strong><code>USystemsWorld</code></strong></a> is a registry that stores <a href="book/architecture//book/architecture/systems.html">systems</a>,
<a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/resources.html">resources</a> and <a href="book/architecture//book/architecture/components.html">actor components</a>.
The first thing you do is you setup your systems world by installing systems, resources and
registering actor components that will be used in systems queries to process and do something
useful with resources and actor components.</p>
<pre><code class="language-cpp">UCLASS()
class EXAMPLE_API UExampleGameInstance : public UGameInstance
{
	GENERATED_BODY()

private:
	virtual void Init() override;
};

void UExampleGameInstance::Init()
{
	Super::Init();

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;AcquireSystemsWorld(FName(),
			[&amp;](auto&amp; Systems)
			{
				Systems.RegisterComponent&lt;UShiaComponent&gt;();

				Systems.InstallResource&lt;UShiaSettings&gt;();

				Systems.InstallLambdaSystem(JustDoItSystem, FInstallSystemOptions(&quot;JustDoIt&quot;));
			});
	}
}
</code></pre>
<p>In example above we register systems world in game instance. We can of course create systems
worlds at will without registering it into <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystemsSubsystem.html"><strong><code>USystemsSubsystem</code></strong></a>, this global registry
is only a more convenient way to access and automate systems world management globally.</p>
<p>Once per tick (when using subsystem approach) all systems gets to run in order they were
installed (system installation options can provide additional hints about more precise order
when working with dependencies between systems).</p>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>The whole point of Systems Architecture is to process game world in a database-like fashion,
which means to perform same operations on a batched set of actor components, instead of putting
that work into these objects. That makes us completely decouple data from behaviors, making it
easier to add, remove and change them at will, even reuse without dealing with solving hidden
dependency tree problems between seemingly unrelated parts of codebase.</p>
<pre><code class="language-cpp">	const auto Count = static_cast&lt;int&gt;(Systems.Query&lt;UBoidComponent&gt;().Count());
	const auto Difference = Count - EXPECTED_POPULATION_NUMBER;

	if (Difference &gt; 0)
	{
		Systems.Query&lt;UBoidComponent&gt;()
			.Take(Difference)
			.ForEach(
				[](auto&amp; QueryItem)
				{
					auto* Actor = QueryItem.Get&lt;0&gt;();

					Actor-&gt;Destroy();
				});
	}
</code></pre>
<p>Queries are <a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/iterators.html">iterators</a> that always yields a tuple of actor
components and can be chained with other iterators to produce more elaborated, yet easy to
reason about data transformations. For example when you do <code>Systems.Query&lt;A, B, C&gt;</code>, values
yielded by query iterator will be of type <code>TTuple&lt;AActor*, A*, B*, C*&gt;</code>. it's also important
to note that user should never cache query objects, rather consume queries in place.</p>
<p>See <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html"><strong><code>TQuery</code></strong></a>.</p>
<h2 id="archetypes"><a class="header" href="#archetypes">Archetypes</a></h2>
<p>Internally all actor components are stored in buckets called archetypes. Given actor archetype
is determined by its <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/FArchetypeSignature.html"><strong><code>FArchetypeSignature</code></strong></a>, which is calculated from the set of
components given actor owns. When actor registers its components, systems world searches through
already existing archetypes and if it finds one, actor gets registered in that bucket, if not
new archetype bucket gets created.</p>
<p>The point of storing actors in groups per archetype is to make queries iteration as fast as
possible by iterating over only these actors that own all requested components in a linear
fashion without need for skipping over actors that we don't need to work on.</p>
<p>Archetype signatures are basically bitsets of 256 bits capacity, each bit represents registered
actor component. Whenever signature gets calculated for given query, it makes empty signature
and enables bits for requested component, then it compares this signature with each archetype
bucket signature and stores in query object a list of archetypes to iterate on.</p>
<h1 id="problems-that-it-solves"><a class="header" href="#problems-that-it-solves">Problems that it solves</a></h1>
<p>Usually when working with game managers it's a common practice to cache managers in other managers
to not perform costly searches in game world. This is unnecessary work and Systems Architecture
solves that by storing resources in single systems world, easily accessible from any system
without any need for caching any used resources in systems itself.</p>
<p>Another common problem is usually hierarchy of game logic gets growing in depth, like when game
logic is performed by game objects themselves, they reference one another, growing hidden
dependency tree and by that comprehensive complexity that requires sometimes hours to jump around
whole codebase just to understand how data flows between certain objects. Systems Architecture
forces user to make flat game logic with explicit order of execution, additionally making units
of work as small and as precise as possible to make it easy to reason about how game data gets
processed.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<h1 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of contents</a></h1>
<ul>
<li><a href="book/architecture/systems.html#explanation">Explanation</a></li>
<li><a href="book/architecture/systems.html#types-of-systems">Types of systems</a>
<ul>
<li><a href="book/architecture/systems.html#stateless-systems">Stateless systems</a></li>
<li><a href="book/architecture/systems.html#stateful-systems">Stateful systems</a></li>
</ul>
</li>
<li><a href="book/architecture/systems.html#problems-that-it-solves">Problems that it solves</a></li>
</ul>
<h1 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h1>
<p>Systems are small but precise units of work, work that's mainly about processing game world data
using queries. These queries are processed using <a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/iterators.html">iterators</a>,
and that makes queries the whole point of systems ergonomics since they simplify both computational
and comprehensive complexity and make that part of game logic really easy to reason about,
which in turn makes adding, removing and changing game logic easy and quicker than with monolithic
code or features highly dependent on each other, scattered around the codebase.</p>
<h1 id="types-of-systems"><a class="header" href="#types-of-systems">Types of systems</a></h1>
<p>There are few types of systems, but the ones that you will mostly use are stateless (lambdas/functions)
and stateful (classes) systems.</p>
<h2 id="stateless-systems"><a class="header" href="#stateless-systems">Stateless systems</a></h2>
<p>These are the most common ones. Stateless systems are just lambdas/functions that expect reference
to <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html"><strong><code>USystemsWorld</code></strong></a> to operate on it. Stateless systems do not require any internal state
to operate.</p>
<pre><code class="language-cpp">void MovementSystem(USystemsWorld&amp; Systems)
{
	const auto* Settings = Systems.Resource&lt;USettings&gt;();
	if (IsValid(Settings) == false)
	{
		return;
	}
	const auto TimeScale = Settings-&gt;TimeScale;
	const auto DeltaTime = Systems.GetWorld()-&gt;GetDeltaSeconds() * TimeScale;

	Systems.Query&lt;UVelocityComponent&gt;().ForEach(
		[&amp;](auto&amp; QueryItem)
		{
			auto* Actor = QueryItem.Get&lt;0&gt;();
			const auto* Velocity = QueryItem.Get&lt;1&gt;();
			const auto Position = Actor-&gt;GetActorLocation();

			Actor-&gt;SetActorLocation(Position + Velocity-&gt;Value * DeltaTime);
		});
}
</code></pre>
<pre><code class="language-cpp">void UExampleGameInstance::Init()
{
	Super::Init();

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;AcquireSystemsWorld(FName(),
			[&amp;](auto&amp; Systems)
			{
				Systems.RegisterComponent&lt;UVelocityComponent&gt;();

				Systems.InstallLambdaSystem(MovementSystem, FInstallSystemOptions(&quot;Movement&quot;));
			});
	}
}
</code></pre>
<h2 id="stateful-systems"><a class="header" href="#stateful-systems">Stateful systems</a></h2>
<p>Stateful systems are useful in cases where system requires some internal state that cannot be
shared with other systems via resources (for example internal cache that is used to track changes
in the system across multiple game ticks).</p>
<pre><code class="language-cpp">UCLASS()
class EXAMPLE_API ULogBirdsNumberChangeSystem : public USystem
{
	GENERATED_BODY()

public:
	virtual void Run(USystemsWorld&amp; Systems) override;

	UPROPERTY()
	uint32 LastCount = 0;
};

void ULogBirdsNumberChangeSystem::Run(USystemsWorld&amp; Systems)
{
	Super::Run(Systems);

	if (Systems.ComponentsDidChanged&lt;UBirdComponent&gt;() == false)
	{
		return;
	}

	const auto Number = static_cast&lt;int&gt;(Systems.Query&lt;UBirdComponent&gt;().Count());
	const Difference = Number - this-&gt;LastCount;
	this-&gt;LastCount = Number;

	if (Difference &gt; 0)
	{
		UE_LOG(LogTemp, Warning, TEXT(&quot;Added %i birds&quot;), Difference);
	}
	else if (Difference &lt; 0)
	{
		UE_LOG(LogTemp, Warning, TEXT(&quot;Removed %i birds&quot;), -Difference);
	}
}
</code></pre>
<pre><code class="language-cpp">void UExampleGameInstance::Init()
{
	Super::Init();

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;AcquireSystemsWorld(FName(),
			[&amp;](auto&amp; Systems)
			{
				Systems.RegisterComponent&lt;UBirdComponent&gt;();

				Systems.InstallSystem&lt;ULogBirdsNumberChangeSystem&gt;(FInstallSystemOptions(&quot;LogBirdsNumberChange&quot;));
			});
	}
}
</code></pre>
<h1 id="problems-that-it-solves-1"><a class="header" href="#problems-that-it-solves-1">Problems that it solves</a></h1>
<p>There is very common (bad) practice in the industry that we make a game prototype, then <strong>we build
actual game on top of that prototype codebase</strong>, instead of treating it purely as a reference for
an actual, properly implemented solutions in actual project - this can and will quickly lead to
poisoned codebase months and years later. It is really hard to break that habit, mostly in
professional game development because time budget and famous last words such as <a href="https://www.youtube.com/watch?v=SETnK2ny1R0">&quot;we will refactor
that later&quot;</a>, but that &quot;later&quot; do not come as soon as
we would like, making us having a weak foundation and we build new features on top of that weak
foundation, <strong>basically playing Jenga with our codebase</strong>, codebase which parts of will fall later
as the project grows, causing <strong>The Fuck Cascade <sup>TM.</sup></strong> and frustration later on - we can
do better than that.</p>
<p>Systems Architecture helps with that by forcing simple and modular codebase from the get go,
making switching from prototype to actual implementation a matter of just swapping prototype
systems with actual properly implemented systems, sometimes not even having to change them at all.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<h1 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of contents</a></h1>
<ul>
<li><a href="book/architecture/components.html#explanation">Explanation</a></li>
<li><a href="book/architecture/components.html#problems-that-it-solves">Problems that it solves</a></li>
</ul>
<h1 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h1>
<p>See <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystemsActorComponent.html"><strong><code>USystemsActorComponent</code></strong></a> and <a href="book/architecture//reference/classes/USystemsSceneComponent.html"><strong><code>USystemsSceneComponent</code></strong></a>.</p>
<p>Systems Architecture treats game world as database that user can query. That enables us to
perform same operations on a batch of actors and their requested components in-place.</p>
<pre><code class="language-cpp">	const auto Count = static_cast&lt;int&gt;(Systems.Query&lt;UBoidComponent&gt;().Count());
	const auto Difference = Count - EXPECTED_POPULATION_NUMBER;

	if (Difference &gt; 0)
	{
		Systems.Query&lt;UBoidComponent&gt;()
			.Take(Difference)
			.ForEach(
				[](auto&amp; QueryItem)
				{
					auto* Actor = QueryItem.Get&lt;0&gt;();

					Actor-&gt;Destroy();
				});
	}
</code></pre>
<p>And all you have to do is to add or remove components on your actors of interest to enable/disabe
them for certain systems, instead of juggling or even duplicating code around many classes,
growing your hidden dependency graph. That simplifies the game logic and greatly improves
iteration times on game systems.</p>
<blockquote>
<p>Keeping data decoupled from game logic enables you to easily perform different logic on same
set of data, avoiding duplication of both logic and data, making it easier to iterate on them.</p>
</blockquote>
<p>Of course sometimes keeping some logic in componets is reasonable - good practice is to add
into actor components only these methods that do not produce any side effects outside this
component scope, which means logic that only serves to recalculate its internal state.</p>
<h1 id="problems-that-it-solves-2"><a class="header" href="#problems-that-it-solves-2">Problems that it solves</a></h1>
<p>When working with Unreal Engine, mostly as a beginner, a little bit less as an advanced user,
you find yourself slapping a lot of code into actors. The general thought wandering around
your mind at that time usually goes like this: &quot;This code is something that only this actor
does, so it's obvious that this code belongs to this actor class, duh&quot; - at that time, while
there is still not much work put in there you <em>might</em> be right, but in that case your intuition
is wrong once again.</p>
<p>Across next months you slap bits of logic there and its complexity grows. It doesn't help that
you've split it into several methods, all of that effort gets invalidated once you have to add
a second, and a third actor that does similar things, and you suddenly find yourself
redesigning proper decoupling or inheritance tree or even doing massive refactoring because
this one problem touches many seemingly unrealted places, that were part of complex hidden
dependency tree.</p>
<p>All of that could be avoided with splitting monolithic work per components, but we can do even
better and <strong>copletely decouple data from logic that we put in small dedicated systems</strong>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h1 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of contents</a></h1>
<ul>
<li><a href="book/architecture/resources.html#explanation">Explanation</a></li>
<li><a href="book/architecture/resources.html#problems-that-it-solves">Problems that it solves</a></li>
</ul>
<h1 id="explanation-3"><a class="header" href="#explanation-3">Explanation</a></h1>
<p>Resource in context of Systems Architecture is any global object that all systems should
be able to access (though resources definitely <strong>aren't singletons!</strong> - they share their
lifetime with owning systems world). Objects such as:</p>
<ul>
<li>
<p>Configuration/settings data</p>
<p>For example systems run criteria that tells the conditions under what certain systems
can run. Or Data Assets / Data Tables passed from game instance to systems world.</p>
</li>
<li>
<p>Cached data shared between systems</p>
<p>Do you have spatialization system that builds RTree for world actors to speed up spatial
queries, and other systems in need to find the closest actor to their location? You
definitely put that data in a resource object and make other systems query and read
that resource!</p>
</li>
<li>
<p>Game managers</p>
<p>Common Unreal Engine game development pattern is to create work units called &quot;managers&quot;
that manage certain state. For some solutions, epecially when dealing with third-party
plugins, we have to still have access into these managers in our systems - definitely put
them in systems world resources. </p>
</li>
</ul>
<pre><code class="language-cpp">UCLASS(BlueprintType)
class EXAMPLE_API USettings : public UDataAsset
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere)
	float TimeScale = 1;
};

void UExampleGameInstance::Init()
{
	Super::Init();

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;AcquireSystemsWorld(FName(),
			[&amp;](auto&amp; Systems)
			{
				Systems.RegisterComponent&lt;UVelocityComponent&gt;();

				// USettings asset set up in editor.
				Systems.InstallResourceRaw(this-&gt;Settings);

				Systems.InstallLambdaSystem(MovementSystem, FInstallSystemOptions(&quot;Movement&quot;));
			});
	}
}

void MovementSystem(USystemsWorld&amp; Systems)
{
	const auto* Settings = Systems.Resource&lt;USettings&gt;();
	if (IsValid(Settings) == false)
	{
		return;
	}
	const auto TimeScale = Settings-&gt;TimeScale;
	const auto DeltaTime = Systems.GetWorld()-&gt;GetDeltaSeconds() * TimeScale;

	Systems.Query&lt;UVelocityComponent&gt;().ForEach(
		[&amp;](auto&amp; QueryItem)
		{
			auto* Actor = QueryItem.Get&lt;0&gt;();
			const auto* Velocity = QueryItem.Get&lt;1&gt;();
			const auto Position = Actor-&gt;GetActorLocation();

			Actor-&gt;SetActorLocation(Position + Velocity-&gt;Value * DeltaTime);
		});
}
</code></pre>
<h1 id="problems-that-it-solves-3"><a class="header" href="#problems-that-it-solves-3">Problems that it solves</a></h1>
<p>While in most cases all what you do is you process game world queries, sometimes you require
to access some configuration data, or cache some data for use by many other systems, or you
just need to interact with third-party game managers - these are useful usecases and Systems
Architecture doesn't get rid of them, rather make their use more ergonomic, yet not giving
them global lifetime like with dangerous singletons.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subsystem"><a class="header" href="#subsystem">Subsystem</a></h1>
<h1 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of contents</a></h1>
<ul>
<li><a href="book/architecture/subsystem.html#explanation">Explanation</a></li>
<li><a href="book/architecture/subsystem.html#examples">Examples</a>
<ul>
<li><a href="book/architecture/subsystem.html#game-instance">Game instance</a></li>
<li><a href="book/architecture/subsystem.html#game-mode">Game mode</a></li>
</ul>
</li>
</ul>
<h1 id="explanation-4"><a class="header" href="#explanation-4">Explanation</a></h1>
<p>For the sake of convenience Systems Architecture provides handy wrapper over
<a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html"><strong><code>USystemsWorld</code></strong></a> global instances as a <a href="book/architecture//reference/classes/USystemsSubsystem.html"><strong><code>USystemsSubsystem</code></strong></a>
that is basically a registry of systems worlds accessible from any place in the code.</p>
<p>All user needs to do is to register and setup systems world using
<a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystemsSubsystem.html#acquiresystemsworld"><strong><code>USystemsSubsystem::AcquireSystemsWorld</code></strong></a> when certain game phase starts
(either game, level, menu, etc) before adding/removing/querying actor components, and
unregister systems world using <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystemsSubsystem.html#releasesystemsworld"><strong><code>USystemsSubsystem::ReleaseSystemsWorld</code></strong></a>
when given game phase ends.</p>
<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>The most common game phases where systems might exists are game instance and game mode.</p>
<ul>
<li>You register systems world in game instance when there are systems are possible
to run during entire game lifetime. This is the easiest and safest option.</li>
<li>You register systems world in game mode when there are systems that are possible
to run during given game level lifetime. This is useful if we for example have completely
separate pipelines set for each level or game mode.</li>
</ul>
<h2 id="game-instance"><a class="header" href="#game-instance">Game instance</a></h2>
<p>Since game instance has a lifetime of entire game run, we only care here about
registering systems world to subsystem on <code>UGameInstance::Init</code>.</p>
<pre><code class="language-cpp">UCLASS()
class EXAMPLE_API UExampleGameInstance : public UGameInstance
{
	GENERATED_BODY()

private:
	virtual void Init() override;
};

void UExampleGameInstance::Init()
{
	Super::Init();

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;AcquireSystemsWorld(FName(),
			[&amp;](auto&amp; Systems)
			{
				Systems.RegisterComponent&lt;UShiaComponent&gt;();

				Systems.InstallResource&lt;UShiaSettings&gt;();

				Systems.InstallLambdaSystem(JustDoItSystem, FInstallSystemOptions(&quot;JustDoIt&quot;));
			});
	}
}
</code></pre>
<h2 id="game-mode"><a class="header" href="#game-mode">Game mode</a></h2>
<p>When it comes to game mode, we should register systems world on <code>AGameModeBase::InitGame</code>
(it runs before any actor <code>BeginPlay</code> - if we register it on <code>BeginPlay</code>, then some
actors placed on level might try to register to yet non-existing systems world) and
unregister it on <code>AGameModeBase::EndPlay</code>.</p>
<pre><code class="language-cpp">UCLASS()
class EXAMPLE_API AExampleGameMode : public AGameModeBase
{
	GENERATED_BODY()

private:
	virtual void InitGame(const FString&amp; MapName, const FString&amp; Options, FString&amp; ErrorMessage) override;

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
};

void AExampleGameMode::InitGame(const FString&amp; MapName, const FString&amp; Options, FString&amp; ErrorMessage)
{
	Super::InitGame(MapName, Options, ErrorMessage);

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;AcquireSystemsWorld(FName(),
			[&amp;](auto&amp; Systems)
			{
				Systems.RegisterComponent&lt;UShiaComponent&gt;();

				Systems.InstallResource&lt;UShiaSettings&gt;();

				Systems.InstallLambdaSystem(JustDoItSystem, FInstallSystemOptions(&quot;JustDoIt&quot;));
			});
	}
}

void AExampleGameMode::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;ReleaseSystemsWorld(ThisClass::SYSTEMS_WORLD);
	}
}
</code></pre>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipelines"><a class="header" href="#pipelines">Pipelines</a></h1>
<h1 id="table-of-contents-6"><a class="header" href="#table-of-contents-6">Table of contents</a></h1>
<ul>
<li><a href="book/architecture/pipelines.html#explanation-and-setup">Explanation and setup</a>
<ul>
<li><a href="book/architecture/pipelines.html#components">Components</a></li>
<li><a href="book/architecture/pipelines.html#resources">Resources</a>
<ul>
<li><a href="book/architecture/pipelines.html#type-resources">Type resources</a></li>
<li><a href="book/architecture/pipelines.html#asset-resources">Asset resources</a></li>
</ul>
</li>
<li><a href="book/architecture/pipelines.html#systems">Systems</a>
<ul>
<li><a href="book/architecture/pipelines.html#stateful-systems">Stateful systems</a></li>
<li><a href="book/architecture/pipelines.html#stateless-systems">Stateless systems</a></li>
<li><a href="book/architecture/pipelines.html#blueprint-systems">Blueprint systems</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="book/architecture/pipelines.html#using-pipeline-data-assets">Using pipeline data assets</a>
<ul>
<li><a href="book/architecture/pipelines.html#systems-game-mode">Systems game mode</a></li>
<li><a href="book/architecture/pipelines.html#systems-game-state">Systems game state</a></li>
</ul>
</li>
</ul>
<h1 id="explanation-and-setup"><a class="header" href="#explanation-and-setup">Explanation and setup</a></h1>
<p>See <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystemsPipeline.html"><strong><code>USystemsPipeline</code></strong></a>.</p>
<p>Systems pipeline is a data asset that describes configuration of a single systems world:
its components, resources and systems that should be installed for new systems world.
Given pipeline is then assigned to either <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/ASystemsGameMode.html"><strong><code>ASystemsGameMode</code></strong></a> or
<a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/ASystemsGameState.html"><strong><code>ASystemsGameState</code></strong></a> to automatically create and destroy dedicated systems world.</p>
<p>Having systems pipeline defined in a data asset simplifies systems world setup and gives
more flexibility to game designers so they can balance and test special cases and new game
features without asking programmers to take their time and make changes to the setup.</p>
<p><img src="book/architecture/../../assets/systems_pipeline.png" alt="Data Asset" /></p>
<ul>
<li><strong><code>World Id</code></strong> - ID under which this pipeline systems world will be registered globally.
Usually there is gonna be single systems world so it's best to leave <code>None</code> here, but in
rare cases there might be sometimes a need to for multiple systems worlds in the game at
once so here user can specify that.</li>
</ul>
<h2 id="components-1"><a class="header" href="#components-1">Components</a></h2>
<p>See components <a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/components.html">architecture book page</a>.</p>
<p>List of all component types that are gonna be recognized by this systems world.</p>
<p><img src="book/architecture/../../assets/systems_pipeline_components.png" alt="Components" /></p>
<ul>
<li><strong><code>Development Build Only</code></strong> - Ensures this component will be registered in development
builds only (and editor builds).</li>
<li><strong><code>Use</code></strong> - Useful for quickly disabling given component from the pipeline without actually
removing it, can be used for quick dirty tests.</li>
</ul>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<p>See resources <a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/resources.html">architecture book page</a>.</p>
<h3 id="type-resources"><a class="header" href="#type-resources">Type resources</a></h3>
<p>List of type resources to install.</p>
<p>Type resources are usually just a typical <code>UObject</code>-based
game managers, 3rd-party library wrappers, data shared runtime data cache/storage and such.</p>
<p><img src="book/architecture/../../assets/systems_pipeline_type_resources.png" alt="Type Resources" /></p>
<h3 id="asset-resources"><a class="header" href="#asset-resources">Asset resources</a></h3>
<p>List of asset resourecs to install.</p>
<p>Asset resources are purely data (either baked data sources
or systems settings) that will be used by systems.</p>
<p><img src="book/architecture/../../assets/systems_pipeline_asset_resources.png" alt="Asset Resources" /></p>
<ul>
<li><strong><code>Development Build Only</code></strong> - Ensures this resource will be registered in development
builds only (and editor builds).</li>
<li><strong><code>Use</code></strong> - Useful for quickly disabling given resource from the pipeline without actually
removing it, can be used for quick dirty tests.</li>
</ul>
<h2 id="systems-1"><a class="header" href="#systems-1">Systems</a></h2>
<p>See systems <a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/systems.html">architecture book page</a>.</p>
<p>Here we list all of the systems that are gonna be used by this pipeline's systems world.</p>
<blockquote>
<p>Order of systems in the list represents order of their execution!</p>
</blockquote>
<p><img src="book/architecture/../../assets/systems_pipeline_systems.png" alt="Systems" /></p>
<ul>
<li><strong><code>Template</code></strong> - Template <code>USystem</code>-based object that can be configured in-place.</li>
<li><strong><code>Development Build Only</code></strong> - Ensures this system will be registered in development
builds only (and editor builds).</li>
<li><strong><code>Use</code></strong> - Useful for quickly disabling given system from the pipeline without actually
removing it, can be used for quick dirty tests.</li>
</ul>
<blockquote>
<p>Note the difference between category of systems:</p>
<ul>
<li><code>Startup</code> - Runs only at systems world installation.</li>
<li><code>Persistent</code> - Runs on every game frame.</li>
<li><code>Cleanup</code> - Runs only at systems world uninstallation.</li>
</ul>
</blockquote>
<p>Commonly used template types:</p>
<h3 id="stateful-systems-1"><a class="header" href="#stateful-systems-1">Stateful systems</a></h3>
<p>Stateful systems are ones that can have configuration properties put in them and/or can hold
internal state (for example to cache some values between next system runs, change detection
for example). User makes them by inheriting directly from <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystem.html"><strong><code>USystem</code></strong></a> class.</p>
<h3 id="stateless-systems-1"><a class="header" href="#stateless-systems-1">Stateless systems</a></h3>
<p>Stateless systems are basically lambdas/functions registered into <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/FSystemsReflection.html"><strong><code>FSystemsReflection</code></strong></a>.</p>
<p><img src="book/architecture/../../assets/systems_pipeline_lambda_systems.png" alt="Lambda Systems" /></p>
<p>The reason for lambda systems to be registered is that Unreal doesn't come with it's own global
function reflection so we have to put these into a dedicated registry ourselves, so we can assign
them in <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/ULambdaSystem.html"><strong><code>ULambdaSystem</code></strong></a>'s <code>Function Name</code> property.</p>
<p>Every game or plugin module that exposes its lambda systems, has to register them in module
<code>StartupModule</code> and <code>ShutdownModule</code> methods like this:</p>
<pre><code class="language-c++">#include &quot;Tutorial.h&quot;

#include &quot;Systems/Public/SystemsReflection.h&quot;

#include &quot;Tutorial/Systems/Persistent/TutorialGoToSystem.h&quot;
#include &quot;Tutorial/Systems/Persistent/TutorialMoveTowardsTargetSystem.h&quot;
#include &quot;Tutorial/Systems/Persistent/TutorialMovementSystem.h&quot;
#include &quot;Tutorial/Systems/Persistent/TutorialSelectActorsSystem.h&quot;

#define LOCTEXT_NAMESPACE &quot;FTutorialModule&quot;
#define SYSTEMS_NAMESPACE &quot;Tutorial&quot;

void FTutorialModule::StartupModule()
{
	REGISTER_SYSTEM_FUNCTION(TutorialGoToSystem);
	REGISTER_SYSTEM_FUNCTION(TutorialMoveTowardsTargetSystem);
	REGISTER_SYSTEM_FUNCTION(TutorialMovementSystem);
	REGISTER_SYSTEM_FUNCTION(TutorialSelectActorsSystem);
}

void FTutorialModule::ShutdownModule()
{
	UNREGISTER_SYSTEM_FUNCTION(TutorialGoToSystem);
	UNREGISTER_SYSTEM_FUNCTION(TutorialMoveTowardsTargetSystem);
	UNREGISTER_SYSTEM_FUNCTION(TutorialMovementSystem);
	UNREGISTER_SYSTEM_FUNCTION(TutorialSelectActorsSystem);
}

#undef LOCTEXT_NAMESPACE
#undef SYSTEMS_NAMESPACE

IMPLEMENT_GAME_MODULE(FTutorialModule, Tutorial);
</code></pre>
<h3 id="blueprint-systems"><a class="header" href="#blueprint-systems">Blueprint systems</a></h3>
<p>Blueprint systems are systems made for quick and dirty prototyping by technical designers and
content creators, they serve purely as final reference for programmers to translate them into
native C++ systems. They exists exactly for scenarios where technical designer or content creator
has an idea for a game feature they want to quickly make and test its viability, without bothering
programmers to put their hands into every aspect of it, making feature design phase much faster
and removing every back-and-forth between programmers and idea owners.</p>
<p>Blueprint systems are made up of two objects:</p>
<ul>
<li>Query blueprint with public properties that represents what components (and optionally actor) query
expects to iterate on.</li>
<li>System blueprint with <code>OnRun</code> event that performs one or more queries on systems world.</li>
</ul>
<p>Here is example of creating blueprint systems:</p>
<ol>
<li>
<p>Create new game object that inherits from <code>UObject</code>:</p>
<p><img src="book/architecture/../../assets/systems_pipeline_create_query_object.png" alt="Create new object" /></p>
<p>And name it <code>BP_ShakeSystemQuery</code>.</p>
</li>
<li>
<p>Create public properties of actor/scene component types (and optionally an actor) your system query
wants to iterate on:</p>
<p><img src="book/architecture/../../assets/systems_pipeline_query_object.png" alt="Create query properties" /></p>
</li>
<li>
<p>Create new game object that inherits from <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/UScriptableSystem.html"><strong><code>UScriptableSystem</code></strong></a>:</p>
<p><img src="book/architecture/../../assets/systems_pipeline_create_scriptable_system.png" alt="Create new system" /></p>
<p>And name it <code>BP_ShakeSystem</code>.</p>
</li>
<li>
<p>Create <code>System World Query</code> node and assign <code>BP_ShakeSystemQuery</code> object class:</p>
<p><img src="book/architecture/../../assets/systems_pipeline_system_query_a.png" alt="System query A" /></p>
<p>With this we tell tis query iterator it will yield <code>BP_ShakeSystemQuery</code> objects with requested components
and actor assigned to its fields.</p>
</li>
<li>
<p>Create <code>Lazy Iterate</code> node:</p>
<p><img src="book/architecture/../../assets/systems_pipeline_system_query_b.png" alt="System query B" /></p>
<p>Since <code>Query</code> returns a lazy iterator object (you can read about lazy iterators in
<a href="book/architecture//Unreal-Systems-Architecture/systems/book/architecture/iterators.html">this architecture book page</a>), this node is a <code>For Each</code> equivalent,
to iterate over this iterator elements.</p>
</li>
<li>
<p>Apply changes to actor offset component we got from yielded query object:</p>
<p><img src="book/architecture/../../assets/systems_pipeline_system_query_c.png" alt="System query C" /></p>
</li>
</ol>
<h1 id="using-pipeline-data-assets"><a class="header" href="#using-pipeline-data-assets">Using pipeline data assets</a></h1>
<p>While you can call <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystemsPipeline.html#install"><strong><code>USystemsPipeline::Install</code></strong></a> and <a href="book/architecture//reference/classes/USystemsPipeline.html#uninstall"><strong><code>USystemsPipeline::Uninstall</code></strong></a>
directly to install and uninstall given pipeline systems world globally, it is useful to have that automated,
and for that these are game objects that do this for you, based on pipeline data asset assigned to them
in the editor:</p>
<h2 id="systems-game-mode"><a class="header" href="#systems-game-mode">Systems game mode</a></h2>
<p>See <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/ASystemsGameMode.html"><strong><code>ASystemsGameMode</code></strong></a>.</p>
<p>Consider using it to install pipeline that has to run singleplayer or multiplayer server game logic (since game modes are spawned only there).</p>
<ol>
<li>
<p>Create game mode that inerits from <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/ASystemsGameMode.html"><strong><code>ASystemsGameMode</code></strong></a>:</p>
<p><img src="book/architecture/../../assets/systems_pipeline_game_mode_a.png" alt="Systems game mode A" /></p>
<p>And name it <code>BP_TutorialGameMode</code>.</p>
</li>
<li>
<p>Assign <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystemsPipeline.html"><strong><code>USystemsPipeline</code></strong></a> data asset into <code>Systems Pipeline</code> property:</p>
<p><img src="book/architecture/../../assets/systems_pipeline_game_mode_b.png" alt="Systems game mode B" /></p>
</li>
</ol>
<h2 id="systems-game-state"><a class="header" href="#systems-game-state">Systems game state</a></h2>
<p>See <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/ASystemsGameState.html"><strong><code>ASystemsGameState</code></strong></a>.</p>
<p>Consider using it to install pipeline that has to run multiplayer client game logic (internally it will enforce to install only on multiplayer client).</p>
<ol>
<li>
<p>Create game state that inerits from <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/ASystemsGameState.html"><strong><code>ASystemsGameState</code></strong></a>:</p>
<p><img src="book/architecture/../../assets/systems_pipeline_game_state_a.png" alt="Systems game state A" /></p>
<p>And name it <code>BP_TutorialGameState</code>.</p>
</li>
<li>
<p>Assign <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/classes/USystemsPipeline.html"><strong><code>USystemsPipeline</code></strong></a> data asset into <code>Systems Pipeline</code> property:</p>
<p><img src="book/architecture/../../assets/systems_pipeline_game_state_b.png" alt="Systems game state B" /></p>
</li>
<li>
<p>Additionally you assign this game state class in its sibling game mode:</p>
<p><img src="book/architecture/../../assets/systems_pipeline_game_state_c.png" alt="Systems game state C" /></p>
<p>To make server game mode spawn this game state with its pipeline on clients.</p>
</li>
</ol>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<h1 id="table-of-contents-7"><a class="header" href="#table-of-contents-7">Table of contents</a></h1>
<ul>
<li><a href="book/architecture/iterators.html#explanation">Explanation</a></li>
<li><a href="book/architecture/iterators.html#types-of-iterators">Types of iterators</a></li>
<li><a href="book/architecture/iterators.html#creating-custom-iterators">Creating custom iterators</a>
<ul>
<li><a href="book/architecture/iterators.html#anatomy-of-iterators">Anatomy of iterators</a></li>
<li><a href="book/architecture/iterators.html#iterator-adapters">Iterator adapters</a></li>
</ul>
</li>
</ul>
<h1 id="explanation-5"><a class="header" href="#explanation-5">Explanation</a></h1>
<p>Iterators, or more precisely lazy iterators, are an useful tool for more efficient and
ergonomic processing of collections and procedural generators. Lazy iterators are lazy
because on their own they do not yield any values until consumed.</p>
<pre><code class="language-cpp">// [0.0, 4.0, 16.0, 36.0, 64.0]
const TArray&lt;float&gt; Result = IterRange(0, 10)
								 .Filter([](const auto&amp; Value) { return Value % 2 == 0; })
								 .Map&lt;float&gt;([](const auto&amp; Value) { return static_cast&lt;float&gt;(Value * Value); })
								 .CollectArray();
</code></pre>
<p>This lazyness allows us to produce more elaborated processing over data without making
unnecessary caching between iteration stages, and that also makes iteration code cleaner
and easier to reason about.</p>
<h1 id="types-of-iterators"><a class="header" href="#types-of-iterators">Types of iterators</a></h1>
<ul>
<li>
<p>Consumers</p>
<p>Consumers are final iterators that consume yielded values and produce some result out
of it, usually single value.</p>
<pre><code class="language-cpp">// 5
const TOptional&lt;int&gt; Result = IterRange(0, 10).Find([](const auto&amp; Value) { return Value &gt;= 5; });
</code></pre>
<ul>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#count"><strong><code>TQuery::Count</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#nth"><strong><code>TQuery::Nth</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#fold"><strong><code>TQuery::Fold</code></strong></a></li>
<li><code>IterSum</code></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#nth"><strong><code>TQuery::Nth</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#find"><strong><code>TQuery::Find</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#findmap"><strong><code>TQuery::FindMap</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#first"><strong><code>TQuery::First</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#last"><strong><code>TQuery::Last</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#foreach"><strong><code>TQuery::ForEach</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#any"><strong><code>TQuery::Any</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#all"><strong><code>TQuery::All</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#comparedby"><strong><code>TQuery::ComparedBy</code></strong></a></li>
</ul>
</li>
<li>
<p>Colectors</p>
<p>Collectors are special kind of consumer iterators that are an explicit way to collect
all yielded values into commonly used collections such as <code>TArray</code>, <code>TSet</code> and <code>TMap</code>.</p>
<pre><code class="language-cpp">const TArray&lt;int&gt; Result = IterRange(0, 10).CollectArray();
</code></pre>
<ul>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#collectarray"><strong><code>TQuery::CollectArray</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#collectintoarray"><strong><code>TQuery::CollectIntoArray</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#collectset"><strong><code>TQuery::CollectSet</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#collectintoset"><strong><code>TQuery::CollectIntoSet</code></strong></a></li>
<li><code>IterCollectMap</code></li>
<li><code>IterCollectIntoMap</code></li>
</ul>
</li>
<li>
<p>Converters</p>
<p>Converters are stages of iteration that converts values yielded by previous iteration
stages into some new values.</p>
<pre><code class="language-cpp">// [0.0, 4.0, 16.0, 36.0, 64.0]
const TArray&lt;float&gt; Result = IterRange(0, 10)
								 .Filter([](const auto&amp; Value) { return Value % 2 == 0; })
								 .Map&lt;float&gt;([](const auto&amp; Value) { return static_cast&lt;float&gt;(Value * Value); })
								 .CollectArray();
</code></pre>
<ul>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#adapt"><strong><code>TQuery::Adapt</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#chain"><strong><code>TQuery::Chain</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#enumerate"><strong><code>TQuery::Enumerate</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#filter"><strong><code>TQuery::Filter</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#filtermap"><strong><code>TQuery::FilterMap</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#flatten"><strong><code>TQuery::Flatten</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#inspect"><strong><code>TQuery::Inspect</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#map"><strong><code>TQuery::Map</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#skip"><strong><code>TQuery::Skip</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#take"><strong><code>TQuery::Take</code></strong></a></li>
<li><a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#zip"><strong><code>TQuery::Zip</code></strong></a></li>
</ul>
</li>
</ul>
<h1 id="creating-custom-iterators"><a class="header" href="#creating-custom-iterators">Creating custom iterators</a></h1>
<p>While built-in iterators provided by SystemsArchitecture should be enough for common usecases,
sometimes for more advanced solutions you might find yourself in a need of creating a custom
iterator that cannot be solved using built-in ones.</p>
<h2 id="anatomy-if-iterators"><a class="header" href="#anatomy-if-iterators">Anatomy if iterators</a></h2>
<p>Let's take a look at Repeat iterator:</p>
<pre><code class="language-cpp">#pragma once

#include &quot;CoreMinimal.h&quot;

// Make sure to include converters declaration header first.
#include &quot;Systems/Public/Iterator/ConvertersDecl.h&quot;

// Then converters, macros and size hint, order doesn't matter here.
#include &quot;Systems/Public/Iterator/Converters.h&quot;
#include &quot;Systems/Public/Iterator/Macros.h&quot;
#include &quot;Systems/Public/Iterator/SizeHint.h&quot;

// This iterator is generalized over type of values it yields.
template &lt;typename T&gt;
struct TIterRepeat
{
public:
	// We need to provide type aliases for iterators injected with macros will
	// properly understand this iterato when wrapping it internally.
	using Self = TIterRepeat&lt;T&gt;;
	using Item = typename T;

	TIterRepeat() : Value(TOptional&lt;T&gt;())
	{
	}

	TIterRepeat(T Data) : Value(TOptional&lt;T&gt;(Data))
	{
	}

	// Provide `Next` method that returns optional value of item type.
	TOptional&lt;Item&gt; Next()
	{
		return TOptional&lt;T&gt;(this-&gt;Value);
	}

	// Provide `Sizehint` method thar returns hint about estimated range of
	// items it can yield.
	IterSizeHint SizeHint() const
	{
		return IterSizeHint{0, TOptional&lt;uint32&gt;()};
	}

private:
	TOptional&lt;T&gt; Value = {};

public:
	// To make iterators chains we call special macro that injects all other
	// built-in iterators as this one methods.
	ITER_IMPL
};

// Provide handy construction function for ergonomics, just because of C++
// having easier times with types deduction on them.
template &lt;typename T&gt;
TIterRepeat&lt;T&gt; IterRepeat(T Value)
{
	return TIterRepeat&lt;T&gt;(Value);
}
</code></pre>
<ul>
<li>
<p><code>Self</code> type alias</p>
<p>Iterators chaining is done by wrapping consecutive iterators in one another so when consumer
calls <code>Next</code>, it internally calls <code>Next</code> of iterator it wraps, and so on. To make them easily
injectable with macros, they use <code>Self</code> as an alias for their type.</p>
</li>
<li>
<p><code>Item</code> type alias</p>
<p>Type alias for type of value that this iterator yields. Not stores, not takes as an input -
exactly one that it yields. This is again used for iterators wrapping purposes so converter
iterators that wraps other iterators can identify value type of previous one in chain by
<code>typename ITERATOR::Item</code>.</p>
</li>
<li>
<p><code>Next</code> method</p>
<p>Every iterator should implement <code>TOptional&lt;Item&gt; Next()</code> method. This method does the actual
job of yielding a value.</p>
<p>See <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#next"><strong><code>TQuery::Next</code></strong></a>.</p>
</li>
<li>
<p><code>SizeHint</code> method.</p>
<p>Size hints are used by for example collector iterators to estimate the capacity of collection
where yielded data will be stored. This at most removes reallocations when adding every next
value into that collection, and at least reduces it to some reasonable number.</p>
<p>Finite iterators will give lower bounds and upper bounds set, infinite iterators will give
only lower bounds.</p>
<p>See <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#sizehint"><strong><code>TQuery::SizeHint</code></strong></a>, <a href="book/architecture//reference/structs/IterSizeHint.html"><strong><code>IterSizeHint</code></strong></a>.</p>
</li>
<li>
<p><code>ITER_IMPL</code> macro</p>
<p>This macro injects other iterators as methods of this one. Without it user would be left with
ugly iterators chains made by passing next stages as argument to iterator functions/constructors.</p>
</li>
</ul>
<h2 id="iterator-adapters"><a class="header" href="#iterator-adapters">Iterator adapters</a></h2>
<p>In some rare cases you might find yourself struggling to express your data processing with built-in
iterators, or you must to make some optimizations that cannot be solved using provided ones. For
this advanced usecase you can create custom iterator adapters that works basically the same way as
converter iterators.</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct TIterOddAdapter
{
public:
	template &lt;typename I&gt;
	TOptional&lt;T&gt; Next(I&amp; Iter)
	{
		Iter.Next();
		return Iter.Next();
	}

	template &lt;typename I&gt;
	IterSizeHint SizeHint(const I&amp; Iter) const
	{
		return Iter.SizeHint();
	}
};
</code></pre>
<pre><code class="language-cpp">// [1, 3, 5, 7, 9]
const TArray&lt;int&gt; Result = IterRange(0, 10).Adapt(TIterOddAdapter&lt;int&gt;()).CollectArray();
</code></pre>
<p>They differ from regular iterators in a way that they do not need type aliases and their <code>Next</code> and
<code>SizeHint</code> methods require reference to previous stage iterator so they both consume and process its
yielded values.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<h1 id="table-of-contents-8"><a class="header" href="#table-of-contents-8">Table of contents</a></h1>
<ul>
<li><a href="book/architecture/channels.html#explanation">Explanation</a></li>
<li><a href="book/architecture/channels.html#problems-that-it-solves">Problems that it solves</a></li>
</ul>
<h1 id="explanation-6"><a class="header" href="#explanation-6">Explanation</a></h1>
<p>See <a href="book/architecture//Unreal-Systems-Architecture/systems/reference/structs/TSenderChannel.html"><strong><code>TSenderChannel</code></strong></a>, <a href="book/architecture//reference/structs/TReceiverChannel.html"><strong><code>TReceiverChannel</code></strong></a>.</p>
<p>Shared channels are Single-Produce, Multiple-Consumer events that instead
being executed at the time of sending message (pushing), they are executed
at the time of receiving, which is an on-demand operation - user decides
when to read messages received in event.</p>
<pre><code class="language-cpp">	auto Sender = TSenderChannel&lt;int&gt;();
	auto Receiver = Sender.Receiver(1);

	Sender.Send(42);
	while (const auto Value = Receiver.Receive())
	{
		UE_LOG(LogTemp, Warning, TEXT(&quot;Received value: %i&quot;), Value);
	}
</code></pre>
<p>Internally channels work as a ring buffer behind thread-safe shared pointer
in receiver channel, and sender channel only holds a weak pointer to list
of registered receivers. When you want to subscribe to a channel, you create
a receiver and store that receiver somewhere.</p>
<blockquote>
<p>It's important to note that receiver is bound to a sender channel as long
as it exists, so there is no need for intentional unbinds, it is all
automated by its design.</p>
</blockquote>
<p>After you have sender and receivers made, when you tell sender channel to
send message, it goes through all weak pointers pointing to receiver
channels, and write cloned data into each of their queues. <strong>Messages are
stored, but not yet executed</strong>.</p>
<p>When you want to receive and execute a message, just make receiver read
sequence of next messages in queue and do something useful with them.
That's all, simple isn't it?</p>
<h1 id="problems-that-it-solves-4"><a class="header" href="#problems-that-it-solves-4">Problems that it solves</a></h1>
<p>There is only one but big problem that it solves - making more
deterministic and ordered data flow between parts of game logic. That way
we avoid situations where objects communicating with each other are
dependend on proper order of messages being sent and received but we can't
ensure that order. We also avoid event cycles, where there is set of event
points that suddenly gets connected in a way that introduces a cycle of
passing messages, leading to game freezes/crashes due to stack overflow, or
simply just situations where some data gets passed too early and
invalidates dependent object state causing unnecessary state recalculations
later by other objects trying to get some data out of it.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-materials"><a class="header" href="#learning-materials">Learning materials</a></h1>
<p>List of learning materials that showcase common and special case usage of Systems Architecture.</p>
<h1 id="pages-2"><a class="header" href="#pages-2">Pages</a></h1>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>Here we will showcase step-by-step process of basic usage of Systems Architecture.</p>
<h1 id="pages-3"><a class="header" href="#pages-3">Pages</a></h1>
<ul>
<li><a href="book/learning_materials/tutorial//Unreal-Systems-Architecture/systems/book/learning_materials/tutorial/installation.html">Installation</a></li>
<li><a href="book/learning_materials/tutorial//Unreal-Systems-Architecture/systems/book/learning_materials/tutorial/setup_component.html">Setup component</a></li>
<li><a href="book/learning_materials/tutorial//Unreal-Systems-Architecture/systems/book/learning_materials/tutorial/setup_actor.html">Setup actor</a></li>
<li><a href="book/learning_materials/tutorial//Unreal-Systems-Architecture/systems/book/learning_materials/tutorial/setup_system.html">Setup system</a></li>
<li><a href="book/learning_materials/tutorial//Unreal-Systems-Architecture/systems/book/learning_materials/tutorial/setup_game.html">Setup game</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Until plugin gets accepted to Unreal Engine Marketplace, we need to install plugin
from GitHub.</p>
<ol>
<li>
<p>Download plugin from <a href="book/learning_materials/tutorial/%5Bhttps://github.com/PsichiX/Unreal-Systems-Architecture/releases%5D">GitHub Release page</a>
(core plugin is in <code>Systems-Architecture.zip</code> archive file).</p>
</li>
<li>
<p>Make sure project folder structure contains <code>Plugins</code> folder in its root (next
to <code>Content</code> and <code>Source</code> folders), then unzip its content into <code>Plugins</code> folder.</p>
</li>
<li>
<p>Launch editor and confirm plugin is properly by trying to create new data asset
of <a href="book/learning_materials/tutorial//Unreal-Systems-Architecture/systems/reference/classes/USystemsPipeline.html"><strong><code>USystemsPipeline</code></strong></a> type:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_pipeline_create_data_asset.png" alt="Create pipeline data asset" /></p>
</li>
</ol>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-component"><a class="header" href="#setup-component">Setup component</a></h1>
<ul>
<li><a href="book/learning_materials/tutorial/setup_component.html#c">C++ implementation</a></li>
<li><a href="book/learning_materials/tutorial/setup_component.html#blueprint">Blueprint implementation</a></li>
</ul>
<h1 id="c"><a class="header" href="#c">C++</a></h1>
<ul>
<li>
<p><code>Tutorial/Components/TutorialMovementComponent.h</code>:</p>
<pre><code class="language-cpp">#pragma once

#include &quot;CoreMinimal.h&quot;

#include &quot;Systems/Public/SystemsComponent.h&quot;

#include &quot;TutorialMovementComponent.generated.h&quot;

UCLASS(BlueprintType, Blueprintable, Meta = (BlueprintSpawnableComponent))
class TUTORIAL_API UTutorialMovementComponent : public USystemsActorComponent
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FVector2D Value = FVector2D(0);
};
</code></pre>
</li>
<li>
<p><code>Tutorial/Components/TutorialMovementComponent.cpp</code>:</p>
<pre><code class="language-cpp">#include &quot;Tutorial/Components/TutorialMovementComponent.h&quot;
</code></pre>
</li>
</ul>
<h1 id="blueprint"><a class="header" href="#blueprint">Blueprint</a></h1>
<ol>
<li>
<p>Create new game object that inherits from <a href="book/learning_materials/tutorial//Unreal-Systems-Architecture/systems/reference/classes/USystemsActorComponent.html"><strong><code>USystemsActorComponent</code></strong></a>:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_component_create.png" alt="Create component" /></p>
<p>And name it <code>BP_TutorialMovement</code>.</p>
</li>
<li>
<p>Add <code>Value</code> property of <code>Vector</code> type:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_component_properties.png" alt="Add properties" /></p>
</li>
</ol>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-actor"><a class="header" href="#setup-actor">Setup actor</a></h1>
<ol>
<li>
<p>Create new game object that inherits from <a href="book/learning_materials/tutorial//Unreal-Systems-Architecture/systems/reference/classes/ASystemsActor.html"><strong><code>ASystemsActor</code></strong></a> or <code>Actor</code>
(if you don't need automatic built-in engine components registration based on
<code>Systems</code> tag) - same for pawns (<a href="book/learning_materials/tutorial//Unreal-Systems-Architecture/systems/reference/classes/ASystemsPawn.html"><strong><code>ASystemsPawn</code></strong></a> or <code>Pawn</code>):</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_actor_create.png" alt="Create actor" /></p>
<p>And name it <code>BP_Entity</code>.</p>
</li>
<li>
<p>Add <code>BP_TutorialMovement</code> component:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_actor_components_a.png" alt="Add components" /></p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_actor_components_b.png" alt="Add components" /></p>
</li>
<li>
<p>Assign random unit vector to <code>TutorialMovement</code>::<code>Value</code> on <code>BeginPlay</code> event:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_actor_components_c.png" alt="Add components" /></p>
<p>To initially pick a random direction for this actor further movement.</p>
</li>
</ol>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-system"><a class="header" href="#setup-system">Setup system</a></h1>
<ul>
<li><a href="book/learning_materials/tutorial/setup_system.html#c">C++ implementation</a></li>
<li><a href="book/learning_materials/tutorial/setup_system.html#blueprint">Blueprint implementation</a></li>
</ul>
<h1 id="c-1"><a class="header" href="#c-1">C++</a></h1>
<ul>
<li>
<p><code>Tutorial/Systems/TutorialMovementSystem.h</code>:</p>
<pre><code class="language-cpp">#pragma once

#include &quot;CoreMinimal.h&quot;

class USystemsWorld;

UFUNCTION()
void TUTORIAL_API TutorialMovementSystem(USystemsWorld&amp; Systems);
</code></pre>
</li>
<li>
<p><code>Tutorial/Systems/TutorialMovementSystem.cpp</code>:</p>
<pre><code class="language-cpp">#include &quot;Tutorial/Systems/Persistent/TutorialMovementSystem.h&quot;

#include &quot;Systems/Public/SystemsWorld.h&quot;

#include &quot;Tutorial/Components/TutorialMovementComponent.h&quot;

void TutorialMovementSystem(USystemsWorld&amp; Systems)
{
    const auto DeltaTime = Systems.GetWorld()-&gt;GetDeltaSeconds();

    Systems.Query&lt;UTutorialMovementComponent&gt;().ForEach(
        [&amp;](auto&amp; QueryItem)
        {
            auto* Actor = QueryItem.Get&lt;0&gt;();
            auto* Movement = QueryItem.Get&lt;1&gt;();
            const auto Position = Actor-&gt;GetActorLocation();
            const auto Velocity = FVector(Movement-&gt;Value, 0) * DeltaTime;

            Actor-&gt;SetActorLocation(Position + Velocity);

            Movement-&gt;Value = FVector2D(0);
        });
}
</code></pre>
</li>
</ul>
<p>Since this is a lambda system, we need to register it to <a href="book/learning_materials/tutorial/"><code>class; FSystemsReflection</code></a>.
To do that you have to register them in your game module:</p>
<ul>
<li>
<p><code>Tutorial/Tutorial.h</code>:</p>
<pre><code class="language-cpp">#pragma once

#include &quot;CoreMinimal.h&quot;

#include &quot;Modules/ModuleManager.h&quot;

class FTutorialModule : public IModuleInterface
{
public:
    virtual void StartupModule() override;

    virtual void ShutdownModule() override;
};
</code></pre>
</li>
<li>
<p><code>Tutorial/Tutorial.cpp</code>:</p>
<pre><code class="language-cpp">#include &quot;Tutorial.h&quot;

#include &quot;Systems/Public/SystemsReflection.h&quot;

#include &quot;Tutorial/Systems/Persistent/TutorialMovementSystem.h&quot;

#define LOCTEXT_NAMESPACE &quot;FTutorialModule&quot;
#define SYSTEMS_NAMESPACE &quot;Tutorial&quot;

void FTutorialModule::StartupModule()
{
    REGISTER_SYSTEM_FUNCTION(TutorialMovementSystem);
}

void FTutorialModule::ShutdownModule()
{
    UNREGISTER_SYSTEM_FUNCTION(TutorialMovementSystem);
}

#undef LOCTEXT_NAMESPACE
#undef SYSTEMS_NAMESPACE

IMPLEMENT_GAME_MODULE(FTutorialModule, Tutorial);
</code></pre>
</li>
</ul>
<h1 id="blueprint-1"><a class="header" href="#blueprint-1">Blueprint</a></h1>
<ol>
<li>
<p>Create new game object that inherits from <code>Object</code>:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_query_create.png" alt="Create query" /></p>
<p>And name it <code>BP_TutorialMovementQuery</code>.</p>
</li>
<li>
<p>Add <code>BP_TutorialMovement</code> component and actor proeprties to tell over what systems
world elements this query wants to iterate over.</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_query_properties.png" alt="Add query properties" /></p>
</li>
<li>
<p>Create new game object that inherits from <a href="book/learning_materials/tutorial//Unreal-Systems-Architecture/systems/reference/classes/UScriptableSystem.html"><strong><code>UScriptableSystem</code></strong></a>:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_system_create.png" alt="Create system" /></p>
<p>And name it <code>BP_TutorialMovementSystem</code>.</p>
</li>
<li>
<p>Override <code>OnRun</code> event:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_system_run_a.png" alt="Override OnRun event" /></p>
</li>
<li>
<p>Create <code>Query</code> node and assign <code>BP_TutorialMovementQuery</code> class to it:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_system_run_b.png" alt="Add query node" /></p>
</li>
<li>
<p>Create <code>Lazy Iterate</code> node:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_system_run_c.png" alt="Add lazy iterate node" /></p>
</li>
<li>
<p>Perform update on yielded object:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_system_run_d.png" alt="Perform update" /></p>
</li>
</ol>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-game"><a class="header" href="#setup-game">Setup game</a></h1>
<ol>
<li>
<p>Create new data asset that inherits from <a href="book/learning_materials/tutorial//Unreal-Systems-Architecture/systems/reference/classes/USystemsPipeline.html"><strong><code>USystemsPipeline</code></strong></a>:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_pipeline_create_data_asset.png" alt="Create data asset" /></p>
<p>And name it <code>DA_TutorialPipeline</code>.</p>
</li>
<li>
<p>Add components:</p>
<ul>
<li>
<p>C++</p>
<p><img src="book/learning_materials/tutorial/../../../assets/game_components_cpp.png" alt="Add C++ components" /></p>
</li>
<li>
<p>Blueprint</p>
<p><img src="book/learning_materials/tutorial/../../../assets/game_components_blueprint.png" alt="Add Blueprint components" /></p>
</li>
</ul>
</li>
<li>
<p>Add persistent systems:</p>
<ul>
<li>
<p>C++</p>
<p><img src="book/learning_materials/tutorial/../../../assets/game_systems_cpp.png" alt="Add C++ systems" /></p>
</li>
<li>
<p>Blueprint</p>
<p><img src="book/learning_materials/tutorial/../../../assets/game_systems_blueprint.png" alt="Add Blueprint systems" /></p>
</li>
</ul>
</li>
<li>
<p>Create new game object that inherits from <strong><code>USystemsGameMode</code></strong>:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_pipeline_game_mode_a.png" alt="Create game mode" /></p>
<p>And name it <code>BP_TutorialGameMode</code>.</p>
</li>
<li>
<p>Assign <code>BP_TutorialPipeline</code> to <code>Systems Pipeline</code> property:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/systems_pipeline_game_mode_b.png" alt="Create game mode" /></p>
</li>
<li>
<p>Assign <code>BP_TutorialGameMode</code> to level you want this pipeline to run on:</p>
<p><img src="book/learning_materials/tutorial/../../../assets/game_level_mode.png" alt="Create game mode" /></p>
</li>
<li>
<p>Put some of <code>BP_Entity</code> actors on level, run game in <code>PIE</code> and see systems performing!</p>
</li>
</ol>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-api-reference"><a class="header" href="#c-api-reference">C++ API Reference</a></h1>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<ul>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/FActorsIter.html"><code>FActorsIter</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/FArchetypeSignature.html"><code>FArchetypeSignature</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/FInstallSystemOptions.html"><code>FInstallSystemOptions</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/FMetronome.html"><code>FMetronome</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/FSystemsPipelineComponent.html"><code>FSystemsPipelineComponent</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/FSystemsPipelineResource.html"><code>FSystemsPipelineResource</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/FSystemsPipelineSystem.html"><code>FSystemsPipelineSystem</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/IterSizeHint.html"><code>IterSizeHint</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/TQuery.html"><code>TQuery</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/TReceiverChannel.html"><code>TReceiverChannel</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/TResult.html"><code>TResult</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/TSenderChannel.html"><code>TSenderChannel</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/structs/TTaggedQuery.html"><code>TTaggedQuery</code></a></li>
</ul>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<ul>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/ASystemsActor.html"><code>ASystemsActor</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/ASystemsGameMode.html"><code>ASystemsGameMode</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/ASystemsGameState.html"><code>ASystemsGameState</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/ASystemsPawn.html"><code>ASystemsPawn</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/FSystemsReflection.html"><code>FSystemsReflection</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/UDynamicIterator.html"><code>UDynamicIterator</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/UDynamicQuery.html"><code>UDynamicQuery</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/ULambdaSystem.html"><code>ULambdaSystem</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/UScriptableSystem.html"><code>UScriptableSystem</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/USystem.html"><code>USystem</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/USystemsActorComponent.html"><code>USystemsActorComponent</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/USystemsPipeline.html"><code>USystemsPipeline</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/USystemsReflection.html"><code>USystemsReflection</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/USystemsSceneComponent.html"><code>USystemsSceneComponent</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/USystemsStatics.html"><code>USystemsStatics</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/USystemsSubsystem.html"><code>USystemsSubsystem</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html"><code>USystemsWorld</code></a></li>
</ul>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<ul>
<li><a href="/Unreal-Systems-Architecture/systems/reference/functions/IterGenerate.html"><code>IterGenerate</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/functions/IterOnce.html"><code>IterOnce</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/functions/IterRange.html"><code>IterRange</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/functions/IterRepeat.html"><code>IterRepeat</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/functions/IterStd.html"><code>IterStd</code></a></li>
<li><a href="/Unreal-Systems-Architecture/systems/reference/functions/IterStdConst.html"><code>IterStdConst</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-1"><a class="header" href="#structs-1">Structs</a></h1>
<ul>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/FActorsIter.html"><code>FActorsIter</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/FArchetypeSignature.html"><code>FArchetypeSignature</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/FInstallSystemOptions.html"><code>FInstallSystemOptions</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/FMetronome.html"><code>FMetronome</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/FSystemsPipelineComponent.html"><code>FSystemsPipelineComponent</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/FSystemsPipelineResource.html"><code>FSystemsPipelineResource</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/FSystemsPipelineSystem.html"><code>FSystemsPipelineSystem</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/IterSizeHint.html"><code>IterSizeHint</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/TQuery.html"><code>TQuery</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/TReceiverChannel.html"><code>TReceiverChannel</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/TResult.html"><code>TResult</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/TSenderChannel.html"><code>TSenderChannel</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/structs/TTaggedQuery.html"><code>TTaggedQuery</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-factorsiter"><a class="header" href="#struct-factorsiter"><strong>Struct: <code>FActorsIter</code></strong></a></h1>
<pre><code class="language-cpp">struct SYSTEMS_API FActorsIter;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers"><a class="header" href="#specifiers">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Query iterator over systems world actors.</p>
<p>See <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#actors"><strong><code>USystemsWorld::Actors</code></strong></a>.</p>
<hr />
<h1 id="methods"><a class="header" href="#methods"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="adapt"><a class="header" href="#adapt"><strong><code>Adapt</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename ADAPTER&gt;
TIterAdapt&lt;Self, ADAPTER&gt; Adapt(
    ADAPTER Adapter
);
</code></pre>
<details>
<hr />
<p>Injects custom iterator adapter into the chain of iteration.</p>
<p>Useful only for really custom/advanced solutions that cannot be solved with
regular iterators.</p>
<h1 id="note"><a class="header" href="#note">Note</a></h1>
<blockquote>
<p><code>ADAPTER</code> should implement iterator adapter methods. Yielded values share
same type wit iterator that wraps this adapter.</p>
</blockquote>
<h1 id="example"><a class="header" href="#example">Example</a></h1>
<pre><code class="language-cpp">// [1, 3, 5, 7, 9]
const TArray&lt;int&gt; Result = IterRange(0, 10).Adapt(TIterOddAdapter&lt;int&gt;()).CollectArray();
</code></pre>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct TIterOddAdapter
{
public:
	template &lt;typename I&gt;
	TOptional&lt;T&gt; Next(I&amp; Iter)
	{
		Iter.Next();
		return Iter.Next();
	}

	template &lt;typename I&gt;
	IterSizeHint SizeHint(const I&amp; Iter) const
	{
		return Iter.SizeHint();
	}
};
</code></pre>
<hr />
<h1 id="arguments"><a class="header" href="#arguments"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="adapter"><a class="header" href="#adapter"><strong><code>Adapter</code></strong></a></h2>
<pre><code class="language-cpp">ADAPTER Adapter
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="all"><a class="header" href="#all"><strong><code>All</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
bool All(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Checks if all values yielded by this iterator passes predicate.</p>
<h1 id="note-1"><a class="header" href="#note-1">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-1"><a class="header" href="#example-1">Example</a></h1>
<pre><code class="language-cpp">// false
const bool Result = IterRange(0, 10).All([](const auto&amp; Value) { return Value &gt; 5; });
</code></pre>
<hr />
<h1 id="arguments-1"><a class="header" href="#arguments-1"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func"><a class="header" href="#func"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="any"><a class="header" href="#any"><strong><code>Any</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
bool Any(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Checks if any value yielded by this iterator passes predicate.</p>
<h1 id="note-2"><a class="header" href="#note-2">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-2"><a class="header" href="#example-2">Example</a></h1>
<pre><code class="language-cpp">// true
const bool Result = IterRange(0, 10).Any([](const auto&amp; Value) { return Value &gt; 5; });
</code></pre>
<hr />
<h1 id="arguments-2"><a class="header" href="#arguments-2"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-1"><a class="header" href="#func-1"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="cast"><a class="header" href="#cast"><strong><code>Cast</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT&gt;
TIterCast&lt;typename RESULT, Self&gt; Cast();
</code></pre>
<details>
<hr />
<p>Casts yielded values to another type.</p>
<p>Commonly used as a shourtcut for mapping between types using target type
constructor.</p>
<h1 id="note-3"><a class="header" href="#note-3">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is type that this iterator will yield after casting.</p>
</blockquote>
<h1 id="example-3"><a class="header" href="#example-3">Example</a></h1>
<pre><code class="language-cpp">// [0.0, 1.0, 2.0, 3.0, 4.0]
const TArray&lt;float&gt; Result = IterRange(0, 5).Cast&lt;float&gt;().CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="chain"><a class="header" href="#chain"><strong><code>Chain</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename ITER&gt;
TIterChain&lt;Self, ITER&gt; Chain(
    ITER&amp;&amp; Iter
);
</code></pre>
<details>
<hr />
<p>Appends another iterator at the end of this iterator.</p>
<p>Useful for combining results of different iterators that yield same value
type.</p>
<h1 id="note-4"><a class="header" href="#note-4">Note</a></h1>
<blockquote>
<p><code>ITER</code> should implement iterator methods. Yielded values share same type
with this iterato value type.</p>
</blockquote>
<h1 id="example-4"><a class="header" href="#example-4">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4, -5, -4, -3, -2, -1]
const TArray&lt;int&gt; Result = IterRange(0, 5).Chain(IterRange(-5, 0)).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-3"><a class="header" href="#arguments-3"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="iter"><a class="header" href="#iter"><strong><code>Iter</code></strong></a></h2>
<pre><code class="language-cpp">ITER&amp;&amp; Iter
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="comparedby"><a class="header" href="#comparedby"><strong><code>ComparedBy</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TOptional&lt;Item&gt; ComparedBy(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Finds iterator value that compared to other items gets greater &quot;score&quot;.</p>
<p>Headline is rather vague, but what it actually does is user can do finding
min/max value with this iterator consumer.</p>
<h1 id="note-5"><a class="header" href="#note-5">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item A, I::Item B)</code> where <code>A</code> holds current value yielded by iterator and <code>B</code> is
the one that has best &quot;score&quot; so far.</p>
</blockquote>
<h1 id="example-5"><a class="header" href="#example-5">Example</a></h1>
<pre><code class="language-cpp">// 42
const int Result = IterRange(0, 42).ComparedBy([](const auto A, const auto B) { return A &gt; B; });
</code></pre>
<hr />
<h1 id="arguments-4"><a class="header" href="#arguments-4"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-2"><a class="header" href="#func-2"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="count"><a class="header" href="#count"><strong><code>Count</code></strong></a></h1>
<pre><code class="language-cpp">public:
uint32 Count();
</code></pre>
<details>
<hr />
<p>Returns exact number of items that iterator can yield.</p>
<h1 id="example-6"><a class="header" href="#example-6">Example</a></h1>
<pre><code class="language-cpp">// 10
const uint32 Result = IterRange(0, 10).Count();
</code></pre>
</details>
</li>
<li>
<h1 id="enumerate"><a class="header" href="#enumerate"><strong><code>Enumerate</code></strong></a></h1>
<pre><code class="language-cpp">public:
TIterEnumerate&lt;Self&gt; Enumerate();
</code></pre>
<details>
<hr />
<p>Enumerates values in this iterator.</p>
<p>Useful for reading index of element/iteration.</p>
<h1 id="note-6"><a class="header" href="#note-6">Note</a></h1>
<blockquote>
<p>Yielded values have type: <code>TTuple&lt;uint32, Item&gt;</code>, which means this
iterator yields tuple o index-value pair.</p>
</blockquote>
<h1 id="example-7"><a class="header" href="#example-7">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4]
const TArray&lt;int&gt; Result =
	IterRepeat(42).Enumerate().Map&lt;int&gt;([](const auto&amp; Pair) { return Pair.Get&lt;0&gt;(); }).Take(5).CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="factorsiter"><a class="header" href="#factorsiter"><strong><code>FActorsIter</code></strong></a></h1>
<pre><code class="language-cpp">public:
FActorsIter(
    USystemsWorld* Systems
);
</code></pre>
<details>
<hr />
<p>Constructs query from systems.</p>
<p>An equivalent of calling <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#actors"><strong><code>USystemsWorld::Actors</code></strong></a></p>
<hr />
<h1 id="arguments-5"><a class="header" href="#arguments-5"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="systems-2"><a class="header" href="#systems-2"><strong><code>Systems</code></strong></a></h2>
<pre><code class="language-cpp">USystemsWorld* Systems
</code></pre>
<p>Pointer to systems world of which actors user wants to iterate on.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="filter"><a class="header" href="#filter"><strong><code>Filter</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TIterFilter&lt;Self, typename FUNCTOR&gt; Filter(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Filters values in the iterator by predicate.</p>
<h1 id="note-7"><a class="header" href="#note-7">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to this function signature: <code>bool(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-8"><a class="header" href="#example-8">Example</a></h1>
<pre><code class="language-cpp">// [0, 2, 4, 6, 8]
const TArray&lt;int&gt; Result = IterRange(0, 10).Filter([](const auto&amp; Value) { return Value % 2 == 0; }).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-6"><a class="header" href="#arguments-6"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-3"><a class="header" href="#func-3"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="filtermap"><a class="header" href="#filtermap"><strong><code>FilterMap</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT, typename FUNCTOR&gt;
TIterFilterMap&lt;typename RESULT, Self, typename FUNCTOR&gt; FilterMap(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Filters values in the iterator by predicate and maps them to another type.</p>
<h1 id="note-8"><a class="header" href="#note-8">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is a type of values yielded by this iterator that maps into.
<code>FUNCTOR</code> should comply to this function signature:
<code>TOptional&lt;RESULT&gt;(const I::Item&amp; Value)</code> Returning some value means
pasing it to next iterator, returning none means we omit thi value.</p>
</blockquote>
<h1 id="example-9"><a class="header" href="#example-9">Example</a></h1>
<pre><code class="language-cpp">// [0.0, 2.0, 4.0, 6.0, 8.0]
const TArray&lt;float&gt; I = IterRange(0, 10)
							.FilterMap&lt;float&gt;(
								[](const auto&amp; Value)
								{
									if (Value % 2 == 0)
									{
										return TOptional&lt;float&gt;(static_cast&lt;float&gt;(Value));
									}
									else
									{
										return TOptional&lt;float&gt;();
									}
								})
							.CollectArray();
</code></pre>
<hr />
<h1 id="arguments-7"><a class="header" href="#arguments-7"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-4"><a class="header" href="#func-4"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="find"><a class="header" href="#find"><strong><code>Find</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TOptional&lt;Item&gt; Find(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Finds and returns value in this iterator that passes <code>FUNCTOR</code> predicate.</p>
<h1 id="note-9"><a class="header" href="#note-9">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-10"><a class="header" href="#example-10">Example</a></h1>
<pre><code class="language-cpp">// 5
const TOptional&lt;int&gt; Result = IterRange(0, 10).Find([](const auto&amp; Value) { return Value &gt;= 5; });
</code></pre>
<hr />
<h1 id="arguments-8"><a class="header" href="#arguments-8"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-5"><a class="header" href="#func-5"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="findmap"><a class="header" href="#findmap"><strong><code>FindMap</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT, typename FUNCTOR&gt;
TOptional&lt;RESULT&gt; FindMap(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Finds and returns value in this iterator that passes <code>FUNCTOR</code> predicate,
mapped to another type.</p>
<h1 id="note-10"><a class="header" href="#note-10">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature:
<code>TOptional&lt;Item&gt;(I::Item Value)</code> where <code>Value</code> holds current value
yielded by iterator. <code>RESULT</code> is the returned type and use should always
return <code>TOptional&lt;RESULT&gt;</code> in the predicate where some value means &quot;found&quot;
an none means &quot;not found&quot;.</p>
</blockquote>
<h1 id="example-11"><a class="header" href="#example-11">Example</a></h1>
<pre><code class="language-cpp">// 5.0
const TOptional&lt;float&gt; Result = IterRange(0, 10).FindMap&lt;float&gt;(
	[](const auto&amp; Value)
	{
		if (Value &gt;= 5)
		{
			return TOptional&lt;float&gt;(static_cast&lt;float&gt;(Value));
		}
		else
		{
			return TOptional&lt;float&gt;();
		}
	});
</code></pre>
<hr />
<h1 id="arguments-9"><a class="header" href="#arguments-9"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-6"><a class="header" href="#func-6"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="first"><a class="header" href="#first"><strong><code>First</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; First();
</code></pre>
<details>
<hr />
<p>Returns first item in the iterator.</p>
<p>This is an equivalent of calling <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/FActorsIter.html#next"><strong><code>FActorsIter::Next</code></strong></a>.</p>
<h1 id="example-12"><a class="header" href="#example-12">Example</a></h1>
<pre><code class="language-cpp">// 5
const int Result = IterRange(5, 10).First();
</code></pre>
</details>
</li>
<li>
<h1 id="flatten"><a class="header" href="#flatten"><strong><code>Flatten</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT&gt;
TIterFlatten&lt;typename RESULT, Self&gt; Flatten();
</code></pre>
<details>
<hr />
<p>Flattens nested iterators.</p>
<p>Imagine you have an iterator that yields another iterators, such as arrays
of arrays.</p>
<h1 id="note-11"><a class="header" href="#note-11">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is a type of values yielded by this iterator - it should be the
same as neste iterator value type (c++ won't accept that syntax, hence we
have to provide a <code>RESULT</code> typ and ensure it's the same) <code>FUNCTOR</code>
should comply to this function signature: <code>RESULT(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-13"><a class="header" href="#example-13">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
const TArray&lt;int&gt; P =
	IterGenerate&lt;TIterRange&lt;int&gt;&gt;([]() { return IterRange(0, 5); }).Take(2).Flatten&lt;int&gt;().CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="fold"><a class="header" href="#fold"><strong><code>Fold</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
Item Fold(
    Item Start,
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Folds iterator into single value.</p>
<p>Folding basically means going through all iterator items and collapsing them
into single value. Example of folding can be sum/accumulation, or min/max,
or anything like that - although for ones mentioned there are existing
optimized iterator consumers: <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/FActorsIter.html#sum"><strong><code>FActorsIter::Sum</code></strong></a> and
<a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/FActorsIter.html#comparedby"><strong><code>FActorsIter::ComparedBy</code></strong></a>.</p>
<h1 id="note-12"><a class="header" href="#note-12">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is the returned type, same as <code>Start</code> argument used as initial
accumulator. <code>FUNCTOR</code> should comply to given function signature: <code>Item(Item Accumulator, I::Item Value)</code> where <code>Accumulator</code> argument holds result of
previous iteration, and <code>Value</code> holds curren value yielded by iterator.
<code>Start</code> argument holds value passed to first iteratio <code>Accumulator</code>.</p>
</blockquote>
<h1 id="example-14"><a class="header" href="#example-14">Example</a></h1>
<pre><code class="language-cpp">// 45
const int Result = IterRange(0, 10).Fold(0, [](const auto&amp; Accum, const auto&amp; Value) { return Accum + Value; });
</code></pre>
<hr />
<h1 id="arguments-10"><a class="header" href="#arguments-10"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="start"><a class="header" href="#start"><strong><code>Start</code></strong></a></h2>
<pre><code class="language-cpp">Item Start
</code></pre>
</li>
<li>
<h2 id="func-7"><a class="header" href="#func-7"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="foreach"><a class="header" href="#foreach"><strong><code>ForEach</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
void ForEach(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Consumes iterator and yields its values for user to process.</p>
<p>This is equivalent of:</p>
<pre><code class="language-cpp">auto Iter = IterRange(0, 9);
while (const auto Value = Iter.Next())
{
	const auto Squared = Value * Value;
	UE_LOG(LogTemp, Warning, TEXT(&quot;Squared value: %i&quot;), Squared);
}
</code></pre>
<h1 id="note-13"><a class="header" href="#note-13">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>void(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-15"><a class="header" href="#example-15">Example</a></h1>
<pre><code class="language-cpp">IterRange(0, 9).ForEach(
	[](const auto&amp; Value)
	{
		const auto Squared = Value * Value;
		UE_LOG(LogTemp, Warning, TEXT(&quot;Squared value: %i&quot;), Squared);
	});
</code></pre>
<hr />
<h1 id="arguments-11"><a class="header" href="#arguments-11"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-8"><a class="header" href="#func-8"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="inspect"><a class="header" href="#inspect"><strong><code>Inspect</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TIterInspect&lt;Self, typename FUNCTOR&gt; Inspect(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Inspects yielded values.</p>
<p>Useful when debugging iterators to for example log what values are yielded
at which iterator chain stage.</p>
<h1 id="note-14"><a class="header" href="#note-14">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to this function signature: <code>void(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-16"><a class="header" href="#example-16">Example</a></h1>
<pre><code class="language-cpp">// [0, 2, 4, 6, 8]
const TArray&lt;int&gt; Result = IterRange(0, 10)
							   .Inspect(
								   [](const auto&amp; Value)
								   {
									   // Prints values: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
									   UE_LOG(LogTemp, Warning, TEXT(&quot;Inspected item before: %i&quot;), Value);
								   })
							   .Filter([](const auto&amp; Value) { return Value % 2 == 0; })
							   .Inspect(
								   [](const auto&amp; Value)
								   {
									   // Prints values: 0, 2, 4, 6, 8.
									   UE_LOG(LogTemp, Warning, TEXT(&quot;Inspected item after: %i&quot;), Value);
								   })
							   .CollectArray();
</code></pre>
<hr />
<h1 id="arguments-12"><a class="header" href="#arguments-12"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-9"><a class="header" href="#func-9"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="last"><a class="header" href="#last"><strong><code>Last</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; Last();
</code></pre>
<details>
<hr />
<p>Returns last item in the iterator.</p>
<h1 id="example-17"><a class="header" href="#example-17">Example</a></h1>
<pre><code class="language-cpp">// 4
const int Result = IterRange(0, 4).Last();
</code></pre>
</details>
</li>
<li>
<h1 id="map"><a class="header" href="#map"><strong><code>Map</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT, typename FUNCTOR&gt;
TIterMap&lt;typename RESULT, Self, typename FUNCTOR&gt; Map(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Maps yielded values to another type.</p>
<p>Commonly used for data transformations for use in later stages of iteration.</p>
<h1 id="note-15"><a class="header" href="#note-15">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is type that this iterator will yield after data transformations.
<code>FUNCTOR</code> should comply to this function signature: <code>RESULT(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-18"><a class="header" href="#example-18">Example</a></h1>
<pre><code class="language-cpp">// [0.0, 4.0, 16.0, 36.0, 64.0]
const TArray&lt;float&gt; Result = IterRange(0, 10)
								 .Filter([](const auto&amp; Value) { return Value % 2 == 0; })
								 .Map&lt;float&gt;([](const auto&amp; Value) { return static_cast&lt;float&gt;(Value * Value); })
								 .CollectArray();
</code></pre>
<hr />
<h1 id="arguments-13"><a class="header" href="#arguments-13"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-10"><a class="header" href="#func-10"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="next"><a class="header" href="#next"><strong><code>Next</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; Next();
</code></pre>
<details>
<hr />
<p>Yields pointers to next actor.</p>
<p>See <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#next"><strong><code>TQuery::Next</code></strong></a>.</p>
</details>
</li>
<li>
<h1 id="nth"><a class="header" href="#nth"><strong><code>Nth</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; Nth(
    uint32 Index
);
</code></pre>
<details>
<hr />
<p>Returns Nth item in the iterator.</p>
<h1 id="example-19"><a class="header" href="#example-19">Example</a></h1>
<pre><code class="language-cpp">// 5
const TOptional&lt;int&gt; Result = IterRange(0, 10).Nth(5);
</code></pre>
<hr />
<h1 id="arguments-14"><a class="header" href="#arguments-14"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="index"><a class="header" href="#index"><strong><code>Index</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Index
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="sizehint"><a class="header" href="#sizehint"><strong><code>SizeHint</code></strong></a></h1>
<pre><code class="language-cpp">public:
IterSizeHint SizeHint() const;
</code></pre>
<details>
<hr />
<p>Gets hint about minimum and optional maximum items count this iterator
can yield.</p>
<p>See <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#sizehint"><strong><code>TQuery::SizeHint</code></strong></a>.</p>
</details>
</li>
<li>
<h1 id="skip"><a class="header" href="#skip"><strong><code>Skip</code></strong></a></h1>
<pre><code class="language-cpp">public:
TIterSkip&lt;Self&gt; Skip(
    uint32 Count
);
</code></pre>
<details>
<hr />
<p>Skips iteration by number of elements.</p>
<p>It's worth noting that this is one-shot skip, not repeated one, which means
if we yield iterator of 10 elements and we skip 2 iterations, then it will
skip just 2 values and yield rest 8.</p>
<h1 id="example-20"><a class="header" href="#example-20">Example</a></h1>
<pre><code class="language-cpp">// [3, 4, 5, 6, 7]
const TArray&lt;int&gt; Result = IterRange(0, 10).Skip(3).Take(5).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-15"><a class="header" href="#arguments-15"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="count-1"><a class="header" href="#count-1"><strong><code>Count</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Count
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="take"><a class="header" href="#take"><strong><code>Take</code></strong></a></h1>
<pre><code class="language-cpp">public:
TIterTake&lt;Self&gt; Take(
    uint32 Count
);
</code></pre>
<details>
<hr />
<p>Limits iterator to at most number of iterations.</p>
<p>If we create an iterator that yields 10 values and we tell it to take 5,
then it will stop iterating after next 5 values (or less, depends if there
is enough values left in iterator).</p>
<h1 id="example-21"><a class="header" href="#example-21">Example</a></h1>
<pre><code class="language-cpp">// [3, 4, 5, 6, 7]
const TArray&lt;int&gt; Result = IterRange(0, 10).Skip(3).Take(5).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-16"><a class="header" href="#arguments-16"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="count-2"><a class="header" href="#count-2"><strong><code>Count</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Count
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="views"><a class="header" href="#views"><strong><code>Views</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;uint32 COUNT&gt;
TIterViews&lt;Self, COUNT&gt; Views();
</code></pre>
<details>
<hr />
<p>Yields sequences of consecutive views over set of values.</p>
<p>If we create an iterator that yields 5 integer values and we tell it to view
2 at the same time, then it will yield <code>TArrayView</code> with values: <code>[0, 1], [1, 2], [2, 3], [3, 4]</code>.</p>
<h1 id="example-22"><a class="header" href="#example-22">Example</a></h1>
<pre><code class="language-cpp">// [(0, 1), (1, 2), (2, 3), (3, 4)]
const TArray&lt;TTuple&lt;int, int&gt;&gt; Result =
	IterRange(0, 5)
		.Views&lt;2&gt;()
		.Map&lt;TTuple&lt;int, int&gt;&gt;([](const auto&amp; View) { return MakeTuple(View[0], View[1]); })
		.CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="zip"><a class="header" href="#zip"><strong><code>Zip</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename ITER&gt;
TIterZip&lt;Self, ITER&gt; Zip(
    ITER&amp;&amp; Iter
);
</code></pre>
<details>
<hr />
<p>Combines two iterators to make one that yields pair of both iterator values
at the same time.</p>
<h1 id="example-23"><a class="header" href="#example-23">Example</a></h1>
<pre><code class="language-cpp">// [(0, -5), (1, -4), (2, -3), (3, -2), (4, -1)]
const TArray&lt;TTuple&lt;int, int&gt;&gt; Result = IterRange(0, 5).Zip(IterRange(-5, 0)).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-17"><a class="header" href="#arguments-17"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="iter-1"><a class="header" href="#iter-1"><strong><code>Iter</code></strong></a></h2>
<pre><code class="language-cpp">ITER&amp;&amp; Iter
</code></pre>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-farchetypesignature"><a class="header" href="#struct-farchetypesignature"><strong>Struct: <code>FArchetypeSignature</code></strong></a></h1>
<pre><code class="language-cpp">struct SYSTEMS_API FArchetypeSignature;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Signature of actor components set.</p>
<p>More in depth about archetype signatures in <a href="reference/structs//Unreal-Systems-Architecture/systems/book/architecture/world.html">this architecture book
section</a>.</p>
<p>Signatures are used internally by <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html"><strong><code>USystemsWorld</code></strong></a> to allow
identification of to which buckets (archetypes) given set of components
belongs to - that allows for querying iterators over only these actor
components that contain all requested components and omiting ones that
doesn't, which improves performance of querying systems world (which is the
most frequently used operation in systems game architecture, hence the
importance of making it fast).</p>
<h1 id="note-16"><a class="header" href="#note-16">Note</a></h1>
<blockquote>
<p>Although constructing signatures has no real value for common usecases
while developing games this API can be useful for users that needs to
perform more advanced operations.</p>
</blockquote>
<h1 id="example-24"><a class="header" href="#example-24">Example</a></h1>
<pre><code class="language-cpp">	// Instead of this:
	const auto A = Systems.Query&lt;UShiaComponent&gt;().Count();

	// You can do this:
	auto Signature = FArchetypeSignature();
	if (const auto Index = Systems.ComponentTypeIndex(UShiaComponent::StaticClass()))
	{
		Signature.EnableBit(Index.GetValue());
	}

	const auto B = Systems.CountRaw(Signature);
</code></pre>
<hr />
<h1 id="methods-1"><a class="header" href="#methods-1"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="clear"><a class="header" href="#clear"><strong><code>Clear</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Clear();
</code></pre>
<details>
<hr />
<p>Clears components set.</p>
</details>
</li>
<li>
<h1 id="containsall"><a class="header" href="#containsall"><strong><code>ContainsAll</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool ContainsAll(
    const FArchetypeSignature&amp; Other
) const;
</code></pre>
<details>
<hr />
<p>Checks if this signature fully contain component set of another
signature.</p>
<p>Used by <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#query"><strong><code>USystemsWorld::Query</code></strong></a> to filter archetypes that are
valid for iteration.</p>
<hr />
<h1 id="arguments-18"><a class="header" href="#arguments-18"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="other"><a class="header" href="#other"><strong><code>Other</code></strong></a></h2>
<pre><code class="language-cpp">const FArchetypeSignature&amp; Other
</code></pre>
<p>Other signature to compare with.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="containsany"><a class="header" href="#containsany"><strong><code>ContainsAny</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool ContainsAny(
    const FArchetypeSignature&amp; Other
) const;
</code></pre>
<details>
<hr />
<p>Checks if this signature at least partially contain component set of
another signature.</p>
<hr />
<h1 id="arguments-19"><a class="header" href="#arguments-19"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="other-1"><a class="header" href="#other-1"><strong><code>Other</code></strong></a></h2>
<pre><code class="language-cpp">const FArchetypeSignature&amp; Other
</code></pre>
<p>Other signature to compare with.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="countbits"><a class="header" href="#countbits"><strong><code>CountBits</code></strong></a></h1>
<pre><code class="language-cpp">public:
uint32 CountBits() const;
</code></pre>
<details>
<hr />
<p>Counts bits of enabled components in set.</p>
</details>
</li>
<li>
<h1 id="difference"><a class="header" href="#difference"><strong><code>Difference</code></strong></a></h1>
<pre><code class="language-cpp">public:
FArchetypeSignature Difference(
    const FArchetypeSignature&amp; Other
) const;
</code></pre>
<details>
<hr />
<p>Returns signature with only component set bits that differs between this
and another signature.</p>
<hr />
<h1 id="arguments-20"><a class="header" href="#arguments-20"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="other-2"><a class="header" href="#other-2"><strong><code>Other</code></strong></a></h2>
<pre><code class="language-cpp">const FArchetypeSignature&amp; Other
</code></pre>
<p>Other signature to test with.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="disablebit"><a class="header" href="#disablebit"><strong><code>DisableBit</code></strong></a></h1>
<pre><code class="language-cpp">public:
void DisableBit(
    uint32 Index
);
</code></pre>
<details>
<hr />
<p>Disable component bit at given index.</p>
<hr />
<h1 id="arguments-21"><a class="header" href="#arguments-21"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="index-1"><a class="header" href="#index-1"><strong><code>Index</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Index
</code></pre>
<p>Index of component bit to disable.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="enablebit"><a class="header" href="#enablebit"><strong><code>EnableBit</code></strong></a></h1>
<pre><code class="language-cpp">public:
void EnableBit(
    uint32 Index
);
</code></pre>
<details>
<hr />
<p>Enable component bit at given index.</p>
<hr />
<h1 id="arguments-22"><a class="header" href="#arguments-22"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="index-2"><a class="header" href="#index-2"><strong><code>Index</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Index
</code></pre>
<p>Index of component bit to enable.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="exclude"><a class="header" href="#exclude"><strong><code>Exclude</code></strong></a></h1>
<pre><code class="language-cpp">public:
FArchetypeSignature Exclude(
    const FArchetypeSignature&amp; Other
) const;
</code></pre>
<details>
<hr />
<p>Exclude components set bits from ones of another signature.</p>
<hr />
<h1 id="arguments-23"><a class="header" href="#arguments-23"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="other-3"><a class="header" href="#other-3"><strong><code>Other</code></strong></a></h2>
<pre><code class="language-cpp">const FArchetypeSignature&amp; Other
</code></pre>
<p>Other signature to exclude from.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="farchetypesignature"><a class="header" href="#farchetypesignature"><strong><code>FArchetypeSignature</code></strong></a></h1>
<pre><code class="language-cpp">public:
FArchetypeSignature();
</code></pre>
<details>
<hr />
<p>Constructs signature of empty components set.</p>
</details>
</li>
<li>
<h1 id="farchetypesignature-1"><a class="header" href="#farchetypesignature-1"><strong><code>FArchetypeSignature</code></strong></a></h1>
<pre><code class="language-cpp">public:
FArchetypeSignature(
    const FArchetypeSignature&amp; Other
);
</code></pre>
<details>
<hr />
<p>Copies signature from another one.</p>
<hr />
<h1 id="arguments-24"><a class="header" href="#arguments-24"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="other-4"><a class="header" href="#other-4"><strong><code>Other</code></strong></a></h2>
<pre><code class="language-cpp">const FArchetypeSignature&amp; Other
</code></pre>
<p>Other signature to copy components set from.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="farchetypesignature-2"><a class="header" href="#farchetypesignature-2"><strong><code>FArchetypeSignature</code></strong></a></h1>
<pre><code class="language-cpp">public:
FArchetypeSignature(
    uint32 Bit
);
</code></pre>
<details>
<hr />
<p>Constructs signature with single component bit enabled.</p>
<hr />
<h1 id="arguments-25"><a class="header" href="#arguments-25"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="bit"><a class="header" href="#bit"><strong><code>Bit</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Bit
</code></pre>
<p>Index of component bit to enable.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="hasbit"><a class="header" href="#hasbit"><strong><code>HasBit</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool HasBit(
    uint32 Index
) const;
</code></pre>
<details>
<hr />
<p>Checks if component bit at given index is enabled.</p>
<hr />
<h1 id="arguments-26"><a class="header" href="#arguments-26"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="index-3"><a class="header" href="#index-3"><strong><code>Index</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Index
</code></pre>
<p>Index of component bit to check.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="include"><a class="header" href="#include"><strong><code>Include</code></strong></a></h1>
<pre><code class="language-cpp">public:
FArchetypeSignature Include(
    const FArchetypeSignature&amp; Other
) const;
</code></pre>
<details>
<hr />
<p>Include components set bits from ones of another signature.</p>
<hr />
<h1 id="arguments-27"><a class="header" href="#arguments-27"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="other-5"><a class="header" href="#other-5"><strong><code>Other</code></strong></a></h2>
<pre><code class="language-cpp">const FArchetypeSignature&amp; Other
</code></pre>
<p>Other signature to include from.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="isempty"><a class="header" href="#isempty"><strong><code>IsEmpty</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool IsEmpty() const;
</code></pre>
<details>
<hr />
<p>Checks if components set is empty.</p>
</details>
</li>
<li>
<h1 id="union"><a class="header" href="#union"><strong><code>Union</code></strong></a></h1>
<pre><code class="language-cpp">public:
FArchetypeSignature Union(
    const FArchetypeSignature&amp; Other
) const;
</code></pre>
<details>
<hr />
<p>Returns signature with only component set bits enabled by both
signatures.</p>
<hr />
<h1 id="arguments-28"><a class="header" href="#arguments-28"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="other-6"><a class="header" href="#other-6"><strong><code>Other</code></strong></a></h2>
<pre><code class="language-cpp">const FArchetypeSignature&amp; Other
</code></pre>
<p>Other signature to test with.</p>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-finstallsystemoptions"><a class="header" href="#struct-finstallsystemoptions"><strong>Struct: <code>FInstallSystemOptions</code></strong></a></h1>
<pre><code class="language-cpp">struct SYSTEMS_API FInstallSystemOptions;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-1"><a class="header" href="#specifiers-1">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Set of options for installation of this system.</p>
<p>It uses builder pattern to simplify setting options.</p>
<p>Note that both <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/FInstallSystemOptions.html#runbefore"><strong><code>FInstallSystemOptions::RunBefore</code></strong></a> and
<a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/FInstallSystemOptions.html#runafter"><strong><code>FInstallSystemOptions::RunAfter</code></strong></a> methods are accumulative, which
means you can specify with them multiple systems required to run before
and/or after this one.</p>
<p>See <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#installsystem"><strong><code>USystemsWorld::InstallSystem</code></strong></a>, <a href="reference/structs//reference/classes/USystemsWorld.html#installlambdasystem"><strong><code>USystemsWorld::InstallLambdaSystem</code></strong></a>,
<a href="reference/structs//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#installsystemraw"><strong><code>USystemsWorld::InstallSystemRaw</code></strong></a></p>
<h1 id="example-25"><a class="header" href="#example-25">Example</a></h1>
<pre><code class="language-cpp">Systems.InstallLambdaSystem(BoidsFaceDirectionSystem,
	FInstallSystemOptions(&quot;BoidsFaceDirection&quot;)
		.RunBefore(&quot;BoidsFaceDirection&quot;)
		.RunAfter(&quot;BoidsApplyImpulse&quot;)
		.MultiplayerRunOn(ESystemMultiplayerRunOn::ServerAndClient));
</code></pre>
<hr />
<h1 id="methods-2"><a class="header" href="#methods-2"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="finstallsystemoptions"><a class="header" href="#finstallsystemoptions"><strong><code>FInstallSystemOptions</code></strong></a></h1>
<pre><code class="language-cpp">public:
FInstallSystemOptions(
    FName Name
);
</code></pre>
<details>
<hr />
<p>Create new options object.</p>
<h1 id="example-26"><a class="header" href="#example-26">Example</a></h1>
<pre><code class="language-cpp">Systems.InstallLambdaSystem(BoidsFaceDirectionSystem,
	FInstallSystemOptions(&quot;BoidsFaceDirection&quot;)
		.RunBefore(&quot;BoidsFaceDirection&quot;)
		.RunAfter(&quot;BoidsApplyImpulse&quot;)
		.MultiplayerRunOn(ESystemMultiplayerRunOn::ServerAndClient));
</code></pre>
<hr />
<h1 id="arguments-29"><a class="header" href="#arguments-29"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="name"><a class="header" href="#name"><strong><code>Name</code></strong></a></h2>
<pre><code class="language-cpp">FName Name
</code></pre>
<p>Name of system being installed.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="runafter"><a class="header" href="#runafter"><strong><code>RunAfter</code></strong></a></h1>
<pre><code class="language-cpp">public:
FInstallSystemOptions&amp; RunAfter(
    FName Name
);
</code></pre>
<details>
<hr />
<p>Add named dependency system that installed system should run after.</p>
<h1 id="example-27"><a class="header" href="#example-27">Example</a></h1>
<pre><code class="language-cpp">Systems.InstallLambdaSystem(BoidsFaceDirectionSystem,
	FInstallSystemOptions(&quot;BoidsFaceDirection&quot;)
		.RunBefore(&quot;BoidsFaceDirection&quot;)
		.RunAfter(&quot;BoidsApplyImpulse&quot;)
		.MultiplayerRunOn(ESystemMultiplayerRunOn::ServerAndClient));
</code></pre>
<hr />
<h1 id="arguments-30"><a class="header" href="#arguments-30"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="name-1"><a class="header" href="#name-1"><strong><code>Name</code></strong></a></h2>
<pre><code class="language-cpp">FName Name
</code></pre>
<p>Name of other system.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="runbefore"><a class="header" href="#runbefore"><strong><code>RunBefore</code></strong></a></h1>
<pre><code class="language-cpp">public:
FInstallSystemOptions&amp; RunBefore(
    FName Name
);
</code></pre>
<details>
<hr />
<p>Add named dependency system that installed system should run before.</p>
<h1 id="example-28"><a class="header" href="#example-28">Example</a></h1>
<pre><code class="language-cpp">Systems.InstallLambdaSystem(BoidsFaceDirectionSystem,
	FInstallSystemOptions(&quot;BoidsFaceDirection&quot;)
		.RunBefore(&quot;BoidsFaceDirection&quot;)
		.RunAfter(&quot;BoidsApplyImpulse&quot;)
		.MultiplayerRunOn(ESystemMultiplayerRunOn::ServerAndClient));
</code></pre>
<hr />
<h1 id="arguments-31"><a class="header" href="#arguments-31"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="name-2"><a class="header" href="#name-2"><strong><code>Name</code></strong></a></h2>
<pre><code class="language-cpp">FName Name
</code></pre>
<p>Name of other system.</p>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-fmetronome"><a class="header" href="#struct-fmetronome"><strong>Struct: <code>FMetronome</code></strong></a></h1>
<pre><code class="language-cpp">struct SYSTEMS_API FMetronome;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-2"><a class="header" href="#specifiers-2">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>Metronome for ticking optimizations.</p>
<p>Useful for spreading tickable work across time.
User should use it to limit number of heavy ticking operations that do not
need to perform on every tick, rather can be executed with uniform random
time offset for each instance of a group. Good usecase would be AI tasks.</p>
<h1 id="example-29"><a class="header" href="#example-29">Example</a></h1>
<pre><code class="language-cpp">auto Metronome = FMetronome{};
Metronome.Progress(10.0);
if (Metronome.ConsumeTicked())
{
	UE_LOG(LogTemp, Warning, TEXT(&quot;Metronome ticked!&quot;));
}
</code></pre>
<hr />
<h1 id="properties"><a class="header" href="#properties"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="accumulator"><a class="header" href="#accumulator"><strong><code>Accumulator</code></strong></a></h1>
<pre><code class="language-cpp">public:
float Accumulator;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-3"><a class="header" href="#specifiers-3">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Systems|Metronome</em></li>
</ul>
<hr />
<p>Tells the current time phase.</p>
</li>
<li>
<h1 id="limit"><a class="header" href="#limit"><strong><code>Limit</code></strong></a></h1>
<pre><code class="language-cpp">public:
float Limit;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-4"><a class="header" href="#specifiers-4">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Systems|Metronome</em></li>
</ul>
<hr />
<p>Tells the time limit that marks time of ticking.</p>
</li>
<li>
<h1 id="bticked"><a class="header" href="#bticked"><strong><code>bTicked</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool bTicked;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-5"><a class="header" href="#specifiers-5">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Systems|Metronome</em></li>
</ul>
<hr />
<p>Tells if metronome has ticked.</p>
</li>
</ul>
<hr />
<h1 id="methods-3"><a class="header" href="#methods-3"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="consumeticked"><a class="header" href="#consumeticked"><strong><code>ConsumeTicked</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool ConsumeTicked();
</code></pre>
<details>
<hr />
<p>Chechs if metronome ticked and consumes <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/FMetronome.html#bticked"><strong><code>FMetronome::bTicked</code></strong></a>
(sets it to <code>false</code>).</p>
</details>
</li>
<li>
<h1 id="progress"><a class="header" href="#progress"><strong><code>Progress</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Progress(
    float DeltaTime
);
</code></pre>
<details>
<hr />
<p>Performs <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/FMetronome.html#accumulator"><strong><code>FMetronome::Accumulator</code></strong></a> accumulation by
<code>DeltaTime</code> value.</p>
<hr />
<h1 id="arguments-32"><a class="header" href="#arguments-32"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="deltatime"><a class="header" href="#deltatime"><strong><code>DeltaTime</code></strong></a></h2>
<pre><code class="language-cpp">float DeltaTime
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="randomize"><a class="header" href="#randomize"><strong><code>Randomize</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Randomize();
</code></pre>
<details>
<hr />
<p>Tries to uniformly randomize <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/FMetronome.html#accumulator"><strong><code>FMetronome::Accumulator</code></strong></a> value
in range from 0 to <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/FMetronome.html#limit"><strong><code>FMetronome::Limit</code></strong></a>.</p>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-fsystemspipelinecomponent"><a class="header" href="#struct-fsystemspipelinecomponent"><strong>Struct: <code>FSystemsPipelineComponent</code></strong></a></h1>
<pre><code class="language-cpp">struct SYSTEMS_API FSystemsPipelineComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-6"><a class="header" href="#specifiers-6">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Pipeline component descriptor.</p>
<hr />
<h1 id="properties-1"><a class="header" href="#properties-1"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="bdevelopmentbuildonly"><a class="header" href="#bdevelopmentbuildonly"><strong><code>bDevelopmentBuildOnly</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool bDevelopmentBuildOnly;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-7"><a class="header" href="#specifiers-7">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Options</em></li>
</ul>
<hr />
<p>Tells if this component should be used in development builds only.</p>
<p>Useful for debug or prototype game features.</p>
</li>
<li>
<h1 id="buse"><a class="header" href="#buse"><strong><code>bUse</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool bUse;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-8"><a class="header" href="#specifiers-8">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Options</em></li>
</ul>
<hr />
<p>Tells if this component should be used.</p>
<p>Useful for quick enable/disable of component without removing it from
the pipeline (quick tests).</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-fsystemspipelineresource"><a class="header" href="#struct-fsystemspipelineresource"><strong>Struct: <code>FSystemsPipelineResource</code></strong></a></h1>
<pre><code class="language-cpp">struct SYSTEMS_API FSystemsPipelineResource;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-9"><a class="header" href="#specifiers-9">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Pipeline resource descriptor.</p>
<hr />
<h1 id="properties-2"><a class="header" href="#properties-2"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="bdevelopmentbuildonly-1"><a class="header" href="#bdevelopmentbuildonly-1"><strong><code>bDevelopmentBuildOnly</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool bDevelopmentBuildOnly;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-10"><a class="header" href="#specifiers-10">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Options</em></li>
</ul>
<hr />
<p>Tells if this resource should be used in development builds only.</p>
<p>Useful for debug or prototype game features.</p>
</li>
<li>
<h1 id="buse-1"><a class="header" href="#buse-1"><strong><code>bUse</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool bUse;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-11"><a class="header" href="#specifiers-11">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Options</em></li>
</ul>
<hr />
<p>Tells if this resource should be used.</p>
<p>Useful for quick enable/disable of resource without removing it from the
pipeline (quick tests).</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-fsystemspipelinesystem"><a class="header" href="#struct-fsystemspipelinesystem"><strong>Struct: <code>FSystemsPipelineSystem</code></strong></a></h1>
<pre><code class="language-cpp">struct SYSTEMS_API FSystemsPipelineSystem;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-12"><a class="header" href="#specifiers-12">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Pipeline system descriptor.</p>
<hr />
<h1 id="properties-3"><a class="header" href="#properties-3"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="template"><a class="header" href="#template"><strong><code>Template</code></strong></a></h1>
<pre><code class="language-cpp">public:
TObjectPtr&lt;USystem&gt; Template;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-13"><a class="header" href="#specifiers-13">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Export</strong></li>
<li><strong>Instanced</strong></li>
<li><strong>Category</strong> = <em>System</em></li>
</ul>
<hr />
<p>Template of system to instantiate.</p>
</li>
<li>
<h1 id="bdevelopmentbuildonly-2"><a class="header" href="#bdevelopmentbuildonly-2"><strong><code>bDevelopmentBuildOnly</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool bDevelopmentBuildOnly;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-14"><a class="header" href="#specifiers-14">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Options</em></li>
</ul>
<hr />
<p>Tells if this system should be used in development builds only.</p>
<p>Useful for debug or prototype game features.</p>
</li>
<li>
<h1 id="buse-2"><a class="header" href="#buse-2"><strong><code>bUse</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool bUse;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-15"><a class="header" href="#specifiers-15">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Options</em></li>
</ul>
<hr />
<p>Tells if this system should be used.</p>
<p>Useful for quick enable/disable of this system without removing it from
the pipeline (quick tests).</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-itersizehint"><a class="header" href="#struct-itersizehint"><strong>Struct: <code>IterSizeHint</code></strong></a></h1>
<pre><code class="language-cpp">struct IterSizeHint;
</code></pre>
<hr />
<p>Hint about minimum and optionally maximum number of items iterator can
yield.</p>
<p>See <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#sizehint"><strong><code>TQuery::SizeHint</code></strong></a>.</p>
<h1 id="example-30"><a class="header" href="#example-30">Example</a></h1>
<pre><code class="language-cpp">template &lt;typename I&gt;
void IterCollectIntoArray(I&amp;&amp; Iterator, TArray&lt;typename I::Item&gt;&amp; Result)
{
	const auto SizeHint = Iterator.SizeHint();
	const auto Capacity = SizeHint.Maximum.IsSet() ? SizeHint.Maximum.GetValue() : SizeHint.Minimum;
	Result.Reserve(Result.Num() + Capacity);
	while (auto QueryItem = Iterator.Next())
	{
		Result.Add(QueryItem.GetValue());
	}
}
</code></pre>
<hr />
<h1 id="properties-4"><a class="header" href="#properties-4"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="maximum"><a class="header" href="#maximum"><strong><code>Maximum</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;uint32&gt; Maximum;
</code></pre>
<hr />
<p>Maximum number of items iterator can yield.</p>
</li>
<li>
<h1 id="minimum"><a class="header" href="#minimum"><strong><code>Minimum</code></strong></a></h1>
<pre><code class="language-cpp">public:
uint32 Minimum;
</code></pre>
<hr />
<p>Minimum number of items iterator can yield.</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-tquery"><a class="header" href="#struct-tquery"><strong>Struct: <code>TQuery</code></strong></a></h1>
<pre><code class="language-cpp">template &lt;class... T&gt;
struct TQuery;
</code></pre>
<hr />
<p>Systems world query iterator.</p>
<p>Allows to iterate over actors and their components that comply to requested
types signature.</p>
<p>More about iterators in <a href="reference/structs//Unreal-Systems-Architecture/systems/book/architecture/iterators.html">this architecture book
page</a>.</p>
<h1 id="note-17"><a class="header" href="#note-17">Note</a></h1>
<blockquote>
<p>User should rather construct queries with <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#query"><strong><code>USystemsWorld::Query</code></strong></a>
instead o constructing queries by hand.</p>
</blockquote>
<blockquote>
<p>Returned query iterator has always put actor as first item of item tuple
and then follow requested components. So <code>Systems-&gt;Query&lt;A, B, C&gt;()</code>
iterator will yield given tuple <code>TTuple&lt;AActor*, A*, B*, C*&gt;</code></p>
</blockquote>
<h1 id="example-31"><a class="header" href="#example-31">Example</a></h1>
<pre><code class="language-cpp">	const auto Count = static_cast&lt;int&gt;(Systems.Query&lt;UBoidComponent&gt;().Count());
	const auto Difference = Count - EXPECTED_POPULATION_NUMBER;

	if (Difference &gt; 0)
	{
		Systems.Query&lt;UBoidComponent&gt;()
			.Take(Difference)
			.ForEach(
				[](auto&amp; QueryItem)
				{
					auto* Actor = QueryItem.Get&lt;0&gt;();

					Actor-&gt;Destroy();
				});
	}
</code></pre>
<hr />
<h1 id="methods-4"><a class="header" href="#methods-4"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="adapt-1"><a class="header" href="#adapt-1"><strong><code>Adapt</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename ADAPTER&gt;
TIterAdapt&lt;Self, ADAPTER&gt; Adapt(
    ADAPTER Adapter
);
</code></pre>
<details>
<hr />
<p>Injects custom iterator adapter into the chain of iteration.</p>
<p>Useful only for really custom/advanced solutions that cannot be solved with
regular iterators.</p>
<h1 id="note-18"><a class="header" href="#note-18">Note</a></h1>
<blockquote>
<p><code>ADAPTER</code> should implement iterator adapter methods. Yielded values share
same type wit iterator that wraps this adapter.</p>
</blockquote>
<h1 id="example-32"><a class="header" href="#example-32">Example</a></h1>
<pre><code class="language-cpp">// [1, 3, 5, 7, 9]
const TArray&lt;int&gt; Result = IterRange(0, 10).Adapt(TIterOddAdapter&lt;int&gt;()).CollectArray();
</code></pre>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct TIterOddAdapter
{
public:
	template &lt;typename I&gt;
	TOptional&lt;T&gt; Next(I&amp; Iter)
	{
		Iter.Next();
		return Iter.Next();
	}

	template &lt;typename I&gt;
	IterSizeHint SizeHint(const I&amp; Iter) const
	{
		return Iter.SizeHint();
	}
};
</code></pre>
<hr />
<h1 id="arguments-33"><a class="header" href="#arguments-33"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="adapter-1"><a class="header" href="#adapter-1"><strong><code>Adapter</code></strong></a></h2>
<pre><code class="language-cpp">ADAPTER Adapter
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="all-1"><a class="header" href="#all-1"><strong><code>All</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
bool All(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Checks if all values yielded by this iterator passes predicate.</p>
<h1 id="note-19"><a class="header" href="#note-19">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-33"><a class="header" href="#example-33">Example</a></h1>
<pre><code class="language-cpp">// false
const bool Result = IterRange(0, 10).All([](const auto&amp; Value) { return Value &gt; 5; });
</code></pre>
<hr />
<h1 id="arguments-34"><a class="header" href="#arguments-34"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-11"><a class="header" href="#func-11"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="any-1"><a class="header" href="#any-1"><strong><code>Any</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
bool Any(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Checks if any value yielded by this iterator passes predicate.</p>
<h1 id="note-20"><a class="header" href="#note-20">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-34"><a class="header" href="#example-34">Example</a></h1>
<pre><code class="language-cpp">// true
const bool Result = IterRange(0, 10).Any([](const auto&amp; Value) { return Value &gt; 5; });
</code></pre>
<hr />
<h1 id="arguments-35"><a class="header" href="#arguments-35"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-12"><a class="header" href="#func-12"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="cast-1"><a class="header" href="#cast-1"><strong><code>Cast</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT&gt;
TIterCast&lt;typename RESULT, Self&gt; Cast();
</code></pre>
<details>
<hr />
<p>Casts yielded values to another type.</p>
<p>Commonly used as a shourtcut for mapping between types using target type
constructor.</p>
<h1 id="note-21"><a class="header" href="#note-21">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is type that this iterator will yield after casting.</p>
</blockquote>
<h1 id="example-35"><a class="header" href="#example-35">Example</a></h1>
<pre><code class="language-cpp">// [0.0, 1.0, 2.0, 3.0, 4.0]
const TArray&lt;float&gt; Result = IterRange(0, 5).Cast&lt;float&gt;().CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="chain-1"><a class="header" href="#chain-1"><strong><code>Chain</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename ITER&gt;
TIterChain&lt;Self, ITER&gt; Chain(
    ITER&amp;&amp; Iter
);
</code></pre>
<details>
<hr />
<p>Appends another iterator at the end of this iterator.</p>
<p>Useful for combining results of different iterators that yield same value
type.</p>
<h1 id="note-22"><a class="header" href="#note-22">Note</a></h1>
<blockquote>
<p><code>ITER</code> should implement iterator methods. Yielded values share same type
with this iterato value type.</p>
</blockquote>
<h1 id="example-36"><a class="header" href="#example-36">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4, -5, -4, -3, -2, -1]
const TArray&lt;int&gt; Result = IterRange(0, 5).Chain(IterRange(-5, 0)).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-36"><a class="header" href="#arguments-36"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="iter-2"><a class="header" href="#iter-2"><strong><code>Iter</code></strong></a></h2>
<pre><code class="language-cpp">ITER&amp;&amp; Iter
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="collectarray"><a class="header" href="#collectarray"><strong><code>CollectArray</code></strong></a></h1>
<pre><code class="language-cpp">public:
TArray&lt;Item&gt; CollectArray();
</code></pre>
<details>
<hr />
<p>Consumes iterator and returns an array with its values.</p>
<h1 id="example-37"><a class="header" href="#example-37">Example</a></h1>
<pre><code class="language-cpp">const TArray&lt;int&gt; Result = IterRange(0, 10).CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="collectintoarray"><a class="header" href="#collectintoarray"><strong><code>CollectIntoArray</code></strong></a></h1>
<pre><code class="language-cpp">public:
void CollectIntoArray(
    TArray&lt;Item&gt;&amp; Result
);
</code></pre>
<details>
<hr />
<p>Consumes iterator and stores its values into provided array.</p>
<h1 id="example-38"><a class="header" href="#example-38">Example</a></h1>
<pre><code class="language-cpp">TArray&lt;int&gt; Result();
IterRange(0, 10).CollectIntoArray(Result);
</code></pre>
<hr />
<h1 id="arguments-37"><a class="header" href="#arguments-37"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="result"><a class="header" href="#result"><strong><code>Result</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;Item&gt;&amp; Result
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="collectintoset"><a class="header" href="#collectintoset"><strong><code>CollectIntoSet</code></strong></a></h1>
<pre><code class="language-cpp">public:
void CollectIntoSet(
    TSet&lt;Item&gt;&amp; Result
);
</code></pre>
<details>
<hr />
<p>Consumes iterator and stores its values into provided set.</p>
<h1 id="example-39"><a class="header" href="#example-39">Example</a></h1>
<pre><code class="language-cpp">TSet&lt;int&gt; Result();
IterRange(0, 10).CollectIntoSet(Result);
</code></pre>
<hr />
<h1 id="arguments-38"><a class="header" href="#arguments-38"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="result-1"><a class="header" href="#result-1"><strong><code>Result</code></strong></a></h2>
<pre><code class="language-cpp">TSet&lt;Item&gt;&amp; Result
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="collectset"><a class="header" href="#collectset"><strong><code>CollectSet</code></strong></a></h1>
<pre><code class="language-cpp">public:
TSet&lt;Item&gt; CollectSet();
</code></pre>
<details>
<hr />
<p>Consumes iterator and returns a set with its values.</p>
<h1 id="example-40"><a class="header" href="#example-40">Example</a></h1>
<pre><code class="language-cpp">const TArray&lt;int&gt; Result = IterRange(0, 10).CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="comparedby-1"><a class="header" href="#comparedby-1"><strong><code>ComparedBy</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TOptional&lt;Item&gt; ComparedBy(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Finds iterator value that compared to other items gets greater &quot;score&quot;.</p>
<p>Headline is rather vague, but what it actually does is user can do finding
min/max value with this iterator consumer.</p>
<h1 id="note-23"><a class="header" href="#note-23">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item A, I::Item B)</code> where <code>A</code> holds current value yielded by iterator and <code>B</code> is
the one that has best &quot;score&quot; so far.</p>
</blockquote>
<h1 id="example-41"><a class="header" href="#example-41">Example</a></h1>
<pre><code class="language-cpp">// 42
const int Result = IterRange(0, 42).ComparedBy([](const auto A, const auto B) { return A &gt; B; });
</code></pre>
<hr />
<h1 id="arguments-39"><a class="header" href="#arguments-39"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-13"><a class="header" href="#func-13"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="count-3"><a class="header" href="#count-3"><strong><code>Count</code></strong></a></h1>
<pre><code class="language-cpp">public:
uint32 Count();
</code></pre>
<details>
<hr />
<p>Returns exact number of items that iterator can yield.</p>
<h1 id="example-42"><a class="header" href="#example-42">Example</a></h1>
<pre><code class="language-cpp">// 10
const uint32 Result = IterRange(0, 10).Count();
</code></pre>
</details>
</li>
<li>
<h1 id="enumerate-1"><a class="header" href="#enumerate-1"><strong><code>Enumerate</code></strong></a></h1>
<pre><code class="language-cpp">public:
TIterEnumerate&lt;Self&gt; Enumerate();
</code></pre>
<details>
<hr />
<p>Enumerates values in this iterator.</p>
<p>Useful for reading index of element/iteration.</p>
<h1 id="note-24"><a class="header" href="#note-24">Note</a></h1>
<blockquote>
<p>Yielded values have type: <code>TTuple&lt;uint32, Item&gt;</code>, which means this
iterator yields tuple o index-value pair.</p>
</blockquote>
<h1 id="example-43"><a class="header" href="#example-43">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4]
const TArray&lt;int&gt; Result =
	IterRepeat(42).Enumerate().Map&lt;int&gt;([](const auto&amp; Pair) { return Pair.Get&lt;0&gt;(); }).Take(5).CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="filter-1"><a class="header" href="#filter-1"><strong><code>Filter</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TIterFilter&lt;Self, typename FUNCTOR&gt; Filter(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Filters values in the iterator by predicate.</p>
<h1 id="note-25"><a class="header" href="#note-25">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to this function signature: <code>bool(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-44"><a class="header" href="#example-44">Example</a></h1>
<pre><code class="language-cpp">// [0, 2, 4, 6, 8]
const TArray&lt;int&gt; Result = IterRange(0, 10).Filter([](const auto&amp; Value) { return Value % 2 == 0; }).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-40"><a class="header" href="#arguments-40"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-14"><a class="header" href="#func-14"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="filtermap-1"><a class="header" href="#filtermap-1"><strong><code>FilterMap</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT, typename FUNCTOR&gt;
TIterFilterMap&lt;typename RESULT, Self, typename FUNCTOR&gt; FilterMap(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Filters values in the iterator by predicate and maps them to another type.</p>
<h1 id="note-26"><a class="header" href="#note-26">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is a type of values yielded by this iterator that maps into.
<code>FUNCTOR</code> should comply to this function signature:
<code>TOptional&lt;RESULT&gt;(const I::Item&amp; Value)</code> Returning some value means
pasing it to next iterator, returning none means we omit thi value.</p>
</blockquote>
<h1 id="example-45"><a class="header" href="#example-45">Example</a></h1>
<pre><code class="language-cpp">// [0.0, 2.0, 4.0, 6.0, 8.0]
const TArray&lt;float&gt; I = IterRange(0, 10)
							.FilterMap&lt;float&gt;(
								[](const auto&amp; Value)
								{
									if (Value % 2 == 0)
									{
										return TOptional&lt;float&gt;(static_cast&lt;float&gt;(Value));
									}
									else
									{
										return TOptional&lt;float&gt;();
									}
								})
							.CollectArray();
</code></pre>
<hr />
<h1 id="arguments-41"><a class="header" href="#arguments-41"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-15"><a class="header" href="#func-15"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="find-1"><a class="header" href="#find-1"><strong><code>Find</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TOptional&lt;Item&gt; Find(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Finds and returns value in this iterator that passes <code>FUNCTOR</code> predicate.</p>
<h1 id="note-27"><a class="header" href="#note-27">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-46"><a class="header" href="#example-46">Example</a></h1>
<pre><code class="language-cpp">// 5
const TOptional&lt;int&gt; Result = IterRange(0, 10).Find([](const auto&amp; Value) { return Value &gt;= 5; });
</code></pre>
<hr />
<h1 id="arguments-42"><a class="header" href="#arguments-42"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-16"><a class="header" href="#func-16"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="findmap-1"><a class="header" href="#findmap-1"><strong><code>FindMap</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT, typename FUNCTOR&gt;
TOptional&lt;RESULT&gt; FindMap(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Finds and returns value in this iterator that passes <code>FUNCTOR</code> predicate,
mapped to another type.</p>
<h1 id="note-28"><a class="header" href="#note-28">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature:
<code>TOptional&lt;Item&gt;(I::Item Value)</code> where <code>Value</code> holds current value
yielded by iterator. <code>RESULT</code> is the returned type and use should always
return <code>TOptional&lt;RESULT&gt;</code> in the predicate where some value means &quot;found&quot;
an none means &quot;not found&quot;.</p>
</blockquote>
<h1 id="example-47"><a class="header" href="#example-47">Example</a></h1>
<pre><code class="language-cpp">// 5.0
const TOptional&lt;float&gt; Result = IterRange(0, 10).FindMap&lt;float&gt;(
	[](const auto&amp; Value)
	{
		if (Value &gt;= 5)
		{
			return TOptional&lt;float&gt;(static_cast&lt;float&gt;(Value));
		}
		else
		{
			return TOptional&lt;float&gt;();
		}
	});
</code></pre>
<hr />
<h1 id="arguments-43"><a class="header" href="#arguments-43"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-17"><a class="header" href="#func-17"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="first-1"><a class="header" href="#first-1"><strong><code>First</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; First();
</code></pre>
<details>
<hr />
<p>Returns first item in the iterator.</p>
<p>This is an equivalent of calling <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#next"><strong><code>TQuery::Next</code></strong></a>.</p>
<h1 id="example-48"><a class="header" href="#example-48">Example</a></h1>
<pre><code class="language-cpp">// 5
const int Result = IterRange(5, 10).First();
</code></pre>
</details>
</li>
<li>
<h1 id="flatten-1"><a class="header" href="#flatten-1"><strong><code>Flatten</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT&gt;
TIterFlatten&lt;typename RESULT, Self&gt; Flatten();
</code></pre>
<details>
<hr />
<p>Flattens nested iterators.</p>
<p>Imagine you have an iterator that yields another iterators, such as arrays
of arrays.</p>
<h1 id="note-29"><a class="header" href="#note-29">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is a type of values yielded by this iterator - it should be the
same as neste iterator value type (c++ won't accept that syntax, hence we
have to provide a <code>RESULT</code> typ and ensure it's the same) <code>FUNCTOR</code>
should comply to this function signature: <code>RESULT(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-49"><a class="header" href="#example-49">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
const TArray&lt;int&gt; P =
	IterGenerate&lt;TIterRange&lt;int&gt;&gt;([]() { return IterRange(0, 5); }).Take(2).Flatten&lt;int&gt;().CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="fold-1"><a class="header" href="#fold-1"><strong><code>Fold</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
Item Fold(
    Item Start,
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Folds iterator into single value.</p>
<p>Folding basically means going through all iterator items and collapsing them
into single value. Example of folding can be sum/accumulation, or min/max,
or anything like that - although for ones mentioned there are existing
optimized iterator consumers: <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#sum"><strong><code>TQuery::Sum</code></strong></a> and
<a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#comparedby"><strong><code>TQuery::ComparedBy</code></strong></a>.</p>
<h1 id="note-30"><a class="header" href="#note-30">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is the returned type, same as <code>Start</code> argument used as initial
accumulator. <code>FUNCTOR</code> should comply to given function signature: <code>Item(Item Accumulator, I::Item Value)</code> where <code>Accumulator</code> argument holds result of
previous iteration, and <code>Value</code> holds curren value yielded by iterator.
<code>Start</code> argument holds value passed to first iteratio <code>Accumulator</code>.</p>
</blockquote>
<h1 id="example-50"><a class="header" href="#example-50">Example</a></h1>
<pre><code class="language-cpp">// 45
const int Result = IterRange(0, 10).Fold(0, [](const auto&amp; Accum, const auto&amp; Value) { return Accum + Value; });
</code></pre>
<hr />
<h1 id="arguments-44"><a class="header" href="#arguments-44"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="start-1"><a class="header" href="#start-1"><strong><code>Start</code></strong></a></h2>
<pre><code class="language-cpp">Item Start
</code></pre>
</li>
<li>
<h2 id="func-18"><a class="header" href="#func-18"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="foreach-1"><a class="header" href="#foreach-1"><strong><code>ForEach</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
void ForEach(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Consumes iterator and yields its values for user to process.</p>
<p>This is equivalent of:</p>
<pre><code class="language-cpp">auto Iter = IterRange(0, 9);
while (const auto Value = Iter.Next())
{
	const auto Squared = Value * Value;
	UE_LOG(LogTemp, Warning, TEXT(&quot;Squared value: %i&quot;), Squared);
}
</code></pre>
<h1 id="note-31"><a class="header" href="#note-31">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>void(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-51"><a class="header" href="#example-51">Example</a></h1>
<pre><code class="language-cpp">IterRange(0, 9).ForEach(
	[](const auto&amp; Value)
	{
		const auto Squared = Value * Value;
		UE_LOG(LogTemp, Warning, TEXT(&quot;Squared value: %i&quot;), Squared);
	});
</code></pre>
<hr />
<h1 id="arguments-45"><a class="header" href="#arguments-45"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-19"><a class="header" href="#func-19"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="inspect-1"><a class="header" href="#inspect-1"><strong><code>Inspect</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TIterInspect&lt;Self, typename FUNCTOR&gt; Inspect(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Inspects yielded values.</p>
<p>Useful when debugging iterators to for example log what values are yielded
at which iterator chain stage.</p>
<h1 id="note-32"><a class="header" href="#note-32">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to this function signature: <code>void(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-52"><a class="header" href="#example-52">Example</a></h1>
<pre><code class="language-cpp">// [0, 2, 4, 6, 8]
const TArray&lt;int&gt; Result = IterRange(0, 10)
							   .Inspect(
								   [](const auto&amp; Value)
								   {
									   // Prints values: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
									   UE_LOG(LogTemp, Warning, TEXT(&quot;Inspected item before: %i&quot;), Value);
								   })
							   .Filter([](const auto&amp; Value) { return Value % 2 == 0; })
							   .Inspect(
								   [](const auto&amp; Value)
								   {
									   // Prints values: 0, 2, 4, 6, 8.
									   UE_LOG(LogTemp, Warning, TEXT(&quot;Inspected item after: %i&quot;), Value);
								   })
							   .CollectArray();
</code></pre>
<hr />
<h1 id="arguments-46"><a class="header" href="#arguments-46"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-20"><a class="header" href="#func-20"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="last-1"><a class="header" href="#last-1"><strong><code>Last</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; Last();
</code></pre>
<details>
<hr />
<p>Returns last item in the iterator.</p>
<h1 id="example-53"><a class="header" href="#example-53">Example</a></h1>
<pre><code class="language-cpp">// 4
const int Result = IterRange(0, 4).Last();
</code></pre>
</details>
</li>
<li>
<h1 id="map-1"><a class="header" href="#map-1"><strong><code>Map</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT, typename FUNCTOR&gt;
TIterMap&lt;typename RESULT, Self, typename FUNCTOR&gt; Map(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Maps yielded values to another type.</p>
<p>Commonly used for data transformations for use in later stages of iteration.</p>
<h1 id="note-33"><a class="header" href="#note-33">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is type that this iterator will yield after data transformations.
<code>FUNCTOR</code> should comply to this function signature: <code>RESULT(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-54"><a class="header" href="#example-54">Example</a></h1>
<pre><code class="language-cpp">// [0.0, 4.0, 16.0, 36.0, 64.0]
const TArray&lt;float&gt; Result = IterRange(0, 10)
								 .Filter([](const auto&amp; Value) { return Value % 2 == 0; })
								 .Map&lt;float&gt;([](const auto&amp; Value) { return static_cast&lt;float&gt;(Value * Value); })
								 .CollectArray();
</code></pre>
<hr />
<h1 id="arguments-47"><a class="header" href="#arguments-47"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-21"><a class="header" href="#func-21"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="next-1"><a class="header" href="#next-1"><strong><code>Next</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; Next();
</code></pre>
<details>
<hr />
<p>Yields tuple to next actors component set.</p>
<p>Usually user would rather want to use iterator methods for ergonomic
iteration over the query, but in case user has valid reasons to handle
iteration different way, this is the single point that performs
iteration and yields an item.</p>
<h1 id="example-55"><a class="header" href="#example-55">Example</a></h1>
<pre><code class="language-cpp">	auto Query = Systems.Query&lt;UShiaComponent&gt;();
	while (auto&amp; QueryItem = Query.Next())
	{
		// Note that we do not check if QueryItem optional value is set.
		// `while` loop perform these checks for us, hence we use it
		// instead of standard `for` loop.
		auto* Actor = QueryItem.GetValue().Get&lt;0&gt;();
		auto* Shia = QueryItem.GetValue().Get&lt;1&gt;();

		Shia-&gt;JustDoIt(Actor);
	}
</code></pre>
</details>
</li>
<li>
<h1 id="nth-1"><a class="header" href="#nth-1"><strong><code>Nth</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; Nth(
    uint32 Index
);
</code></pre>
<details>
<hr />
<p>Returns Nth item in the iterator.</p>
<h1 id="example-56"><a class="header" href="#example-56">Example</a></h1>
<pre><code class="language-cpp">// 5
const TOptional&lt;int&gt; Result = IterRange(0, 10).Nth(5);
</code></pre>
<hr />
<h1 id="arguments-48"><a class="header" href="#arguments-48"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="index-4"><a class="header" href="#index-4"><strong><code>Index</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Index
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="sizehint-1"><a class="header" href="#sizehint-1"><strong><code>SizeHint</code></strong></a></h1>
<pre><code class="language-cpp">public:
IterSizeHint SizeHint() const;
</code></pre>
<details>
<hr />
<p>Gets hint about minimum and optional maximum items count this iterator
can yield.</p>
<p>Used internally by lazy-iterators, but in case user would like to
implement their own iterators, or iterator consumers, or just wants to
preallocate some memory for later consumed iterator items, this method
is really useful for these usecases.</p>
<p>See <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/IterSizeHint.html"><strong><code>IterSizeHint</code></strong></a>.</p>
<h1 id="example-57"><a class="header" href="#example-57">Example</a></h1>
<pre><code class="language-cpp">template &lt;typename I&gt;
void IterCollectIntoArray(I&amp;&amp; Iterator, TArray&lt;typename I::Item&gt;&amp; Result)
{
	const auto SizeHint = Iterator.SizeHint();
	const auto Capacity = SizeHint.Maximum.IsSet() ? SizeHint.Maximum.GetValue() : SizeHint.Minimum;
	Result.Reserve(Result.Num() + Capacity);
	while (auto QueryItem = Iterator.Next())
	{
		Result.Add(QueryItem.GetValue());
	}
}
</code></pre>
</details>
</li>
<li>
<h1 id="skip-1"><a class="header" href="#skip-1"><strong><code>Skip</code></strong></a></h1>
<pre><code class="language-cpp">public:
TIterSkip&lt;Self&gt; Skip(
    uint32 Count
);
</code></pre>
<details>
<hr />
<p>Skips iteration by number of elements.</p>
<p>It's worth noting that this is one-shot skip, not repeated one, which means
if we yield iterator of 10 elements and we skip 2 iterations, then it will
skip just 2 values and yield rest 8.</p>
<h1 id="example-58"><a class="header" href="#example-58">Example</a></h1>
<pre><code class="language-cpp">// [3, 4, 5, 6, 7]
const TArray&lt;int&gt; Result = IterRange(0, 10).Skip(3).Take(5).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-49"><a class="header" href="#arguments-49"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="count-4"><a class="header" href="#count-4"><strong><code>Count</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Count
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="sum"><a class="header" href="#sum"><strong><code>Sum</code></strong></a></h1>
<pre><code class="language-cpp">public:
Item Sum(
    Item InitialValue
);
</code></pre>
<details>
<hr />
<p>Returns sum of values that iterator can yield.</p>
<h1 id="note-34"><a class="header" href="#note-34">Note</a></h1>
<blockquote>
<p>Make sure that type of iterator values actually implement <code>operator+</code>!
Also since iterator can work on non-numerical types, user has to provide
initial value, tha makes it work like <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#fold"><strong><code>TQuery::Fold</code></strong></a>.</p>
</blockquote>
<h1 id="example-59"><a class="header" href="#example-59">Example</a></h1>
<pre><code class="language-cpp">// 45
const int Return = IterRange(0, 10).Sum(0);
</code></pre>
<p>This is equivalent of:</p>
<pre><code class="language-cpp">// 45
const int Result = IterRange(0, 10).Fold(0, [](const auto&amp; Accum, const auto&amp; Value) { return Accum + Value; });
</code></pre>
<hr />
<h1 id="arguments-50"><a class="header" href="#arguments-50"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="initialvalue"><a class="header" href="#initialvalue"><strong><code>InitialValue</code></strong></a></h2>
<pre><code class="language-cpp">Item InitialValue
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="tquery"><a class="header" href="#tquery"><strong><code>TQuery</code></strong></a></h1>
<pre><code class="language-cpp">public:
TQuery(
    USystemsWorld* Systems
);
</code></pre>
<details>
<hr />
<p>Constructs query from systems.</p>
<p>An equivalent of calling <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#query"><strong><code>USystemsWorld::Query</code></strong></a></p>
<hr />
<h1 id="arguments-51"><a class="header" href="#arguments-51"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="systems-3"><a class="header" href="#systems-3"><strong><code>Systems</code></strong></a></h2>
<pre><code class="language-cpp">USystemsWorld* Systems
</code></pre>
<p>Pointer to systems world of which actor components user wants to
iterate on.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="take-1"><a class="header" href="#take-1"><strong><code>Take</code></strong></a></h1>
<pre><code class="language-cpp">public:
TIterTake&lt;Self&gt; Take(
    uint32 Count
);
</code></pre>
<details>
<hr />
<p>Limits iterator to at most number of iterations.</p>
<p>If we create an iterator that yields 10 values and we tell it to take 5,
then it will stop iterating after next 5 values (or less, depends if there
is enough values left in iterator).</p>
<h1 id="example-60"><a class="header" href="#example-60">Example</a></h1>
<pre><code class="language-cpp">// [3, 4, 5, 6, 7]
const TArray&lt;int&gt; Result = IterRange(0, 10).Skip(3).Take(5).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-52"><a class="header" href="#arguments-52"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="count-5"><a class="header" href="#count-5"><strong><code>Count</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Count
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="views-1"><a class="header" href="#views-1"><strong><code>Views</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;uint32 COUNT&gt;
TIterViews&lt;Self, COUNT&gt; Views();
</code></pre>
<details>
<hr />
<p>Yields sequences of consecutive views over set of values.</p>
<p>If we create an iterator that yields 5 integer values and we tell it to view
2 at the same time, then it will yield <code>TArrayView</code> with values: <code>[0, 1], [1, 2], [2, 3], [3, 4]</code>.</p>
<h1 id="example-61"><a class="header" href="#example-61">Example</a></h1>
<pre><code class="language-cpp">// [(0, 1), (1, 2), (2, 3), (3, 4)]
const TArray&lt;TTuple&lt;int, int&gt;&gt; Result =
	IterRange(0, 5)
		.Views&lt;2&gt;()
		.Map&lt;TTuple&lt;int, int&gt;&gt;([](const auto&amp; View) { return MakeTuple(View[0], View[1]); })
		.CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="zip-1"><a class="header" href="#zip-1"><strong><code>Zip</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename ITER&gt;
TIterZip&lt;Self, ITER&gt; Zip(
    ITER&amp;&amp; Iter
);
</code></pre>
<details>
<hr />
<p>Combines two iterators to make one that yields pair of both iterator values
at the same time.</p>
<h1 id="example-62"><a class="header" href="#example-62">Example</a></h1>
<pre><code class="language-cpp">// [(0, -5), (1, -4), (2, -3), (3, -2), (4, -1)]
const TArray&lt;TTuple&lt;int, int&gt;&gt; Result = IterRange(0, 5).Zip(IterRange(-5, 0)).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-53"><a class="header" href="#arguments-53"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="iter-3"><a class="header" href="#iter-3"><strong><code>Iter</code></strong></a></h2>
<pre><code class="language-cpp">ITER&amp;&amp; Iter
</code></pre>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-treceiverchannel"><a class="header" href="#struct-treceiverchannel"><strong>Struct: <code>TReceiverChannel</code></strong></a></h1>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct TReceiverChannel;
</code></pre>
<hr />
<p>SPMC (single-prodicer, multiple-consumer) receiver channel.</p>
<p>See <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TSenderChannel.html"><strong><code>TSenderChannel</code></strong></a>.</p>
<h1 id="example-63"><a class="header" href="#example-63">Example</a></h1>
<pre><code class="language-cpp">	auto Sender = TSenderChannel&lt;int&gt;();
	auto Receiver = Sender.Receiver(1);

	Sender.Send(42);
	while (const auto Value = Receiver.Receive())
	{
		UE_LOG(LogTemp, Warning, TEXT(&quot;Received value: %i&quot;), Value);
	}
</code></pre>
<hr />
<h1 id="methods-5"><a class="header" href="#methods-5"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="clear-1"><a class="header" href="#clear-1"><strong><code>Clear</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Clear();
</code></pre>
<details>
<hr />
<p>Clears internal queue.</p>
<p>User would rather want to read and conume stored messages but sometimes
user might have valid reasons to discard all messages without reading
them.</p>
</details>
</li>
<li>
<h1 id="isempty-1"><a class="header" href="#isempty-1"><strong><code>IsEmpty</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool IsEmpty() const;
</code></pre>
<details>
<hr />
<p>Checks if there are incoming messages in queue.</p>
</details>
</li>
<li>
<h1 id="receive"><a class="header" href="#receive"><strong><code>Receive</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;T&gt; Receive();
</code></pre>
<details>
<hr />
<p>Consumes and returns one message from internal queue.</p>
<h1 id="example-64"><a class="header" href="#example-64">Example</a></h1>
<pre><code class="language-cpp">	auto Sender = TSenderChannel&lt;int&gt;();
	auto Receiver = Sender.Receiver(1);

	Sender.Send(42);
	while (const auto Value = Receiver.Receive())
	{
		UE_LOG(LogTemp, Warning, TEXT(&quot;Received value: %i&quot;), Value);
	}
</code></pre>
</details>
</li>
<li>
<h1 id="unbind"><a class="header" href="#unbind"><strong><code>Unbind</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Unbind();
</code></pre>
<details>
<hr />
<p>Unbind from sender.</p>
<p>This forcefully unbinds reciever from sender and clears internal queue,
though user do not have to call this method when its lifetime ends -
receivers unbind themselves as soon as they get destroyed. This method
exists only in case user would want to stop receiving further messages
on demand, useful in more advanced scenarios.</p>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-tresult"><a class="header" href="#struct-tresult"><strong>Struct: <code>TResult</code></strong></a></h1>
<pre><code class="language-cpp">template &lt;typename T, typename E&gt;
struct TResult;
</code></pre>
<hr />
<p>Result type that can wrap either <code>T</code> value or <code>E</code> error data.</p>
<p>Useful for return types in functions that can return either valid value or
some error. Given implementation tries to match <code>TOptional</code> API as much as
possible.</p>
<h1 id="example-65"><a class="header" href="#example-65">Example</a></h1>
<pre><code class="language-cpp">UENUM()
enum class EGuessError : uint8
{
	TooHigh,
	TooLow,
};

USTRUCT()
struct FShiaTheSecretKeeper
{
	GENERATED_BODY()

public:
	FShiaTheSecretKeeper() : Secret(), Password()
	{
	}

	FShiaTheSecretKeeper(FString InSecret, int InPassword) : Secret(InSecret), Password(InPassword)
	{
	}

	TResult&lt;FString, EGuessError&gt; TryGuess(int GuessPassword)
	{
		if (GuessPassword == this-&gt;Password)
		{
			return TResult&lt;FString, EGuessError&gt;(this-&gt;Secret);
		}
		else if (GuessPassword &lt; this-&gt;Password)
		{
			return TResult&lt;FString, EGuessError&gt;(EGuessError::TooLow);
		}
		else
		{
			return TResult&lt;FString, EGuessError&gt;(EGuessError::TooHigh);
		}
	}

private:
	FString Secret = {};
	int Password = {};
};

int Main()
{
	const auto Shia = FShiaTheSecretKeeper(&quot;Just do it!&quot;, 42);
	const auto Result = Shia.TryGuess(42);
	if (Result.IsOk())
	{
		UE_LOG(LogTemp, Info, TEXT(&quot;Guessed! Secret: %s&quot;), *Result.GetOk());
	}
	else
	{
		switch (Result.GetError())
		{
			case EGuessError::TooHigh:
				UE_LOG(LogTemp, Error, TEXT(&quot;Too high!&quot;));
				break;

			case EGuessError::TooLow:
				UE_LOG(LogTemp, Error, TEXT(&quot;Too low!&quot;));
				break;
		}
	}
}
</code></pre>
<hr />
<h1 id="methods-6"><a class="header" href="#methods-6"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="aserror"><a class="header" href="#aserror"><strong><code>AsError</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;E&gt; AsError() const;
</code></pre>
<details>
<hr />
<p>Returns option with cloned error data.</p>
<p>In case of result wrapping value data, it returns none.</p>
</details>
</li>
<li>
<h1 id="asok"><a class="header" href="#asok"><strong><code>AsOk</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;T&gt; AsOk() const;
</code></pre>
<details>
<hr />
<p>Returns option with cloned value data.</p>
<p>In case of result wrapping error data, it returns none.</p>
</details>
</li>
<li>
<h1 id="geterror"><a class="header" href="#geterror"><strong><code>GetError</code></strong></a></h1>
<pre><code class="language-cpp">public:
E&amp; GetError();
</code></pre>
<details>
<hr />
<p>Returns reference to internal error.</p>
<h1 id="note-35"><a class="header" href="#note-35">Note</a></h1>
<blockquote>
<p>It panics if result wraps value data.</p>
</blockquote>
</details>
</li>
<li>
<h1 id="geterror-1"><a class="header" href="#geterror-1"><strong><code>GetError</code></strong></a></h1>
<pre><code class="language-cpp">public:
const E&amp; GetError() const;
</code></pre>
<details>
<hr />
<p>Returns reference to internal error.</p>
<h1 id="note-36"><a class="header" href="#note-36">Note</a></h1>
<blockquote>
<p>It panics if result wraps value data.</p>
</blockquote>
</details>
</li>
<li>
<h1 id="getok"><a class="header" href="#getok"><strong><code>GetOk</code></strong></a></h1>
<pre><code class="language-cpp">public:
T&amp; GetOk();
</code></pre>
<details>
<hr />
<p>Returns reference to internal value.</p>
<h1 id="note-37"><a class="header" href="#note-37">Note</a></h1>
<blockquote>
<p>It panics if result wraps error data.</p>
</blockquote>
</details>
</li>
<li>
<h1 id="getok-1"><a class="header" href="#getok-1"><strong><code>GetOk</code></strong></a></h1>
<pre><code class="language-cpp">public:
const T&amp; GetOk() const;
</code></pre>
<details>
<hr />
<p>Returns reference to internal value.</p>
<h1 id="note-38"><a class="header" href="#note-38">Note</a></h1>
<blockquote>
<p>It panics if result wraps error data.</p>
</blockquote>
</details>
</li>
<li>
<h1 id="iserror"><a class="header" href="#iserror"><strong><code>IsError</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool IsError() const;
</code></pre>
<details>
<hr />
<p>Tells if result wraps error data.</p>
</details>
</li>
<li>
<h1 id="isok"><a class="header" href="#isok"><strong><code>IsOk</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool IsOk() const;
</code></pre>
<details>
<hr />
<p>Tells if result wraps value data.</p>
</details>
</li>
<li>
<h1 id="seterror"><a class="header" href="#seterror"><strong><code>SetError</code></strong></a></h1>
<pre><code class="language-cpp">public:
void SetError(
    const E&amp; Error
);
</code></pre>
<details>
<hr />
<p>Replaces internal data with cloned error data.</p>
<hr />
<h1 id="arguments-54"><a class="header" href="#arguments-54"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="error"><a class="header" href="#error"><strong><code>Error</code></strong></a></h2>
<pre><code class="language-cpp">const E&amp; Error
</code></pre>
<p>Error to copy from.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="seterror-1"><a class="header" href="#seterror-1"><strong><code>SetError</code></strong></a></h1>
<pre><code class="language-cpp">public:
void SetError(
    E&amp;&amp; Error
);
</code></pre>
<details>
<hr />
<p>Replaces internal data with moved error data.</p>
<hr />
<h1 id="arguments-55"><a class="header" href="#arguments-55"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="error-1"><a class="header" href="#error-1"><strong><code>Error</code></strong></a></h2>
<pre><code class="language-cpp">E&amp;&amp; Error
</code></pre>
<p>Error to consume.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="setok"><a class="header" href="#setok"><strong><code>SetOk</code></strong></a></h1>
<pre><code class="language-cpp">public:
void SetOk(
    const T&amp; Value
);
</code></pre>
<details>
<hr />
<p>Replaces internal data with cloned value data.</p>
<hr />
<h1 id="arguments-56"><a class="header" href="#arguments-56"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="value"><a class="header" href="#value"><strong><code>Value</code></strong></a></h2>
<pre><code class="language-cpp">const T&amp; Value
</code></pre>
<p>Value to copy from.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="setok-1"><a class="header" href="#setok-1"><strong><code>SetOk</code></strong></a></h1>
<pre><code class="language-cpp">public:
void SetOk(
    T&amp;&amp; Value
);
</code></pre>
<details>
<hr />
<p>Replaces internal data with moved value data.</p>
<hr />
<h1 id="arguments-57"><a class="header" href="#arguments-57"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="value-1"><a class="header" href="#value-1"><strong><code>Value</code></strong></a></h2>
<pre><code class="language-cpp">T&amp;&amp; Value
</code></pre>
<p>Value to consume.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="tresult"><a class="header" href="#tresult"><strong><code>TResult</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult(
    const T&amp; Value
);
</code></pre>
<details>
<hr />
<p>Copy constructor.</p>
<hr />
<h1 id="arguments-58"><a class="header" href="#arguments-58"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="value-2"><a class="header" href="#value-2"><strong><code>Value</code></strong></a></h2>
<pre><code class="language-cpp">const T&amp; Value
</code></pre>
<p>Value data to copy from.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="tresult-1"><a class="header" href="#tresult-1"><strong><code>TResult</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult(
    T&amp;&amp; Value
);
</code></pre>
<details>
<hr />
<p>Move constructor.</p>
<hr />
<h1 id="arguments-59"><a class="header" href="#arguments-59"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="value-3"><a class="header" href="#value-3"><strong><code>Value</code></strong></a></h2>
<pre><code class="language-cpp">T&amp;&amp; Value
</code></pre>
<p>Value to consume.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="tresult-2"><a class="header" href="#tresult-2"><strong><code>TResult</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult(
    const E&amp; Error
);
</code></pre>
<details>
<hr />
<p>Copy constructor.</p>
<hr />
<h1 id="arguments-60"><a class="header" href="#arguments-60"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="error-2"><a class="header" href="#error-2"><strong><code>Error</code></strong></a></h2>
<pre><code class="language-cpp">const E&amp; Error
</code></pre>
<p>Error to copy from.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="tresult-3"><a class="header" href="#tresult-3"><strong><code>TResult</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult(
    E&amp;&amp; Error
);
</code></pre>
<details>
<hr />
<p>Move constructor.</p>
<hr />
<h1 id="arguments-61"><a class="header" href="#arguments-61"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="error-3"><a class="header" href="#error-3"><strong><code>Error</code></strong></a></h2>
<pre><code class="language-cpp">E&amp;&amp; Error
</code></pre>
<p>Error to consume.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="tresult-4"><a class="header" href="#tresult-4"><strong><code>TResult</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult(
    const TResult&amp; Other
);
</code></pre>
<details>
<hr />
<p>Copy constructor.</p>
<hr />
<h1 id="arguments-62"><a class="header" href="#arguments-62"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="other-7"><a class="header" href="#other-7"><strong><code>Other</code></strong></a></h2>
<pre><code class="language-cpp">const TResult&amp; Other
</code></pre>
<p>Result to copy from.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="tresult-5"><a class="header" href="#tresult-5"><strong><code>TResult</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult(
    TResult&amp;&amp; Other
);
</code></pre>
<details>
<hr />
<p>Move constructor.</p>
<hr />
<h1 id="arguments-63"><a class="header" href="#arguments-63"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="other-8"><a class="header" href="#other-8"><strong><code>Other</code></strong></a></h2>
<pre><code class="language-cpp">TResult&amp;&amp; Other
</code></pre>
<p>Result to consume.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="operator-bool"><a class="header" href="#operator-bool"><strong><code>operator bool</code></strong></a></h1>
<pre><code class="language-cpp">public:
explicit operator bool() const;
</code></pre>
<details>
<hr />
<p>Cast to boolean.</p>
<p>Handy shortcut for <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TResult.html#isok"><strong><code>TResult::IsOk</code></strong></a>.
Useful when used in if statement condition.</p>
</details>
</li>
<li>
<h1 id="operator"><a class="header" href="#operator"><strong><code>operator!=</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool operator!=(
    const TResult&amp; Lhs,
    const TResult&amp; Rhs
);
</code></pre>
<details>
<hr />
<p>Tells if two results aren't equal.</p>
<p>Two results must both wrap either value or error, and if they do then
their data is compared.</p>
<hr />
<h1 id="arguments-64"><a class="header" href="#arguments-64"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="lhs"><a class="header" href="#lhs"><strong><code>Lhs</code></strong></a></h2>
<pre><code class="language-cpp">const TResult&amp; Lhs
</code></pre>
</li>
<li>
<h2 id="rhs"><a class="header" href="#rhs"><strong><code>Rhs</code></strong></a></h2>
<pre><code class="language-cpp">const TResult&amp; Rhs
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="operator-1"><a class="header" href="#operator-1"><strong><code>operator&lt;&lt;</code></strong></a></h1>
<pre><code class="language-cpp">public:
FArchive&amp; operator&lt;&lt;(
    FArchive&amp; Ar,
    TResult&amp; Result
);
</code></pre>
<details>
<hr />
<p>Serializes given result.</p>
<hr />
<h1 id="arguments-65"><a class="header" href="#arguments-65"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="ar"><a class="header" href="#ar"><strong><code>Ar</code></strong></a></h2>
<pre><code class="language-cpp">FArchive&amp; Ar
</code></pre>
</li>
<li>
<h2 id="result-2"><a class="header" href="#result-2"><strong><code>Result</code></strong></a></h2>
<pre><code class="language-cpp">TResult&amp; Result
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="operator-2"><a class="header" href="#operator-2"><strong><code>operator=</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult&amp; operator=(
    const TResult&amp; Other
);
</code></pre>
<details>
<hr />
<p>Copies other result.</p>
<hr />
<h1 id="arguments-66"><a class="header" href="#arguments-66"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="other-9"><a class="header" href="#other-9"><strong><code>Other</code></strong></a></h2>
<pre><code class="language-cpp">const TResult&amp; Other
</code></pre>
<p>Result to copy from.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="operator-3"><a class="header" href="#operator-3"><strong><code>operator=</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult&amp; operator=(
    TResult&amp;&amp; Other
);
</code></pre>
<details>
<hr />
<p>Consumes other result.</p>
<hr />
<h1 id="arguments-67"><a class="header" href="#arguments-67"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="other-10"><a class="header" href="#other-10"><strong><code>Other</code></strong></a></h2>
<pre><code class="language-cpp">TResult&amp;&amp; Other
</code></pre>
<p>Result to consume.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="operator-4"><a class="header" href="#operator-4"><strong><code>operator=</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult&amp; operator=(
    const T&amp; Value
);
</code></pre>
<details>
<hr />
<p>Replaces internal data with cloned value data.</p>
<hr />
<h1 id="arguments-68"><a class="header" href="#arguments-68"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="value-4"><a class="header" href="#value-4"><strong><code>Value</code></strong></a></h2>
<pre><code class="language-cpp">const T&amp; Value
</code></pre>
<p>Value to copy from.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="operator-5"><a class="header" href="#operator-5"><strong><code>operator=</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult&amp; operator=(
    T&amp;&amp; Value
);
</code></pre>
<details>
<hr />
<p>Replaces internal data with moved value data.</p>
<hr />
<h1 id="arguments-69"><a class="header" href="#arguments-69"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="value-5"><a class="header" href="#value-5"><strong><code>Value</code></strong></a></h2>
<pre><code class="language-cpp">T&amp;&amp; Value
</code></pre>
<p>Value to consume.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="operator-6"><a class="header" href="#operator-6"><strong><code>operator=</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult&amp; operator=(
    const E&amp; Error
);
</code></pre>
<details>
<hr />
<p>Replaces internal data with cloned error data.</p>
<hr />
<h1 id="arguments-70"><a class="header" href="#arguments-70"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="error-4"><a class="header" href="#error-4"><strong><code>Error</code></strong></a></h2>
<pre><code class="language-cpp">const E&amp; Error
</code></pre>
<p>Error to copy from.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="operator-7"><a class="header" href="#operator-7"><strong><code>operator=</code></strong></a></h1>
<pre><code class="language-cpp">public:
TResult&amp; operator=(
    E&amp;&amp; Error
);
</code></pre>
<details>
<hr />
<p>Replaces internal data with cloned error data.</p>
<hr />
<h1 id="arguments-71"><a class="header" href="#arguments-71"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="error-5"><a class="header" href="#error-5"><strong><code>Error</code></strong></a></h2>
<pre><code class="language-cpp">E&amp;&amp; Error
</code></pre>
<p>Error to consume.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="operator-8"><a class="header" href="#operator-8"><strong><code>operator==</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool operator==(
    const TResult&amp; Lhs,
    const TResult&amp; Rhs
);
</code></pre>
<details>
<hr />
<p>Tells if two results are equal.</p>
<p>Two results must both wrap either value or error, and if they do then
their data is compared.</p>
<hr />
<h1 id="arguments-72"><a class="header" href="#arguments-72"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="lhs-1"><a class="header" href="#lhs-1"><strong><code>Lhs</code></strong></a></h2>
<pre><code class="language-cpp">const TResult&amp; Lhs
</code></pre>
</li>
<li>
<h2 id="rhs-1"><a class="header" href="#rhs-1"><strong><code>Rhs</code></strong></a></h2>
<pre><code class="language-cpp">const TResult&amp; Rhs
</code></pre>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-tsenderchannel"><a class="header" href="#struct-tsenderchannel"><strong>Struct: <code>TSenderChannel</code></strong></a></h1>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct TSenderChannel;
</code></pre>
<hr />
<p>SPMC (single-prodicer, multiple-consumer) sender channel.</p>
<p>More in-depth explanation of channels can be found in <a href="reference/structs//Unreal-Systems-Architecture/systems/book/architecture/channels.html">this architecture
book page</a>.</p>
<p>Channels are similar to Unreal events, the difference is while channels
sends data that gets stored immediatelly on receiver queue, user have to
consume received messages by polling (intentionally asking for next message
in queue).</p>
<p>The benefit of polling over pushing (Unreal events) is that user has full
controll over when and where incoming messages are processed and executed,
and that makes user avoid random/undefined data flow which is common pitfall
when using events - with channels we bring determinism into the
communication between parts of the game.</p>
<h1 id="note-39"><a class="header" href="#note-39">Note</a></h1>
<blockquote>
<p>User can freely send messages across multiple separate threads, for
example if user spawn system on another thread to process some big chunk
of data and that system has to send it processing results back to game
thread.</p>
</blockquote>
<blockquote>
<p>User might notice there is method for creating bound receiver, but there
is none fo destroying it - the reason is receivers are weakly connected
so they will automaticall unbound from sender channel as soon as they get
destroyed in their scope, and sender will tr to send any message to that
already gone receiver.</p>
</blockquote>
<h1 id="example-66"><a class="header" href="#example-66">Example</a></h1>
<pre><code class="language-cpp">	auto Sender = TSenderChannel&lt;int&gt;();
	auto Receiver = Sender.Receiver(1);

	Sender.Send(42);
	while (const auto Value = Receiver.Receive())
	{
		UE_LOG(LogTemp, Warning, TEXT(&quot;Received value: %i&quot;), Value);
	}
</code></pre>
<hr />
<h1 id="methods-7"><a class="header" href="#methods-7"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="receiver"><a class="header" href="#receiver"><strong><code>Receiver</code></strong></a></h1>
<pre><code class="language-cpp">public:
TReceiverChannel&lt;T&gt; Receiver(
    uint32 Capacity = 0
);
</code></pre>
<details>
<hr />
<p>Creates receiver channel bound to this sender channel.</p>
<hr />
<h1 id="arguments-73"><a class="header" href="#arguments-73"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="capacity"><a class="header" href="#capacity"><strong><code>Capacity</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Capacity = 0
</code></pre>
<p>Initial capacity of messages queue for created receiver channel.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="receivers"><a class="header" href="#receivers"><strong><code>Receivers</code></strong></a></h1>
<pre><code class="language-cpp">public:
uint32 Receivers() const;
</code></pre>
<details>
<hr />
<p>Returns number of actively bound receivers.</p>
</details>
</li>
<li>
<h1 id="send"><a class="header" href="#send"><strong><code>Send</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Send(
    const T&amp; Data
);
</code></pre>
<details>
<hr />
<p>Sends message to all registered receivers.</p>
<hr />
<h1 id="arguments-74"><a class="header" href="#arguments-74"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="data"><a class="header" href="#data"><strong><code>Data</code></strong></a></h2>
<pre><code class="language-cpp">const T&amp; Data
</code></pre>
<p>Data representation of given message to send.</p>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-ttaggedquery"><a class="header" href="#struct-ttaggedquery"><strong>Struct: <code>TTaggedQuery</code></strong></a></h1>
<pre><code class="language-cpp">template &lt;class... T&gt;
struct TTaggedQuery;
</code></pre>
<hr />
<p>Systems world tagged query iterator.</p>
<p>This is basically an extension to <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html"><strong><code>TQuery</code></strong></a> that allows to ensure
additional components without the need for reading them - useful for tag
components (ones that just mark actors and do not store any data).</p>
<h1 id="note-40"><a class="header" href="#note-40">Note</a></h1>
<blockquote>
<p>User should rather construct queries with
<a href="reference/structs//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#taggedquery"><strong><code>USystemsWorld::TaggedQuery</code></strong></a> instead o constructing queries by
hand.</p>
</blockquote>
<h1 id="example-67"><a class="header" href="#example-67">Example</a></h1>
<pre><code class="language-inject">systems_world_tagged_query
</code></pre>
<hr />
<h1 id="methods-8"><a class="header" href="#methods-8"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="iter-4"><a class="header" href="#iter-4"><strong><code>Iter</code></strong></a></h1>
<pre><code class="language-cpp">public:
TQuery&lt;T...&gt; Iter() const;
</code></pre>
<details>
<hr />
<p>Constructs <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html"><strong><code>TQuery</code></strong></a> from requested actor components and tag
components.</p>
</details>
</li>
<li>
<h1 id="ttaggedquery"><a class="header" href="#ttaggedquery"><strong><code>TTaggedQuery</code></strong></a></h1>
<pre><code class="language-cpp">public:
TTaggedQuery(
    USystemsWorld* InSystems
);
</code></pre>
<details>
<hr />
<p>Constructs tagged query from systems.</p>
<p>An equivalent of calling <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#taggedquery"><strong><code>USystemsWorld::TaggedQuery</code></strong></a></p>
<hr />
<h1 id="arguments-75"><a class="header" href="#arguments-75"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="insystems"><a class="header" href="#insystems"><strong><code>InSystems</code></strong></a></h2>
<pre><code class="language-cpp">USystemsWorld* InSystems
</code></pre>
<p>Pointer to systems world of which actor components user wants to
iterate on.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="with"><a class="header" href="#with"><strong><code>With</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class W&gt;
TTaggedQuery&amp; With();
</code></pre>
<details>
<hr />
<p>Handy wrapper for <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TTaggedQuery.html#withraw"><strong><code>TTaggedQuery::WithRaw</code></strong></a>.</p>
<h1 id="note-41"><a class="header" href="#note-41">Note</a></h1>
<blockquote>
<p>Make sure <code>W</code> inherits from <code>UActorComponent</code>.</p>
</blockquote>
</details>
</li>
<li>
<h1 id="withraw"><a class="header" href="#withraw"><strong><code>WithRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
TTaggedQuery&amp; WithRaw(
    const UClass* Type
);
</code></pre>
<details>
<hr />
<p>Request given component type to exists in queried actor without accesing
its contents.</p>
<h1 id="note-42"><a class="header" href="#note-42">Note</a></h1>
<blockquote>
<p>Make sure <code>Type</code> inherits from <code>UActorComponent</code>.</p>
</blockquote>
<hr />
<h1 id="arguments-76"><a class="header" href="#arguments-76"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="type"><a class="header" href="#type"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">const UClass* Type
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="without"><a class="header" href="#without"><strong><code>Without</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class W&gt;
TTaggedQuery&amp; Without();
</code></pre>
<details>
<hr />
<p>Handy wrapper for <a href="reference/structs//Unreal-Systems-Architecture/systems/reference/structs/TTaggedQuery.html#withoutraw"><strong><code>TTaggedQuery::WithoutRaw</code></strong></a>.</p>
<h1 id="note-43"><a class="header" href="#note-43">Note</a></h1>
<blockquote>
<p>Make sure <code>W</code> inherits from <code>UActorComponent</code>.</p>
</blockquote>
</details>
</li>
<li>
<h1 id="withoutraw"><a class="header" href="#withoutraw"><strong><code>WithoutRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
TTaggedQuery&amp; WithoutRaw(
    const UClass* Type
);
</code></pre>
<details>
<hr />
<p>Request given component type to not exists in queried actors.</p>
<h1 id="note-44"><a class="header" href="#note-44">Note</a></h1>
<blockquote>
<p>Make sure <code>Type</code> inherits from <code>UActorComponent</code>.</p>
</blockquote>
<hr />
<h1 id="arguments-77"><a class="header" href="#arguments-77"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="type-1"><a class="header" href="#type-1"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">const UClass* Type
</code></pre>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-1"><a class="header" href="#classes-1">Classes</a></h1>
<ul>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/ASystemsActor.html"><code>ASystemsActor</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/ASystemsGameMode.html"><code>ASystemsGameMode</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/ASystemsGameState.html"><code>ASystemsGameState</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/ASystemsPawn.html"><code>ASystemsPawn</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/FSystemsReflection.html"><code>FSystemsReflection</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/UDynamicIterator.html"><code>UDynamicIterator</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/UDynamicQuery.html"><code>UDynamicQuery</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/ULambdaSystem.html"><code>ULambdaSystem</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/UScriptableSystem.html"><code>UScriptableSystem</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/USystem.html"><code>USystem</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/USystemsActorComponent.html"><code>USystemsActorComponent</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/USystemsPipeline.html"><code>USystemsPipeline</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/USystemsReflection.html"><code>USystemsReflection</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/USystemsSceneComponent.html"><code>USystemsSceneComponent</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/USystemsStatics.html"><code>USystemsStatics</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/USystemsSubsystem.html"><code>USystemsSubsystem</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/classes/USystemsWorld.html"><code>USystemsWorld</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-asystemsactor"><a class="header" href="#class-asystemsactor"><strong>Class: <code>ASystemsActor</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API ASystemsActor
    : public AActor;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-16"><a class="header" href="#specifiers-16">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
<li><strong>Blueprintable</strong></li>
<li><strong>Abstract</strong></li>
</ul>
<hr />
<p>Base class for systems actors.</p>
<p>Automatically registers this actor components that are not inheriting from
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsActorComponent.html"><strong><code>USystemsActorComponent</code></strong></a> or <a href="reference/classes//reference/classes/USystemsSceneComponent.html"><strong><code>USystemsSceneComponent</code></strong></a>
and have <code>Systems</code> component tag applied to them. This simply allows Systems
World to recognize and query built-in Unreal Engine components without
registering them manually - one less boilerplate to make on user side.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-asystemsgamemode"><a class="header" href="#class-asystemsgamemode"><strong>Class: <code>ASystemsGameMode</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API ASystemsGameMode
    : public AGameModeBase;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Base class for game mode that has to install <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsPipeline.html"><strong><code>USystemsPipeline</code></strong></a>.</p>
<h1 id="note-45"><a class="header" href="#note-45">Note</a></h1>
<blockquote>
<p>Given pipeline will be installed only on server.</p>
</blockquote>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-asystemsgamestate"><a class="header" href="#class-asystemsgamestate"><strong>Class: <code>ASystemsGameState</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API ASystemsGameState
    : public AGameStateBase;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Base class for game state that has to install <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsPipeline.html"><strong><code>USystemsPipeline</code></strong></a>.</p>
<h1 id="note-46"><a class="header" href="#note-46">Note</a></h1>
<blockquote>
<p>Given pipeline will be installed only on client.</p>
</blockquote>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-asystemspawn"><a class="header" href="#class-asystemspawn"><strong>Class: <code>ASystemsPawn</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API ASystemsPawn
    : public APawn;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-17"><a class="header" href="#specifiers-17">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
<li><strong>Blueprintable</strong></li>
<li><strong>Abstract</strong></li>
</ul>
<hr />
<p>Base class for systems actors.</p>
<p>Does exactly the same as <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/ASystemsActor.html"><strong><code>ASystemsActor</code></strong></a> but for Pawns.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-fsystemsreflection"><a class="header" href="#class-fsystemsreflection"><strong>Class: <code>FSystemsReflection</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API FSystemsReflection;
</code></pre>
<hr />
<p>Systems reflection singleton.</p>
<p>Stores application-wide database of named system functions to be used by
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/ULambdaSystem.html"><strong><code>ULambdaSystem</code></strong></a>.</p>
<hr />
<h1 id="methods-9"><a class="header" href="#methods-9"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="findbyname"><a class="header" href="#findbyname"><strong><code>FindByName</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;TFunction&lt;USystemsWorld::LambdaSystemType&gt;&gt; FindByName(
    FName Name
) const;
</code></pre>
<details>
<hr />
<p>Find system function by name.</p>
<hr />
<h1 id="arguments-78"><a class="header" href="#arguments-78"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="name-3"><a class="header" href="#name-3"><strong><code>Name</code></strong></a></h2>
<pre><code class="language-cpp">FName Name
</code></pre>
<p>Unique name for given system function.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="getnames"><a class="header" href="#getnames"><strong><code>GetNames</code></strong></a></h1>
<pre><code class="language-cpp">public:
void GetNames(
    TArray&lt;FString&gt;&amp; Result
) const;
</code></pre>
<details>
<hr />
<p>Gets list of system function names.</p>
<hr />
<h1 id="arguments-79"><a class="header" href="#arguments-79"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="result-3"><a class="header" href="#result-3"><strong><code>Result</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FString&gt;&amp; Result
</code></pre>
<p>Output array to receive names.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="register"><a class="header" href="#register"><strong><code>Register</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Register(
    FName Name,
    TFunction&lt;USystemsWorld::LambdaSystemType&gt; Callback
);
</code></pre>
<details>
<hr />
<p>Register or overwrite system function under given name.</p>
<hr />
<h1 id="arguments-80"><a class="header" href="#arguments-80"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="name-4"><a class="header" href="#name-4"><strong><code>Name</code></strong></a></h2>
<pre><code class="language-cpp">FName Name
</code></pre>
<p>Unique name for given system function.</p>
</li>
<li>
<h2 id="callback"><a class="header" href="#callback"><strong><code>Callback</code></strong></a></h2>
<pre><code class="language-cpp">TFunction&lt;USystemsWorld::LambdaSystemType&gt; Callback
</code></pre>
<p>Reference to system function.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="unregister"><a class="header" href="#unregister"><strong><code>Unregister</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Unregister(
    FName Name
);
</code></pre>
<details>
<hr />
<p>Unregister system function under given name.</p>
<hr />
<h1 id="arguments-81"><a class="header" href="#arguments-81"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="name-5"><a class="header" href="#name-5"><strong><code>Name</code></strong></a></h2>
<pre><code class="language-cpp">FName Name
</code></pre>
<p>Unique name for given system function.</p>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-udynamiciterator"><a class="header" href="#class-udynamiciterator"><strong>Class: <code>UDynamicIterator</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API UDynamicIterator
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-18"><a class="header" href="#specifiers-18">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<hr />
<h1 id="methods-10"><a class="header" href="#methods-10"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="estimatesizeleft"><a class="header" href="#estimatesizeleft"><strong><code>EstimateSizeLeft</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual int EstimateSizeLeft() const;
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-19"><a class="header" href="#specifiers-19">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<h3 id="meta-specifiers"><a class="header" href="#meta-specifiers">Meta Specifiers:</a></h3>
<ul>
<li><strong>DevelopmentOnly</strong></li>
</ul>
<hr />
<p>Calculates (usually minimal) number of items this iterator stage can yield.</p>
</details>
</li>
<li>
<h1 id="next-2"><a class="header" href="#next-2"><strong><code>Next</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual UObject* Next();
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-20"><a class="header" href="#specifiers-20">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<h3 id="meta-specifiers-1"><a class="header" href="#meta-specifiers-1">Meta Specifiers:</a></h3>
<ul>
<li><strong>DevelopmentOnly</strong></li>
</ul>
<hr />
<p>Performs iteration and returns yielded value.</p>
<p>Null means no object left to iterate.</p>
</details>
</li>
<li>
<h1 id="nextbranched"><a class="header" href="#nextbranched"><strong><code>NextBranched</code></strong></a></h1>
<pre><code class="language-cpp">public:
UObject* NextBranched(
    EDynamicIteratorNextBranch&amp; Branches
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-21"><a class="header" href="#specifiers-21">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<h3 id="meta-specifiers-2"><a class="header" href="#meta-specifiers-2">Meta Specifiers:</a></h3>
<ul>
<li><strong>ExpandEnumAsExecs</strong> = <em>Branches</em></li>
<li><strong>DevelopmentOnly</strong></li>
</ul>
<hr />
<p>Handy wrapper for <strong><code>Self::Next</code></strong> for use in blueprints, where iteration can branch to <code>yielded</code> and
<code>completed</code> execution nodes.</p>
<hr />
<h1 id="arguments-82"><a class="header" href="#arguments-82"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="branches"><a class="header" href="#branches"><strong><code>Branches</code></strong></a></h2>
<pre><code class="language-cpp">EDynamicIteratorNextBranch&amp; Branches
</code></pre>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-udynamicquery"><a class="header" href="#class-udynamicquery"><strong>Class: <code>UDynamicQuery</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API UDynamicQuery
    : public UDynamicIterator;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-22"><a class="header" href="#specifiers-22">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Dynamic query useful for performing system world queries in blueprints.</p>
<p>One of the goals of Systems Architecture is to provide game designers with
means to prototype systems without need for programmers. Dynamic query is a
way of performing systems world queries in blueprints. Although blueprint
API doesn't have same ergonomics as C++ API because of the lack of lazy
iterators on blueprints side, technical game designers still might benefit
from quickly testing simple systems without involving programmers into the
process and being able to quickly test the idea - it makes failing quicker
than it would without technical game designers getting their hands dirty
once in a while, which is beneficial to the whole production process in long
term.</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#spawnquery"><strong><code>USystemsWorld::SpawnQuery</code></strong></a>.</p>
<h1 id="example-68"><a class="header" href="#example-68">Example</a></h1>
<pre><code class="language-cpp">	UCLASS(BlueprintType)
	class EXAMPLE_API UShiaQueryBundle
	{
		GENERATED_BODY()

	public:
		UPROPERTY(BlueprintReadOnly)
		AActor* Actor = nullptr;

		UPROPERTY(BlueprintReadOnly)
		UShiaComponent* Shia = nullptr;
	};

	auto Query = Systems.DynamicQuery&lt;UShiaQueryBundle&gt;();
	auto* Bundle = NewObject&lt;UShiaQueryBundle&gt;(this, UShiaQueryBundle::StaticClass());
	while (Query-&gt;Next(Bundle))
	{
		Bundle-&gt;Shia-&gt;JustDoIt(Bundle-&gt;Actor);
	}
</code></pre>
<hr />
<h1 id="methods-11"><a class="header" href="#methods-11"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="estimatesizeleft-1"><a class="header" href="#estimatesizeleft-1"><strong><code>EstimateSizeLeft</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual int EstimateSizeLeft() const override;
</code></pre>
<details>
<hr />
<p>Calculates maximum number of items this query can yield.</p>
</details>
</li>
<li>
<h1 id="next-3"><a class="header" href="#next-3"><strong><code>Next</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual UObject* Next() override;
</code></pre>
<details>
<hr />
<p>Performs iteration and stores yielded values in returned object.</p>
<h1 id="note-47"><a class="header" href="#note-47">Note</a></h1>
<blockquote>
<p>This method uses reflection to figure out properties that gonna store
yielded actor and components in returned object.</p>
</blockquote>
</details>
</li>
<li>
<h1 id="setup"><a class="header" href="#setup"><strong><code>Setup</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Setup(
    USystemsWorld* Systems,
    const UClass* Type
);
</code></pre>
<details>
<hr />
<p>Resets internal iterator to state for interating current state of
systems world.</p>
<hr />
<h1 id="arguments-83"><a class="header" href="#arguments-83"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="systems-4"><a class="header" href="#systems-4"><strong><code>Systems</code></strong></a></h2>
<pre><code class="language-cpp">USystemsWorld* Systems
</code></pre>
<p>Pointer to systems world to iterate on.</p>
</li>
<li>
<h2 id="type-2"><a class="header" href="#type-2"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">const UClass* Type
</code></pre>
<p>Class of object that contains fields where yielded actor and
components are gonna be stored.</p>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ulambdasystem"><a class="header" href="#class-ulambdasystem"><strong>Class: <code>ULambdaSystem</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API ULambdaSystem
    : public USystem;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-23"><a class="header" href="#specifiers-23">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>Handy wrapper for state-less systems (functions or lambdas).</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystem.html"><strong><code>USystem</code></strong></a></p>
<h1 id="example-69"><a class="header" href="#example-69">Example</a></h1>
<pre><code class="language-cpp">UFUNCTION()
void BoidsFaceDirectionSystem(USystemsWorld&amp; Systems);

void BoidsFaceDirectionSystem(USystemsWorld&amp; Systems)
{
	Systems.Query&lt;UVelocityComponent, UBoidComponent&gt;().ForEach(
		[&amp;](auto&amp; QueryItem)
		{
			auto* Actor = QueryItem.Get&lt;0&gt;();
			const auto* Velocity = QueryItem.Get&lt;1&gt;();

			if (Velocity-&gt;Value.IsNearlyZero() == false)
			{
				Actor-&gt;SetActorRotation(Velocity-&gt;Value.Rotation());
			}
		});
}
</code></pre>
<pre><code class="language-cpp">Systems.InstallLambdaSystem(BoidsFaceDirectionSystem, FInstallSystemOptions(&quot;BoidsFaceDirection&quot;));
</code></pre>
<hr />
<h1 id="methods-12"><a class="header" href="#methods-12"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="bind"><a class="header" href="#bind"><strong><code>Bind</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Bind(
    TFunction&lt;FunctorType&gt;&amp;&amp; Func
);
</code></pre>
<details>
<hr />
<p>Binds given function/lambda that runs some system logic.</p>
<p>Method called by <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#installlambdasystem"><strong><code>USystemsWorld::InstallLambdaSystem</code></strong></a></p>
<hr />
<h1 id="arguments-84"><a class="header" href="#arguments-84"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-22"><a class="header" href="#func-22"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">TFunction&lt;FunctorType&gt;&amp;&amp; Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="unbind-1"><a class="header" href="#unbind-1"><strong><code>Unbind</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Unbind();
</code></pre>
<details>
<hr />
<p>Unbinds stored function/lambda that runs some system logic.</p>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-uscriptablesystem"><a class="header" href="#class-uscriptablesystem"><strong>Class: <code>UScriptableSystem</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API UScriptableSystem
    : public USystem;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-24"><a class="header" href="#specifiers-24">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>Variant of system that works with blueprints.</p>
<p>User can override OnInit method for system initialization, as well as
OnRun for performing system logic.</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystem.html"><strong><code>USystem</code></strong></a></p>
<hr />
<h1 id="methods-13"><a class="header" href="#methods-13"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="oninit"><a class="header" href="#oninit"><strong><code>OnInit</code></strong></a></h1>
<pre><code class="language-cpp">public:
void OnInit(
    USystemsWorld* Systems
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-25"><a class="header" href="#specifiers-25">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintNativeEvent</strong></li>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<h3 id="meta-specifiers-3"><a class="header" href="#meta-specifiers-3">Meta Specifiers:</a></h3>
<ul>
<li><strong>DevelopmentOnly</strong></li>
</ul>
<hr />
<p>Override to initialize system (setup its internal state).</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystem.html#init"><strong><code>USystem::Init</code></strong></a></p>
<hr />
<h1 id="arguments-85"><a class="header" href="#arguments-85"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="systems-5"><a class="header" href="#systems-5"><strong><code>Systems</code></strong></a></h2>
<pre><code class="language-cpp">USystemsWorld* Systems
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="onrun"><a class="header" href="#onrun"><strong><code>OnRun</code></strong></a></h1>
<pre><code class="language-cpp">public:
void OnRun(
    USystemsWorld* Systems,
    float DeltaSeconds
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-26"><a class="header" href="#specifiers-26">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintNativeEvent</strong></li>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<h3 id="meta-specifiers-4"><a class="header" href="#meta-specifiers-4">Meta Specifiers:</a></h3>
<ul>
<li><strong>DevelopmentOnly</strong></li>
</ul>
<hr />
<p>Override to run system work logic (perform queries on world components
and resources).</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystem.html#run"><strong><code>USystem::Run</code></strong></a></p>
<hr />
<h1 id="arguments-86"><a class="header" href="#arguments-86"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="systems-6"><a class="header" href="#systems-6"><strong><code>Systems</code></strong></a></h2>
<pre><code class="language-cpp">USystemsWorld* Systems
</code></pre>
</li>
<li>
<h2 id="deltaseconds"><a class="header" href="#deltaseconds"><strong><code>DeltaSeconds</code></strong></a></h2>
<pre><code class="language-cpp">float DeltaSeconds
</code></pre>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-usystem"><a class="header" href="#class-usystem"><strong>Class: <code>USystem</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API USystem
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-27"><a class="header" href="#specifiers-27">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>EditInlineNew</strong></li>
</ul>
<hr />
<p>Base class for unit of work over some data.</p>
<p><a href="reference/classes//Unreal-Systems-Architecture/systems/book/architecture/systems.html">Architecture book page</a> explains more in
depth systems.</p>
<p>System's job is to process data. Usually it involves performing queries
over game world and/or resources.</p>
<p>This is only one of few ways of system representation, used mostly in case
your system has to cache some internal state or has to perform some logic
on system initialization phase, which is not possible in case of for example
lambda systems.</p>
<h1 id="example-70"><a class="header" href="#example-70">Example</a></h1>
<pre><code class="language-cpp">UCLASS()
class EXAMPLE_API ULogBirdsNumberChangeSystem : public USystem
{
	GENERATED_BODY()

public:
	virtual void Run(USystemsWorld&amp; Systems) override;

	UPROPERTY()
	uint32 LastCount = 0;
};

void ULogBirdsNumberChangeSystem::Run(USystemsWorld&amp; Systems)
{
	Super::Run(Systems);

	if (Systems.ComponentsDidChanged&lt;UBirdComponent&gt;() == false)
	{
		return;
	}

	const auto Number = static_cast&lt;int&gt;(Systems.Query&lt;UBirdComponent&gt;().Count());
	const Difference = Number - this-&gt;LastCount;
	this-&gt;LastCount = Number;

	if (Difference &gt; 0)
	{
		UE_LOG(LogTemp, Warning, TEXT(&quot;Added %i birds&quot;), Difference);
	}
	else if (Difference &lt; 0)
	{
		UE_LOG(LogTemp, Warning, TEXT(&quot;Removed %i birds&quot;), -Difference);
	}
}
</code></pre>
<hr />
<h1 id="methods-14"><a class="header" href="#methods-14"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="init"><a class="header" href="#init"><strong><code>Init</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual void Init(
    USystemsWorld&amp; Systems
);
</code></pre>
<details>
<hr />
<p>Override to initialize system (setup its internal state).</p>
<p>This method is called by <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#sealandinitialize"><strong><code>USystemsWorld::SealAndInitialize</code></strong></a>,
right after systems world is setup and sealed by the user.</p>
<p>Here user can perform initialization of this system internal state, or
do something useful with systems world (for example initialize some
resources). At this stage systems world does not yet have registered any
of world components so any query will yield no results.</p>
<h1 id="example-71"><a class="header" href="#example-71">Example</a></h1>
<pre><code class="language-cpp">UCLASS()
class BOIDS_API UBoidsMovementSystem : public USystem
{
	GENERATED_BODY()

public:
	virtual void Init(USystemsWorld&amp; Systems) override;

private:
	TReceiverChannel&lt;FMovementStep&gt; MovementStep = {};
};

void UBoidsMovementSystem::Init(USystemsWorld&amp; Systems)
{
	Super::Init(Systems);

	auto* GameEvents = Systems.Resource&lt;UGameEvents&gt;();
	if (IsValid(GameEvents))
	{
		this-&gt;MovementStep = GameEvents-&gt;MovementStep.Receiver(1);
	}
}
</code></pre>
<hr />
<h1 id="arguments-87"><a class="header" href="#arguments-87"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="systems-7"><a class="header" href="#systems-7"><strong><code>Systems</code></strong></a></h2>
<pre><code class="language-cpp">USystemsWorld&amp; Systems
</code></pre>
<p>Reference to systems world that triggers this system initialization.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="run"><a class="header" href="#run"><strong><code>Run</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual void Run(
    USystemsWorld&amp; Systems
);
</code></pre>
<details>
<hr />
<p>Override to run system work logic (perform queries on world components
and resources).</p>
<p>This method is called by <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#process"><strong><code>USystemsWorld::Process</code></strong></a>.</p>
<p>Here user can perform system logic, usually performs single task such as
apply velocity accumulated by other systems on actor location, or
perform actors AI tasks, or kill actors that has 0 or less health -
whatever work you want to do make sure it's not monolithic, rather make
it small, like don't do multiple things at once - always divide work to
small data processing work units. Split bigger tasks between multiple
systems and use components/resources/channels to share data between
systems.</p>
<h1 id="example-72"><a class="header" href="#example-72">Example</a></h1>
<pre><code class="language-cpp">UCLASS()
class BOIDS_API UBoidsMovementSystem : public USystem
{
	GENERATED_BODY()

public:
	virtual void Run(USystemsWorld&amp; Systems) override;
};

void UBoidsMovementSystem::Run(USystemsWorld&amp; Systems)
{
	Super::Run(Systems);

	const auto* BoidsSettings = Systems.Resource&lt;UBoidsSettings&gt;();
	if (IsValid(BoidsSettings) == false)
	{
		return;
	}
	const auto TimeScale = BoidsSettings-&gt;TimeScale;
	const auto DeltaTime = Systems.GetWorld()-&gt;GetDeltaSeconds() * TimeScale;

	Systems.Query&lt;UVelocityComponent, UBoidComponent&gt;().ForEach(
		[&amp;](auto&amp; QueryItem)
		{
			auto* Actor = QueryItem.Get&lt;0&gt;();
			const auto* Velocity = QueryItem.Get&lt;1&gt;();
			const auto Position = Actor-&gt;GetActorLocation();

			Actor-&gt;SetActorLocation(Position + Velocity-&gt;Value * DeltaTime);
		});
}
</code></pre>
<hr />
<h1 id="arguments-88"><a class="header" href="#arguments-88"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="systems-8"><a class="header" href="#systems-8"><strong><code>Systems</code></strong></a></h2>
<pre><code class="language-cpp">USystemsWorld&amp; Systems
</code></pre>
<p>Reference to systems world that triggers this system run.</p>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-usystemsactorcomponent"><a class="header" href="#class-usystemsactorcomponent"><strong>Class: <code>USystemsActorComponent</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API USystemsActorComponent
    : public UActorComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-28"><a class="header" href="#specifiers-28">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
<li><strong>Blueprintable</strong></li>
<li><strong>Abstract</strong></li>
</ul>
<h3 id="meta-specifiers-5"><a class="header" href="#meta-specifiers-5">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
</ul>
<hr />
<p>Base class for systems actor components.</p>
<p><a href="reference/classes//Unreal-Systems-Architecture/systems/book/architecture/components.html">Architecture book page</a> explains more in
depth actor components relation with systems world but in a brief: they are
data stored in game world actors. You should inherit from this class any new
component class that should get automatically registered to and unregistered
from globally accessible systems worlds in <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsSubsystem.html"><strong><code>USystemsSubsystem</code></strong></a>
and then can be queried using <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#query"><strong><code>USystemsWorld::Query</code></strong></a>. You can of
course not inherit components from this class and manually register or
unregister this component at will to any systems world if you want to make
it available from custom or just non-globally accessible systems world, this
class is useful only for automation of registering/unregistering components.</p>
<hr />
<h1 id="properties-5"><a class="header" href="#properties-5"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="systemsworlds"><a class="header" href="#systemsworlds"><strong><code>SystemsWorlds</code></strong></a></h1>
<pre><code class="language-cpp">public:
TSet&lt;FName&gt; SystemsWorlds;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-29"><a class="header" href="#specifiers-29">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Systems|Component|Actor</em></li>
</ul>
<hr />
<p>List of subsystem's systems worlds where this component should be
registered.</p>
<p>If list is empty, it means this component will be added to every
registered systems world.</p>
</li>
</ul>
<hr />
<h1 id="methods-15"><a class="header" href="#methods-15"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="canberegisteredtosystemsworld"><a class="header" href="#canberegisteredtosystemsworld"><strong><code>CanBeRegisteredToSystemsWorld</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual bool CanBeRegisteredToSystemsWorld() const;
</code></pre>
<details>
<hr />
<p>Tells if given component can be automatically registered into systems
worlds.</p>
<p>Useful to override when component has to meet certain conditions to get
considered for automatic registration, conditions such as for example
being owned by server game instance, or actor being a pawn.</p>
<p>By default this method always returns <code>true</code>.</p>
</details>
</li>
<li>
<h1 id="isregistered"><a class="header" href="#isregistered"><strong><code>IsRegistered</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool IsRegistered() const;
</code></pre>
<details>
<hr />
<p>Tells if this component is registered to subsystem's systems world.</p>
</details>
</li>
<li>
<h1 id="setregistered"><a class="header" href="#setregistered"><strong><code>SetRegistered</code></strong></a></h1>
<pre><code class="language-cpp">public:
void SetRegistered(
    bool bMode,
    bool bForced = false
);
</code></pre>
<details>
<hr />
<p>Registers this component to subsystem's systems worlds listed in
<strong><code>Self::SystemsWorlds</code></strong>.</p>
<hr />
<h1 id="arguments-89"><a class="header" href="#arguments-89"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="bmode"><a class="header" href="#bmode"><strong><code>bMode</code></strong></a></h2>
<pre><code class="language-cpp">bool bMode
</code></pre>
<p>If true, component gets registered, otherwise it gets unregistered.</p>
</li>
<li>
<h2 id="bforced"><a class="header" href="#bforced"><strong><code>bForced</code></strong></a></h2>
<pre><code class="language-cpp">bool bForced = false
</code></pre>
<p>Forces registration change.</p>
<h1 id="note-48"><a class="header" href="#note-48">Note</a></h1>
<blockquote>
<p>Be careful, when <code>bMode</code> is true, this will not unregister this
component from systems worlds where this component is already
registered - this is useful mainly when get called in
<code>UActorComponent::BeginPlay</code> to enforce initial registration when
internal <code>bRegister</code> gets set to true in editor.</p>
</blockquote>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-usystemspipeline"><a class="header" href="#class-usystemspipeline"><strong>Class: <code>USystemsPipeline</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API USystemsPipeline
    : public UDataAsset;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-30"><a class="header" href="#specifiers-30">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Data asset used to describe Systems pipeline.</p>
<hr />
<h1 id="properties-6"><a class="header" href="#properties-6"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="assetresourcestoinstall"><a class="header" href="#assetresourcestoinstall"><strong><code>AssetResourcesToInstall</code></strong></a></h1>
<pre><code class="language-cpp">public:
TMap&lt;TObjectPtr&lt;UDataAsset&gt;, FSystemsPipelineResource&gt; AssetResourcesToInstall;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-31"><a class="header" href="#specifiers-31">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Resources|Assets</em></li>
</ul>
<hr />
<p>Asset resources to be registered into systems world.</p>
<p>Usually these are used as settings/config data sources.</p>
</li>
<li>
<h1 id="cleanupsystemstorun"><a class="header" href="#cleanupsystemstorun"><strong><code>CleanupSystemsToRun</code></strong></a></h1>
<pre><code class="language-cpp">public:
TArray&lt;FSystemsPipelineSystem&gt; CleanupSystemsToRun;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-32"><a class="header" href="#specifiers-32">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Systems|Cleanup</em></li>
</ul>
<hr />
<p>System templates to instantiate and run on systems world destruction.</p>
<p>Order in the list represents order of execution.</p>
</li>
<li>
<h1 id="componentstoregister"><a class="header" href="#componentstoregister"><strong><code>ComponentsToRegister</code></strong></a></h1>
<pre><code class="language-cpp">public:
TMap&lt;TSubclassOf&lt;UActorComponent&gt;, FSystemsPipelineComponent&gt; ComponentsToRegister;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-33"><a class="header" href="#specifiers-33">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Components|Types</em></li>
</ul>
<hr />
<p>Typed components to be registered into systems world.</p>
</li>
<li>
<h1 id="persistentsystemstoinstall"><a class="header" href="#persistentsystemstoinstall"><strong><code>PersistentSystemsToInstall</code></strong></a></h1>
<pre><code class="language-cpp">public:
TArray&lt;FSystemsPipelineSystem&gt; PersistentSystemsToInstall;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-34"><a class="header" href="#specifiers-34">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Systems|Persistent</em></li>
</ul>
<hr />
<p>System templates to instantiate and register into systems world to run
every tick.</p>
<p>Order in the list represents order of execution.</p>
</li>
<li>
<h1 id="startupsystemstorun"><a class="header" href="#startupsystemstorun"><strong><code>StartupSystemsToRun</code></strong></a></h1>
<pre><code class="language-cpp">public:
TArray&lt;FSystemsPipelineSystem&gt; StartupSystemsToRun;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-35"><a class="header" href="#specifiers-35">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Systems|Startup</em></li>
</ul>
<hr />
<p>System templates to instantiate and run on systems world creation.</p>
<p>Order in the list represents order of execution.</p>
</li>
<li>
<h1 id="typeresourcestoinstall"><a class="header" href="#typeresourcestoinstall"><strong><code>TypeResourcesToInstall</code></strong></a></h1>
<pre><code class="language-cpp">public:
TMap&lt;TSubclassOf&lt;UObject&gt;, FSystemsPipelineResource&gt; TypeResourcesToInstall;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-36"><a class="header" href="#specifiers-36">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Resources|Types</em></li>
</ul>
<hr />
<p>Typed resources to be registered into systems world.</p>
<p>Usually these are used as game managers.</p>
</li>
</ul>
<hr />
<h1 id="methods-16"><a class="header" href="#methods-16"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="install"><a class="header" href="#install"><strong><code>Install</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Install(
    UWorld* World
) const;
</code></pre>
<details>
<hr />
<p>Creates new global systems world under <strong><code>Self::WorldId</code></strong> name and
installs this pipeline content into that systems world.</p>
<hr />
<h1 id="arguments-90"><a class="header" href="#arguments-90"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="world-1"><a class="header" href="#world-1"><strong><code>World</code></strong></a></h2>
<pre><code class="language-cpp">UWorld* World
</code></pre>
<p>World that has running <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsSubsystem.html"><strong><code>USystemsSubsystem</code></strong></a>.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="uninstall"><a class="header" href="#uninstall"><strong><code>Uninstall</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Uninstall(
    UWorld* World
) const;
</code></pre>
<details>
<hr />
<p>Destroys systems world registered under <strong><code>Self::WorldId</code></strong> name.</p>
<hr />
<h1 id="arguments-91"><a class="header" href="#arguments-91"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="world-2"><a class="header" href="#world-2"><strong><code>World</code></strong></a></h2>
<pre><code class="language-cpp">UWorld* World
</code></pre>
<p>World that has running <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsSubsystem.html"><strong><code>USystemsSubsystem</code></strong></a>.</p>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-usystemsreflection"><a class="header" href="#class-usystemsreflection"><strong>Class: <code>USystemsReflection</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API USystemsReflection
    : public UBlueprintFunctionLibrary;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Systems reflection blueprint library.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-usystemsscenecomponent"><a class="header" href="#class-usystemsscenecomponent"><strong>Class: <code>USystemsSceneComponent</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API USystemsSceneComponent
    : public USceneComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-37"><a class="header" href="#specifiers-37">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
<li><strong>Blueprintable</strong></li>
<li><strong>Abstract</strong></li>
</ul>
<h3 id="meta-specifiers-6"><a class="header" href="#meta-specifiers-6">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
</ul>
<hr />
<p>Base class for systems scene components.</p>
<p>This is scene component equivalent to <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsActorComponent.html"><strong><code>USystemsActorComponent</code></strong></a> -
scene componets are useful where given component should have transformation
relative to actor.</p>
<hr />
<h1 id="properties-7"><a class="header" href="#properties-7"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="systemsworlds-1"><a class="header" href="#systemsworlds-1"><strong><code>SystemsWorlds</code></strong></a></h1>
<pre><code class="language-cpp">public:
TSet&lt;FName&gt; SystemsWorlds;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-38"><a class="header" href="#specifiers-38">Specifiers:</a></h3>
<ul>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Systems|Component|Scene</em></li>
</ul>
<hr />
<p>List of subsystem's systems worlds where this component should be
registered.</p>
<p>If list is empty, it means this component will be added to every
registered systems world.</p>
</li>
</ul>
<hr />
<h1 id="methods-17"><a class="header" href="#methods-17"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="canberegisteredtosystemsworld-1"><a class="header" href="#canberegisteredtosystemsworld-1"><strong><code>CanBeRegisteredToSystemsWorld</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual bool CanBeRegisteredToSystemsWorld() const;
</code></pre>
<details>
<hr />
<p>Tells if given component can be automatically registered into systems
worlds.</p>
<p>Useful to override when component has to meet certain conditions to get
considered for automatic registration, conditions such as for example
being owned by server game instance, or actor being a pawn.</p>
<p>By default this method always returns <code>true</code>.</p>
</details>
</li>
<li>
<h1 id="isregistered-1"><a class="header" href="#isregistered-1"><strong><code>IsRegistered</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool IsRegistered() const;
</code></pre>
<details>
<hr />
<p>Tells if this component is registered to subsystem's systems world.</p>
</details>
</li>
<li>
<h1 id="setregistered-1"><a class="header" href="#setregistered-1"><strong><code>SetRegistered</code></strong></a></h1>
<pre><code class="language-cpp">public:
void SetRegistered(
    bool bMode,
    bool bForced = false
);
</code></pre>
<details>
<hr />
<p>Registers this component to subsystem's systems worlds listed in
<strong><code>Self::SystemsWorlds</code></strong>.</p>
<hr />
<h1 id="arguments-92"><a class="header" href="#arguments-92"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="bmode-1"><a class="header" href="#bmode-1"><strong><code>bMode</code></strong></a></h2>
<pre><code class="language-cpp">bool bMode
</code></pre>
<p>If true, component gets registered, otherwise it gets unregistered.</p>
</li>
<li>
<h2 id="bforced-1"><a class="header" href="#bforced-1"><strong><code>bForced</code></strong></a></h2>
<pre><code class="language-cpp">bool bForced = false
</code></pre>
<p>Forces registration change.</p>
<h1 id="note-49"><a class="header" href="#note-49">Note</a></h1>
<blockquote>
<p>Be careful, when <code>bMode</code> is true, this will not unregister this
component from systems worlds where this component is already
registered - this is useful mainly when get called in
<code>UActorComponent::BeginPlay</code> to enforce initial registration when
internal <code>bRegister</code> gets set to true in editor.</p>
</blockquote>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-usystemsstatics"><a class="header" href="#class-usystemsstatics"><strong>Class: <code>USystemsStatics</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API USystemsStatics
    : public UBlueprintFunctionLibrary;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Library of useful boilerplate-wrapping functions related to systems
components.</p>
<hr />
<h1 id="methods-18"><a class="header" href="#methods-18"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="addcomponent"><a class="header" href="#addcomponent"><strong><code>AddComponent</code></strong></a></h1>
<pre><code class="language-cpp">public:
static void AddComponent(
    UActorComponent* Component,
    const TSet&lt;FName&gt;&amp; SystemsWorlds,
    UObject* WorldContext
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-39"><a class="header" href="#specifiers-39">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems|Components</em></li>
</ul>
<h3 id="meta-specifiers-7"><a class="header" href="#meta-specifiers-7">Meta Specifiers:</a></h3>
<ul>
<li><strong>WorldContext</strong> = <em>WorldContext</em></li>
<li><strong>UnsafeDuringActorConstruction</strong> = <em>true</em></li>
</ul>
<hr />
<p>Tries to add component to specified global systems worlds.</p>
<p>Useful when creating proxy components that inherits from engine
components to make them auto added to global systems worlds on
<code>BeginPlay</code>.</p>
<hr />
<h1 id="arguments-93"><a class="header" href="#arguments-93"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="component"><a class="header" href="#component"><strong><code>Component</code></strong></a></h2>
<pre><code class="language-cpp">UActorComponent* Component
</code></pre>
<p>Actor component to add to global systems world.</p>
</li>
<li>
<h2 id="systemsworlds-2"><a class="header" href="#systemsworlds-2"><strong><code>SystemsWorlds</code></strong></a></h2>
<pre><code class="language-cpp">const TSet&lt;FName&gt;&amp; SystemsWorlds
</code></pre>
<p>List of global systems worlds given component should be registered
into.</p>
</li>
<li>
<h2 id="worldcontext"><a class="header" href="#worldcontext"><strong><code>WorldContext</code></strong></a></h2>
<pre><code class="language-cpp">UObject* WorldContext
</code></pre>
<p>World context object.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="addcomponenteverywhere"><a class="header" href="#addcomponenteverywhere"><strong><code>AddComponentEverywhere</code></strong></a></h1>
<pre><code class="language-cpp">public:
static void AddComponentEverywhere(
    UActorComponent* Component,
    UObject* WorldContext
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-40"><a class="header" href="#specifiers-40">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems|Components</em></li>
</ul>
<h3 id="meta-specifiers-8"><a class="header" href="#meta-specifiers-8">Meta Specifiers:</a></h3>
<ul>
<li><strong>WorldContext</strong> = <em>WorldContext</em></li>
<li><strong>UnsafeDuringActorConstruction</strong> = <em>true</em></li>
</ul>
<hr />
<p>Tries to add component to every global systems worlds.</p>
<p>Useful when creating proxy components that inherits from engine
components to make them auto added to global systems worlds on
<code>BeginPlay</code>.</p>
<hr />
<h1 id="arguments-94"><a class="header" href="#arguments-94"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="component-1"><a class="header" href="#component-1"><strong><code>Component</code></strong></a></h2>
<pre><code class="language-cpp">UActorComponent* Component
</code></pre>
<p>Actor component to add to global systems world.</p>
</li>
<li>
<h2 id="worldcontext-1"><a class="header" href="#worldcontext-1"><strong><code>WorldContext</code></strong></a></h2>
<pre><code class="language-cpp">UObject* WorldContext
</code></pre>
<p>World context object.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="getcomponentraw"><a class="header" href="#getcomponentraw"><strong><code>GetComponentRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
static UActorComponent* GetComponentRaw(
    FName Id,
    AActor* Actor,
    const TSubclassOf&lt;UActorComponent&gt;&amp; Type,
    UObject* WorldContext
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-41"><a class="header" href="#specifiers-41">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintPure</strong></li>
<li><strong>Category</strong> = <em>Systems|Components</em></li>
</ul>
<h3 id="meta-specifiers-9"><a class="header" href="#meta-specifiers-9">Meta Specifiers:</a></h3>
<ul>
<li><strong>WorldContext</strong> = <em>WorldContext</em></li>
<li><strong>UnsafeDuringActorConstruction</strong> = <em>true</em></li>
<li><strong>DisplayName</strong> = <em>Get Component</em></li>
<li><strong>DeterminesOutputType</strong> = <em>Type</em></li>
</ul>
<hr />
<p>Gets actor component from globally registered systems world by its label.</p>
<p>This is a handy shortcut for <strong><code>Self::GetSystemsWorld</code></strong> and then
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#componentraw"><strong><code>USystemsWorld::ComponentRaw</code></strong></a> on it.</p>
<hr />
<h1 id="arguments-95"><a class="header" href="#arguments-95"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="id"><a class="header" href="#id"><strong><code>Id</code></strong></a></h2>
<pre><code class="language-cpp">FName Id
</code></pre>
<p>Systems world ID.</p>
</li>
<li>
<h2 id="actor"><a class="header" href="#actor"><strong><code>Actor</code></strong></a></h2>
<pre><code class="language-cpp">AActor* Actor
</code></pre>
<p>Actor to search in.</p>
</li>
<li>
<h2 id="type-3"><a class="header" href="#type-3"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">const TSubclassOf&lt;UActorComponent&gt;&amp; Type
</code></pre>
<p>Type of component to search for.</p>
</li>
<li>
<h2 id="worldcontext-2"><a class="header" href="#worldcontext-2"><strong><code>WorldContext</code></strong></a></h2>
<pre><code class="language-cpp">UObject* WorldContext
</code></pre>
<p>World context object.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="getresource"><a class="header" href="#getresource"><strong><code>GetResource</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class T&gt;
static T* GetResource(
    FName Id,
    UObject* WorldContext
);
</code></pre>
<details>
<hr />
<p>Gets resource from globally registered systems world by its label.</p>
<p>This is a handy template shortcut for <strong><code>Self::ResourceRaw</code></strong>.</p>
<hr />
<h1 id="arguments-96"><a class="header" href="#arguments-96"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="id-1"><a class="header" href="#id-1"><strong><code>Id</code></strong></a></h2>
<pre><code class="language-cpp">FName Id
</code></pre>
<p>Systems world ID.</p>
</li>
<li>
<h2 id="worldcontext-3"><a class="header" href="#worldcontext-3"><strong><code>WorldContext</code></strong></a></h2>
<pre><code class="language-cpp">UObject* WorldContext
</code></pre>
<p>World context object.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="getresourceraw"><a class="header" href="#getresourceraw"><strong><code>GetResourceRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
static UObject* GetResourceRaw(
    FName Id,
    const UClass* Type,
    UObject* WorldContext
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-42"><a class="header" href="#specifiers-42">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintPure</strong></li>
<li><strong>Category</strong> = <em>Systems|Resources</em></li>
</ul>
<h3 id="meta-specifiers-10"><a class="header" href="#meta-specifiers-10">Meta Specifiers:</a></h3>
<ul>
<li><strong>WorldContext</strong> = <em>WorldContext</em></li>
<li><strong>UnsafeDuringActorConstruction</strong> = <em>true</em></li>
<li><strong>DisplayName</strong> = <em>Get Resource</em></li>
<li><strong>DeterminesOutputType</strong> = <em>Type</em></li>
</ul>
<hr />
<p>Gets resource from globally registered systems world by its label.</p>
<p>This is a handy shortcut for <strong><code>Self::GetSystemsWorld</code></strong> and then
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#resourceraw"><strong><code>USystemsWorld::ResourceRaw</code></strong></a> on it.</p>
<hr />
<h1 id="arguments-97"><a class="header" href="#arguments-97"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="id-2"><a class="header" href="#id-2"><strong><code>Id</code></strong></a></h2>
<pre><code class="language-cpp">FName Id
</code></pre>
<p>Systems world ID.</p>
</li>
<li>
<h2 id="type-4"><a class="header" href="#type-4"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">const UClass* Type
</code></pre>
<p>Resource type user wants to get from global systems world.</p>
</li>
<li>
<h2 id="worldcontext-4"><a class="header" href="#worldcontext-4"><strong><code>WorldContext</code></strong></a></h2>
<pre><code class="language-cpp">UObject* WorldContext
</code></pre>
<p>World context object.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="getsystemsworld"><a class="header" href="#getsystemsworld"><strong><code>GetSystemsWorld</code></strong></a></h1>
<pre><code class="language-cpp">public:
static USystemsWorld* GetSystemsWorld(
    FName Id,
    UObject* WorldContext
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-43"><a class="header" href="#specifiers-43">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintPure</strong></li>
<li><strong>Category</strong> = <em>Systems|World</em></li>
</ul>
<h3 id="meta-specifiers-11"><a class="header" href="#meta-specifiers-11">Meta Specifiers:</a></h3>
<ul>
<li><strong>WorldContext</strong> = <em>WorldContext</em></li>
<li><strong>UnsafeDuringActorConstruction</strong> = <em>true</em></li>
</ul>
<hr />
<p>Gets globally registered systems world by its label.</p>
<p>Useful in places where we need to perform systems qorld query, but there
is no systems world provided into the scope.</p>
<hr />
<h1 id="arguments-98"><a class="header" href="#arguments-98"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="id-3"><a class="header" href="#id-3"><strong><code>Id</code></strong></a></h2>
<pre><code class="language-cpp">FName Id
</code></pre>
<p>Systems world ID.</p>
</li>
<li>
<h2 id="worldcontext-5"><a class="header" href="#worldcontext-5"><strong><code>WorldContext</code></strong></a></h2>
<pre><code class="language-cpp">UObject* WorldContext
</code></pre>
<p>World context object.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="removecomponent"><a class="header" href="#removecomponent"><strong><code>RemoveComponent</code></strong></a></h1>
<pre><code class="language-cpp">public:
static void RemoveComponent(
    UActorComponent* Component,
    UObject* WorldContext
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-44"><a class="header" href="#specifiers-44">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems|Components</em></li>
</ul>
<h3 id="meta-specifiers-12"><a class="header" href="#meta-specifiers-12">Meta Specifiers:</a></h3>
<ul>
<li><strong>WorldContext</strong> = <em>WorldContext</em></li>
<li><strong>UnsafeDuringActorConstruction</strong> = <em>true</em></li>
</ul>
<hr />
<p>Tries to add component to global systems worlds.</p>
<p>Useful when creating proxy components that inherits from engine
components to make them auto removed from global systems worlds on
<code>EndPlay</code>.</p>
<hr />
<h1 id="arguments-99"><a class="header" href="#arguments-99"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="component-2"><a class="header" href="#component-2"><strong><code>Component</code></strong></a></h2>
<pre><code class="language-cpp">UActorComponent* Component
</code></pre>
<p>Actor component to remove from global systems world.</p>
</li>
<li>
<h2 id="worldcontext-6"><a class="header" href="#worldcontext-6"><strong><code>WorldContext</code></strong></a></h2>
<pre><code class="language-cpp">UObject* WorldContext
</code></pre>
<p>World context object.</p>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-usystemssubsystem"><a class="header" href="#class-usystemssubsystem"><strong>Class: <code>USystemsSubsystem</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API USystemsSubsystem
    : public UGameInstanceSubsystem;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Global accessible registry of systems worlds.</p>
<p><a href="reference/classes//Unreal-Systems-Architecture/systems/book/architecture/subsystem.html">Architecture book page</a> explains more in
depth how to interact with systems subsystem, but in a brief: This is a
registry of globally accessible systems worlds game can have at any time.</p>
<h1 id="example-73"><a class="header" href="#example-73">Example</a></h1>
<pre><code class="language-cpp">UCLASS()
class EXAMPLE_API UExampleGameInstance : public UGameInstance
{
	GENERATED_BODY()

private:
	virtual void Init() override;
};

void UExampleGameInstance::Init()
{
	Super::Init();

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;AcquireSystemsWorld(FName(),
			[&amp;](auto&amp; Systems)
			{
				Systems.RegisterComponent&lt;UShiaComponent&gt;();

				Systems.InstallResource&lt;UShiaSettings&gt;();

				Systems.InstallLambdaSystem(JustDoItSystem, FInstallSystemOptions(&quot;JustDoIt&quot;));
			});
	}
}
</code></pre>
<hr />
<h1 id="methods-19"><a class="header" href="#methods-19"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="acquiresystemsworld"><a class="header" href="#acquiresystemsworld"><strong><code>AcquireSystemsWorld</code></strong></a></h1>
<pre><code class="language-cpp">public:
void AcquireSystemsWorld(
    FName Id,
    TFunction&lt;SystemSetupFunctor&gt; SetupFunctor
);
</code></pre>
<details>
<hr />
<p>Create, setup and register new systems world.</p>
<h1 id="example-74"><a class="header" href="#example-74">Example</a></h1>
<pre><code class="language-cpp">UCLASS()
class EXAMPLE_API AExampleGameMode : public AGameModeBase
{
	GENERATED_BODY()

private:
	virtual void InitGame(const FString&amp; MapName, const FString&amp; Options, FString&amp; ErrorMessage) override;

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
};

void AExampleGameMode::InitGame(const FString&amp; MapName, const FString&amp; Options, FString&amp; ErrorMessage)
{
	Super::InitGame(MapName, Options, ErrorMessage);

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;AcquireSystemsWorld(FName(),
			[&amp;](auto&amp; Systems)
			{
				Systems.RegisterComponent&lt;UShiaComponent&gt;();

				Systems.InstallResource&lt;UShiaSettings&gt;();

				Systems.InstallLambdaSystem(JustDoItSystem, FInstallSystemOptions(&quot;JustDoIt&quot;));
			});
	}
}

void AExampleGameMode::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;ReleaseSystemsWorld(ThisClass::SYSTEMS_WORLD);
	}
}
</code></pre>
<hr />
<h1 id="arguments-100"><a class="header" href="#arguments-100"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="id-4"><a class="header" href="#id-4"><strong><code>Id</code></strong></a></h2>
<pre><code class="language-cpp">FName Id
</code></pre>
<p>Systems world ID.</p>
</li>
<li>
<h2 id="setupfunctor"><a class="header" href="#setupfunctor"><strong><code>SetupFunctor</code></strong></a></h2>
<pre><code class="language-cpp">TFunction&lt;SystemSetupFunctor&gt; SetupFunctor
</code></pre>
<p>Function/lambda that performs setup of created systems world.</p>
<h1 id="note-50"><a class="header" href="#note-50">Note</a></h1>
<blockquote>
<p><code>SystemSetupFunctor</code> has given signature:
<code>void(USystemsWorld&amp; Systems)</code>.</p>
</blockquote>
</li>
</ul>
</details>
</li>
<li>
<h1 id="blueprintacquiresystemsworld"><a class="header" href="#blueprintacquiresystemsworld"><strong><code>BlueprintAcquireSystemsWorld</code></strong></a></h1>
<pre><code class="language-cpp">public:
void BlueprintAcquireSystemsWorld(
    FName Id,
    FOnSetupSystemsWorld SetupDelegate
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-45"><a class="header" href="#specifiers-45">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems|Subsystem</em></li>
</ul>
<h3 id="meta-specifiers-13"><a class="header" href="#meta-specifiers-13">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Acquire Systems World</em></li>
</ul>
<hr />
<p>Create, setup and register new systems world.</p>
<p>Blueprint-side version of <strong><code>Self::AcquireSystemsWorld</code></strong>.</p>
<hr />
<h1 id="arguments-101"><a class="header" href="#arguments-101"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="id-5"><a class="header" href="#id-5"><strong><code>Id</code></strong></a></h2>
<pre><code class="language-cpp">FName Id
</code></pre>
<p>Systems world ID.</p>
</li>
<li>
<h2 id="setupdelegate"><a class="header" href="#setupdelegate"><strong><code>SetupDelegate</code></strong></a></h2>
<pre><code class="language-cpp">FOnSetupSystemsWorld SetupDelegate
</code></pre>
<p>Delegate that performs setup of created systems world.</p>
<h1 id="note-51"><a class="header" href="#note-51">Note</a></h1>
<blockquote>
<p>This delegate has given signature:
<code>void(USystemsWorld&amp; Systems)</code>.</p>
</blockquote>
</li>
</ul>
</details>
</li>
<li>
<h1 id="get"><a class="header" href="#get"><strong><code>Get</code></strong></a></h1>
<pre><code class="language-cpp">public:
static USystemsSubsystem* Get(
    UWorld* World
);
</code></pre>
<details>
<hr />
<p>Gets instance of this subsystem.</p>
<hr />
<h1 id="arguments-102"><a class="header" href="#arguments-102"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="world-3"><a class="header" href="#world-3"><strong><code>World</code></strong></a></h2>
<pre><code class="language-cpp">UWorld* World
</code></pre>
<p>World context object.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="getsystemsworld-1"><a class="header" href="#getsystemsworld-1"><strong><code>GetSystemsWorld</code></strong></a></h1>
<pre><code class="language-cpp">public:
USystemsWorld* GetSystemsWorld(
    FName Id
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-46"><a class="header" href="#specifiers-46">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems|Subsystem</em></li>
</ul>
<h3 id="meta-specifiers-14"><a class="header" href="#meta-specifiers-14">Meta Specifiers:</a></h3>
<ul>
<li><strong>Displayname</strong> = <em>Get Systems World</em></li>
</ul>
<hr />
<p>Gets systems world by its label.</p>
<hr />
<h1 id="arguments-103"><a class="header" href="#arguments-103"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="id-6"><a class="header" href="#id-6"><strong><code>Id</code></strong></a></h2>
<pre><code class="language-cpp">FName Id
</code></pre>
<p>Systems world ID.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="getsystemsworldsids"><a class="header" href="#getsystemsworldsids"><strong><code>GetSystemsWorldsIds</code></strong></a></h1>
<pre><code class="language-cpp">public:
void GetSystemsWorldsIds(
    TSet&lt;FName&gt;&amp; Output
) const;
</code></pre>
<details>
<hr />
<p>Gets list of all registered systems worlds IDs.</p>
<p>Useful only for more advanced usecases like editor tools that might want
to list currently existing systems world.</p>
<hr />
<h1 id="arguments-104"><a class="header" href="#arguments-104"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="output"><a class="header" href="#output"><strong><code>Output</code></strong></a></h2>
<pre><code class="language-cpp">TSet&lt;FName&gt;&amp; Output
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="releasesystemsworld"><a class="header" href="#releasesystemsworld"><strong><code>ReleaseSystemsWorld</code></strong></a></h1>
<pre><code class="language-cpp">public:
void ReleaseSystemsWorld(
    FName Id
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-47"><a class="header" href="#specifiers-47">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems|Subsystem</em></li>
</ul>
<h3 id="meta-specifiers-15"><a class="header" href="#meta-specifiers-15">Meta Specifiers:</a></h3>
<ul>
<li><strong>Displayname</strong> = <em>Release Systems World</em></li>
</ul>
<hr />
<p>Unregister given systems world.</p>
<h1 id="example-75"><a class="header" href="#example-75">Example</a></h1>
<pre><code class="language-cpp">UCLASS()
class EXAMPLE_API AExampleGameMode : public AGameModeBase
{
	GENERATED_BODY()

private:
	virtual void InitGame(const FString&amp; MapName, const FString&amp; Options, FString&amp; ErrorMessage) override;

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
};

void AExampleGameMode::InitGame(const FString&amp; MapName, const FString&amp; Options, FString&amp; ErrorMessage)
{
	Super::InitGame(MapName, Options, ErrorMessage);

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;AcquireSystemsWorld(FName(),
			[&amp;](auto&amp; Systems)
			{
				Systems.RegisterComponent&lt;UShiaComponent&gt;();

				Systems.InstallResource&lt;UShiaSettings&gt;();

				Systems.InstallLambdaSystem(JustDoItSystem, FInstallSystemOptions(&quot;JustDoIt&quot;));
			});
	}
}

void AExampleGameMode::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	auto* Subsystem = USystemsSubsystem::Get(GetWorld());
	if (IsValid(Subsystem))
	{
		Subsystem-&gt;ReleaseSystemsWorld(ThisClass::SYSTEMS_WORLD);
	}
}
</code></pre>
<hr />
<h1 id="arguments-105"><a class="header" href="#arguments-105"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="id-7"><a class="header" href="#id-7"><strong><code>Id</code></strong></a></h2>
<pre><code class="language-cpp">FName Id
</code></pre>
</li>
</ul>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-usystemsworld"><a class="header" href="#class-usystemsworld"><strong>Class: <code>USystemsWorld</code></strong></a></h1>
<pre><code class="language-cpp">class SYSTEMS_API USystemsWorld
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-48"><a class="header" href="#specifiers-48">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Container that holds systems, resources and registry of components that
belongs to actors.</p>
<p><a href="reference/classes//Unreal-Systems-Architecture/systems/book/architecture/world.html">Architecture book page</a> explains more in depth
what systems world is, but in a brief: systems world is a central point user
interacts with using queries to resources and actor components. Think of it
as database - actor components are records and resources are unique
singleton-like data (usually config/settings or things you would call
managers).</p>
<hr />
<h1 id="methods-20"><a class="header" href="#methods-20"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="actors"><a class="header" href="#actors"><strong><code>Actors</code></strong></a></h1>
<pre><code class="language-cpp">public:
FActorsIter Actors();
</code></pre>
<details>
<hr />
<p>Acquires lazy-iterator over all registered actors.</p>
<p>This works similar to <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#query"><strong><code>USystemsWorld::Query</code></strong></a> but it yields
only actors without their components, and <strong>it yields all actors</strong>. This
method exists only for a last resort use cases - user should have a
valid reason to query all actors and should always try to solve problem
with <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#query"><strong><code>USystemsWorld::Query</code></strong></a>.</p>
<p>The only use case i can think of is when user needs to for example count
all registered actors, but there are other usecases which can definitely
be solved with regular component queries.</p>
<p>Common usecase that would be wrong to query actors would be:</p>
<pre><code class="language-cpp">Systems.Actors().ForEach(
	[](const auto* Actor)
	{
		auto* ShiaActor = Cast&lt;AShiaActor&gt;(Actor);
		if (IsValid(ShiaActor))
		{
			ShiaActor-&gt;JustDoit();
		}
	});
</code></pre>
<p>User should instead for example add <code>UShiaComponent</code> actor component and
query actors using
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#query"><strong><code>USystemsWorld::Query</code></strong></a> to iterate only on these actors that
are marked as &quot;Shia&quot; actor using actor component tag:</p>
<pre><code class="language-cpp">Systems.Query&lt;UShiaComponent&gt;().ForEach(
	[](const auto* Actor)
	{
		auto* ShiaActor = Cast&lt;AShiaActor&gt;(Actor);
		if (IsValid(ShiaActor))
		{
			ShiaActor-&gt;JustDoit();
		}
	});
</code></pre>
<p>Another thing is that user should avoid putting any logic into the
actors itself and rather create system that performs work of
<code>AShiaActor::JustDoIt()</code> method. Although sometimes, mostly in case of
interacting with third-party code, user is forced to call logic of actor
so in this case just marking actor with component tag would be a
sufficient compromise.</p>
</details>
</li>
<li>
<h1 id="actorscount"><a class="header" href="#actorscount"><strong><code>ActorsCount</code></strong></a></h1>
<pre><code class="language-cpp">public:
uint32 ActorsCount() const;
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Counts all registered actors.</p>
<p>Useful for debugging purposes to show number of registered actors, but
any other use case would and most likely should be solved with regular
queries.</p>
</details>
</li>
<li>
<h1 id="addcomponent-1"><a class="header" href="#addcomponent-1"><strong><code>AddComponent</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool AddComponent(
    UActorComponent* Component
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-49"><a class="header" href="#specifiers-49">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<hr />
<p>Add actor component to registry.</p>
<p>Called in <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsActorComponent.html#beginplay"><strong><code>USystemsActorComponent::BeginPlay</code></strong></a> and
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsSceneComponent.html#beginplay"><strong><code>USystemsSceneComponent::BeginPlay</code></strong></a> methods so user doesn't
have to, but in case of user dynamically removing actor component to
achieve support for behavior toggling, adding components back to
registry can be achieved with this method.</p>
<h1 id="note-52"><a class="header" href="#note-52">Note</a></h1>
<blockquote>
<p>Actor components are not registered immediatelly to avoid undefined
behavior or even game crashes when performing this while iterating
over systems world queries - rather they ar queued and registered
after all systems complete their run on current game tick.</p>
</blockquote>
<h1 id="return"><a class="header" href="#return">Return</a></h1>
<p>True if both actor and component are valid.</p>
<h1 id="example-76"><a class="header" href="#example-76">Example</a></h1>
<pre><code class="language-cpp">void ASomeActor::ToggleTagComponent(USystemsWorld&amp; Systems, UTagComponent* Tag)
{
	this-&gt;bTagEnabled = !this-&gt;bTagEnabled;
	if (this-&gt;bTagEnabled)
	{
		Systems.AddComponent(this, Tag);
	}
	else
	{
		Systems.RemoveComponent(this, Tag);
	}
}
</code></pre>
<hr />
<h1 id="arguments-106"><a class="header" href="#arguments-106"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="component-3"><a class="header" href="#component-3"><strong><code>Component</code></strong></a></h2>
<pre><code class="language-cpp">UActorComponent* Component
</code></pre>
<p>Component to be registered.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="component-4"><a class="header" href="#component-4"><strong><code>Component</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class T&gt;
T* Component(
    AActor* Actor
);
</code></pre>
<details>
<hr />
<p>Tries to get pointer to registered actor component.</p>
<p>Handy shortcut for <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#componentraw"><strong><code>USystemsWorld::ComponentRaw</code></strong></a></p>
<h1 id="return-1"><a class="header" href="#return-1">Return</a></h1>
<p>Pointer to component or <code>nullptr</code> in case component does not exist in
registry.</p>
<h1 id="note-53"><a class="header" href="#note-53">Note</a></h1>
<blockquote>
<p><code>T</code> should inherit from <strong><code>UActorComponent</code></strong></p>
</blockquote>
<h1 id="example-77"><a class="header" href="#example-77">Example</a></h1>
<pre><code class="language-cpp">Systems.Component&lt;UShiaComponent&gt;(Actor)-&gt;JustDoIt();
</code></pre>
<hr />
<h1 id="arguments-107"><a class="header" href="#arguments-107"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="actor-1"><a class="header" href="#actor-1"><strong><code>Actor</code></strong></a></h2>
<pre><code class="language-cpp">AActor* Actor
</code></pre>
<p>Actor owning given component.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="componentindex"><a class="header" href="#componentindex"><strong><code>ComponentIndex</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;uint32&gt; ComponentIndex(
    const UActorComponent* Component
) const;
</code></pre>
<details>
<hr />
<p>Get component registry index.</p>
<p>Useful when working directly with <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/structs/FArchetypeSignature.html"><strong><code>FArchetypeSignature</code></strong></a>, but
user most likely won't have any high-level usecase for that.</p>
<p>For getting component index by its class use: <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#componenttypeindex"><strong><code>USystemsWorld::ComponentTypeIndex</code></strong></a></p>
<hr />
<h1 id="arguments-108"><a class="header" href="#arguments-108"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="component-5"><a class="header" href="#component-5"><strong><code>Component</code></strong></a></h2>
<pre><code class="language-cpp">const UActorComponent* Component
</code></pre>
<p>Component which index of we ask for.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="componentraw"><a class="header" href="#componentraw"><strong><code>ComponentRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
UActorComponent* ComponentRaw(
    AActor* Actor,
    TSubclassOf&lt;UActorComponent&gt; Type
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-50"><a class="header" href="#specifiers-50">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintPure</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<h3 id="meta-specifiers-16"><a class="header" href="#meta-specifiers-16">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Get Component</em></li>
<li><strong>DeterminesOutputType</strong> = <em>Type</em></li>
</ul>
<hr />
<p>Tries to get pointer to registered actor component.</p>
<h1 id="note-54"><a class="header" href="#note-54">Note</a></h1>
<blockquote>
<p>Because components are registered after systems run this will always
return <code>nullptr</code> whe trying to get actor component just after calling
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#addcomponent"><strong><code>USystemsWorld::AddComponent</code></strong></a></p>
</blockquote>
<blockquote>
<p>Also when trying to get actor component just after calling
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#removecomponent"><strong><code>USystemsWorld::RemoveComponent</code></strong></a> will return given component
instead o <code>nullptr</code> because components get unregistered after systems
run.</p>
</blockquote>
<h1 id="return-2"><a class="header" href="#return-2">Return</a></h1>
<p>Pointer to component or <code>nullptr</code> in case component does not exist in
registry.</p>
<h1 id="example-78"><a class="header" href="#example-78">Example</a></h1>
<pre><code class="language-cpp">Systems.ComponentRaw(Actor, UShiaComponent::StaticClass())-&gt;JustDoIt();
</code></pre>
<hr />
<h1 id="arguments-109"><a class="header" href="#arguments-109"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="actor-2"><a class="header" href="#actor-2"><strong><code>Actor</code></strong></a></h2>
<pre><code class="language-cpp">AActor* Actor
</code></pre>
<p>Actor owning given component.</p>
</li>
<li>
<h2 id="type-5"><a class="header" href="#type-5"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">TSubclassOf&lt;UActorComponent&gt; Type
</code></pre>
<p>Component class.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="componenttypeindex"><a class="header" href="#componenttypeindex"><strong><code>ComponentTypeIndex</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;uint32&gt; ComponentTypeIndex(
    const UClass* Type
) const;
</code></pre>
<details>
<hr />
<p>Get component registry index.</p>
<p>Useful when working directly with <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/structs/FArchetypeSignature.html"><strong><code>FArchetypeSignature</code></strong></a>, but
user most likely won't have any high-level usecase for that.</p>
<p>For getting component index by component: <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#componentindex"><strong><code>USystemsWorld::ComponentIndex</code></strong></a></p>
<hr />
<h1 id="arguments-110"><a class="header" href="#arguments-110"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="type-6"><a class="header" href="#type-6"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">const UClass* Type
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="components-2"><a class="header" href="#components-2"><strong><code>Components</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class... T&gt;
TTuple&lt;T*...&gt; Components(
    AActor* Actor
);
</code></pre>
<details>
<hr />
<p>Gets tuple of actor components.</p>
<p>Handy wrapper for <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#component"><strong><code>USystemsWorld::Component</code></strong></a> in case of
asking for more than one actor component.</p>
<h1 id="note-55"><a class="header" href="#note-55">Note</a></h1>
<blockquote>
<p>Works similar way to <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#query"><strong><code>USystemsWorld::Query</code></strong></a> but do not put
actor in its first tuple element, rather gives exactly the pointers to
actor components user requests. It's worth noting that in case of
component not being registered, it returns <code>nullptr</code> in tuple elements
corresponding to requested actor component type.</p>
</blockquote>
<hr />
<h1 id="arguments-111"><a class="header" href="#arguments-111"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="actor-3"><a class="header" href="#actor-3"><strong><code>Actor</code></strong></a></h2>
<pre><code class="language-cpp">AActor* Actor
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="componentsdidchanged"><a class="header" href="#componentsdidchanged"><strong><code>ComponentsDidChanged</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class... T&gt;
bool ComponentsDidChanged() const;
</code></pre>
<details>
<hr />
<p>Tells if components changed during last game tick.</p>
<p>handy wrapper for <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#componentsdidchangedraw"><strong><code>USystemsWorld::ComponentsDidChangedRaw</code></strong></a>.</p>
</details>
</li>
<li>
<h1 id="componentsdidchangedraw"><a class="header" href="#componentsdidchangedraw"><strong><code>ComponentsDidChangedRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool ComponentsDidChangedRaw(
    const FArchetypeSignature&amp; Signature
) const;
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Tells if components changed during last game tick.</p>
<h1 id="note-56"><a class="header" href="#note-56">Note</a></h1>
<blockquote>
<p>This checks if any, not all of components marked in signature changed.</p>
</blockquote>
<hr />
<h1 id="arguments-112"><a class="header" href="#arguments-112"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="signature"><a class="header" href="#signature"><strong><code>Signature</code></strong></a></h2>
<pre><code class="language-cpp">const FArchetypeSignature&amp; Signature
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="componentssignature"><a class="header" href="#componentssignature"><strong><code>ComponentsSignature</code></strong></a></h1>
<pre><code class="language-cpp">public:
FArchetypeSignature ComponentsSignature(
    const TArrayView&lt;UActorComponent*&gt;&amp; View
) const;
</code></pre>
<details>
<hr />
<p>Get archetype signature of given set of components.</p>
<p>Useful when working directly with <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/structs/FArchetypeSignature.html"><strong><code>FArchetypeSignature</code></strong></a>, but
user most likely won't have any high-level usecase for that.</p>
<hr />
<h1 id="arguments-113"><a class="header" href="#arguments-113"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="view"><a class="header" href="#view"><strong><code>View</code></strong></a></h2>
<pre><code class="language-cpp">const TArrayView&lt;UActorComponent*&gt;&amp; View
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="count-6"><a class="header" href="#count-6"><strong><code>Count</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class... T&gt;
uint32 Count() const;
</code></pre>
<details>
<hr />
<p>Counts actors that contain given archetype signature.</p>
<p>This is ergonomic shortcut for <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#countraw"><strong><code>USystemsWorld::CountRaw</code></strong></a> that
only counts types that should be included.</p>
<h1 id="note-57"><a class="header" href="#note-57">Note</a></h1>
<blockquote>
<p><code>T</code> classes should inherit from <strong><code>UActorComponent</code></strong>!</p>
</blockquote>
<h1 id="example-79"><a class="header" href="#example-79">Example</a></h1>
<pre><code class="language-cpp">const auto Result = Systems.Count&lt;UShiaComponent&gt;();
</code></pre>
</details>
</li>
<li>
<h1 id="countraw"><a class="header" href="#countraw"><strong><code>CountRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
uint32 CountRaw(
    const FArchetypeSignature&amp; IncludeSignature,
    const FArchetypeSignature&amp; ExcludeSignature = {}
) const;
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Counts actors that contain given archetype include signature and do not
contains exclude signature.</p>
<p>This is more performant way of counting actors with given set of
components (although non-ergonomic for sure):</p>
<pre><code class="language-cpp">	// Instead of this:
	const auto A = Systems.Query&lt;UShiaComponent&gt;().Count();

	// You can do this:
	auto Signature = FArchetypeSignature();
	if (const auto Index = Systems.ComponentTypeIndex(UShiaComponent::StaticClass()))
	{
		Signature.EnableBit(Index.GetValue());
	}

	const auto B = Systems.CountRaw(Signature);
</code></pre>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#count"><strong><code>USystemsWorld::Count</code></strong></a> for more ergonomic use.</p>
<h1 id="note-58"><a class="header" href="#note-58">Note</a></h1>
<blockquote>
<p>For example if requested signature is: <code>&lt;A, B&gt;</code> and there are actors:
<code>1: A, B, C</code> and <code>2: A, C</code> then only actor <code>1: A, B, C</code> gets counted
since only this one contains entirel requested signature.</p>
</blockquote>
<hr />
<h1 id="arguments-114"><a class="header" href="#arguments-114"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="includesignature"><a class="header" href="#includesignature"><strong><code>IncludeSignature</code></strong></a></h2>
<pre><code class="language-cpp">const FArchetypeSignature&amp; IncludeSignature
</code></pre>
<p>Archetype signature with minimal set of components that counted
actors should contain.</p>
</li>
<li>
<h2 id="excludesignature"><a class="header" href="#excludesignature"><strong><code>ExcludeSignature</code></strong></a></h2>
<pre><code class="language-cpp">const FArchetypeSignature&amp; ExcludeSignature = {}
</code></pre>
<p>Archetype signature with minimal set of components that counted
actors should not contain.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="dynamicquery"><a class="header" href="#dynamicquery"><strong><code>DynamicQuery</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class T&gt;
UDynamicQuery* DynamicQuery();
</code></pre>
<details>
<hr />
<p>Acquires lazy-iterator to dynamically queried actor components.</p>
<p>Handy shortcut for <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#spawnquery"><strong><code>USystemsWorld::SpawnQuery</code></strong></a>.</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/UDynamicQuery.html"><strong><code>UDynamicQuery</code></strong></a></p>
</details>
</li>
<li>
<h1 id="installdefaultresource"><a class="header" href="#installdefaultresource"><strong><code>InstallDefaultResource</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool InstallDefaultResource(
    const UClass* Type
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-51"><a class="header" href="#specifiers-51">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<hr />
<p>Register resource object.</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#installresourceraw"><strong><code>USystemsWorld::InstallResourceRaw</code></strong></a></p>
<h1 id="return-3"><a class="header" href="#return-3">Return</a></h1>
<p>True if resource was successfully installed (registry is not sealed).</p>
<h1 id="example-80"><a class="header" href="#example-80">Example</a></h1>
<pre><code class="language-cpp">Systems.InstallDefaultResource(UInventory::StaticClass());
</code></pre>
<hr />
<h1 id="arguments-115"><a class="header" href="#arguments-115"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="type-7"><a class="header" href="#type-7"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">const UClass* Type
</code></pre>
<p>Resource class to get constructed and registered.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="installdefaultsystem"><a class="header" href="#installdefaultsystem"><strong><code>InstallDefaultSystem</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool InstallDefaultSystem(
    const UClass* Type,
    FInstallSystemOptions Options
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-52"><a class="header" href="#specifiers-52">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<hr />
<p>Install system.</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#installsystemraw"><strong><code>USystemsWorld::InstallSystemRaw</code></strong></a>, <a href="reference/classes//reference/classes/USystem.html"><strong><code>USystem</code></strong></a>,
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/structs/FInstallSystemOptions.html"><strong><code>FInstallSystemOptions</code></strong></a></p>
<h1 id="return-4"><a class="header" href="#return-4">Return</a></h1>
<p>True if system was successfully installed (registry is not sealed).</p>
<h1 id="example-81"><a class="header" href="#example-81">Example</a></h1>
<pre><code class="language-cpp">Systems.InstallDefaultSystem(USomeSystem::StaticClass(), FInstallSystemOptions(&quot;Something&quot;));
</code></pre>
<hr />
<h1 id="arguments-116"><a class="header" href="#arguments-116"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="type-8"><a class="header" href="#type-8"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">const UClass* Type
</code></pre>
<p>Class of system being installed.</p>
</li>
<li>
<h2 id="options"><a class="header" href="#options"><strong><code>Options</code></strong></a></h2>
<pre><code class="language-cpp">FInstallSystemOptions Options
</code></pre>
<p>System install options.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="installlambdasystem"><a class="header" href="#installlambdasystem"><strong><code>InstallLambdaSystem</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool InstallLambdaSystem(
    TFunction&lt;LambdaSystemType&gt;&amp;&amp; Functor,
    FInstallSystemOptions Options = FInstallSystemOptions()
);
</code></pre>
<details>
<hr />
<p>Install state-less (function or lambda) system.</p>
<p>Stateless systems are the most common ones because usually what system
does it only processes the data, so creating function/lambda systems
brings more ergonomics into codebase.</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/structs/FInstallSystemOptions.html"><strong><code>FInstallSystemOptions</code></strong></a></p>
<h1 id="return-5"><a class="header" href="#return-5">Return</a></h1>
<p>True if system was successfully installed (registry is not sealed).</p>
<h1 id="example-82"><a class="header" href="#example-82">Example</a></h1>
<pre><code class="language-cpp">UFUNCTION()
void BoidsFaceDirectionSystem(USystemsWorld&amp; Systems);

void BoidsFaceDirectionSystem(USystemsWorld&amp; Systems)
{
	Systems.Query&lt;UVelocityComponent, UBoidComponent&gt;().ForEach(
		[&amp;](auto&amp; QueryItem)
		{
			auto* Actor = QueryItem.Get&lt;0&gt;();
			const auto* Velocity = QueryItem.Get&lt;1&gt;();

			if (Velocity-&gt;Value.IsNearlyZero() == false)
			{
				Actor-&gt;SetActorRotation(Velocity-&gt;Value.Rotation());
			}
		});
}
</code></pre>
<pre><code class="language-cpp">Systems.InstallLambdaSystem(BoidsFaceDirectionSystem, FInstallSystemOptions(&quot;BoidsFaceDirection&quot;));
</code></pre>
<hr />
<h1 id="arguments-117"><a class="header" href="#arguments-117"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="functor"><a class="header" href="#functor"><strong><code>Functor</code></strong></a></h2>
<pre><code class="language-cpp">TFunction&lt;LambdaSystemType&gt;&amp;&amp; Functor
</code></pre>
<p>Function or lambda being installed as system</p>
<h1 id="note-59"><a class="header" href="#note-59">Note</a></h1>
<blockquote>
<p><code>LambdaSystemType</code> should comply to given signature:
<code>void(USystemsWorld&amp;)</code></p>
</blockquote>
</li>
<li>
<h2 id="options-1"><a class="header" href="#options-1"><strong><code>Options</code></strong></a></h2>
<pre><code class="language-cpp">FInstallSystemOptions Options = FInstallSystemOptions()
</code></pre>
<p>System install options.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="installresource"><a class="header" href="#installresource"><strong><code>InstallResource</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class T&gt;
bool InstallResource();
</code></pre>
<details>
<hr />
<p>Register resource object.</p>
<p>Handy shortcut for <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#installdefaultresource"><strong><code>USystemsWorld::InstallDefaultResource</code></strong></a></p>
<h1 id="return-6"><a class="header" href="#return-6">Return</a></h1>
<p>True if resource was successfully installed (registry is not sealed).</p>
<h1 id="example-83"><a class="header" href="#example-83">Example</a></h1>
<pre><code class="language-cpp">Systems.InstallResource&lt;UInventory&gt;();
</code></pre>
</details>
</li>
<li>
<h1 id="installresourceraw"><a class="header" href="#installresourceraw"><strong><code>InstallResourceRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool InstallResourceRaw(
    UObject* Resource
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-53"><a class="header" href="#specifiers-53">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<h3 id="meta-specifiers-17"><a class="header" href="#meta-specifiers-17">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Install Resource</em></li>
</ul>
<hr />
<p>Register resource object.</p>
<p>It accepts any object that inherits from <code>UObject</code>. Also systems world
takes ownership over provided resource so its best to not pass any
object that has its lifetime managed by other object.</p>
<h1 id="return-7"><a class="header" href="#return-7">Return</a></h1>
<p>True if resource was successfully installed (registry is not sealed).</p>
<h1 id="example-84"><a class="header" href="#example-84">Example</a></h1>
<pre><code class="language-cpp">Systems.InstallResourceRaw(NewObject&lt;UInventory&gt;(Systems, UInventory::StaticClass()));
</code></pre>
<hr />
<h1 id="arguments-118"><a class="header" href="#arguments-118"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="resource"><a class="header" href="#resource"><strong><code>Resource</code></strong></a></h2>
<pre><code class="language-cpp">UObject* Resource
</code></pre>
<p>Resource object to get registered and managed by this systems world.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="installsystem"><a class="header" href="#installsystem"><strong><code>InstallSystem</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class T&gt;
bool InstallSystem(
    FInstallSystemOptions Options
);
</code></pre>
<details>
<hr />
<p>Install system.</p>
<p>Handy shortcut for <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#installdefaultsystem"><strong><code>USystemsWorld::InstallDefaultSystem</code></strong></a></p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystem.html"><strong><code>USystem</code></strong></a>, <a href="reference/classes//reference/structs/FInstallSystemOptions.html"><strong><code>FInstallSystemOptions</code></strong></a></p>
<h1 id="note-60"><a class="header" href="#note-60">Note</a></h1>
<blockquote>
<p>Make sure <code>T</code> is a class that inherits from <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystem.html"><strong><code>USystem</code></strong></a>!</p>
</blockquote>
<h1 id="return-8"><a class="header" href="#return-8">Return</a></h1>
<p>True if system was successfully installed (registry is not sealed).</p>
<h1 id="example-85"><a class="header" href="#example-85">Example</a></h1>
<pre><code class="language-cpp">Systems.InstallSystem&lt;USomeSystem&gt;(FInstallSystemOptions(&quot;Something&quot;));
</code></pre>
<hr />
<h1 id="arguments-119"><a class="header" href="#arguments-119"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="options-2"><a class="header" href="#options-2"><strong><code>Options</code></strong></a></h2>
<pre><code class="language-cpp">FInstallSystemOptions Options
</code></pre>
<p>System install options.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="installsystemraw"><a class="header" href="#installsystemraw"><strong><code>InstallSystemRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool InstallSystemRaw(
    USystem* System,
    FInstallSystemOptions Options
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-54"><a class="header" href="#specifiers-54">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<h3 id="meta-specifiers-18"><a class="header" href="#meta-specifiers-18">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Install System</em></li>
</ul>
<hr />
<p>Install system.</p>
<p>Usually user would want to install systems using either
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#installsystem"><strong><code>USystemsWorld::InstallSystem</code></strong></a> or <a href="reference/classes//reference/classes/USystemsWorld.html#installlambdasystem"><strong><code>USystemsWorld::InstallLambdaSystem</code></strong></a> but in case of valid reasons user
can install system by its instance.</p>
<h1 id="note-61"><a class="header" href="#note-61">Note</a></h1>
<blockquote>
<p>In case of <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/structs/FInstallSystemOptions.html#label"><strong><code>FInstallSystemOptions::Label</code></strong></a> being empty, it
will generate random label from new GUID.</p>
</blockquote>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystem.html"><strong><code>USystem</code></strong></a>, <a href="reference/classes//reference/structs/FInstallSystemOptions.html"><strong><code>FInstallSystemOptions</code></strong></a></p>
<h1 id="return-9"><a class="header" href="#return-9">Return</a></h1>
<p>True if system was successfully installed (registry is not sealed).</p>
<h1 id="example-86"><a class="header" href="#example-86">Example</a></h1>
<pre><code class="language-cpp">Systems.InstallSystemRaw(
	NewObject&lt;USomeSystem&gt;(Systems, USomeSystem::StaticClass()), FInstallSystemOptions(&quot;Something&quot;));
</code></pre>
<hr />
<h1 id="arguments-120"><a class="header" href="#arguments-120"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="system"><a class="header" href="#system"><strong><code>System</code></strong></a></h2>
<pre><code class="language-cpp">USystem* System
</code></pre>
<p>Pointer to system being installed.</p>
</li>
<li>
<h2 id="options-3"><a class="header" href="#options-3"><strong><code>Options</code></strong></a></h2>
<pre><code class="language-cpp">FInstallSystemOptions Options
</code></pre>
<p>System install options.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="lastchangedcomponents"><a class="header" href="#lastchangedcomponents"><strong><code>LastChangedComponents</code></strong></a></h1>
<pre><code class="language-cpp">public:
const FArchetypeSignature&amp; LastChangedComponents() const;
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Returns signature of component types that changed during last game tick.</p>
<p>Useful for more usecases where user needs to cache and perform more
advanced change detection between game ticks.</p>
</details>
</li>
<li>
<h1 id="lastchangedresources"><a class="header" href="#lastchangedresources"><strong><code>LastChangedResources</code></strong></a></h1>
<pre><code class="language-cpp">public:
const TSet&lt;uint32&gt;&amp; LastChangedResources() const;
</code></pre>
<details>
<hr />
<p>Returns a set of unique type IDs of all resources that changed in last
game tick.</p>
<p>Useful for more advanced usecases where user needs to ask for all
changes anyway and compare them with some cached set of previously
stored changes.</p>
</details>
</li>
<li>
<h1 id="markcomponentchanged"><a class="header" href="#markcomponentchanged"><strong><code>MarkComponentChanged</code></strong></a></h1>
<pre><code class="language-cpp">public:
void MarkComponentChanged(
    UActorComponent* Component
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-55"><a class="header" href="#specifiers-55">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<hr />
<p>Marks component as changed.</p>
<h1 id="note-62"><a class="header" href="#note-62">Note</a></h1>
<blockquote>
<p>This will mark component type, not component instance, as changed. The
need for component iinstance here is purely to ensure we do not mark
components we do not have access to.</p>
</blockquote>
<hr />
<h1 id="arguments-121"><a class="header" href="#arguments-121"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="component-6"><a class="header" href="#component-6"><strong><code>Component</code></strong></a></h2>
<pre><code class="language-cpp">UActorComponent* Component
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="markresourcechanged"><a class="header" href="#markresourcechanged"><strong><code>MarkResourceChanged</code></strong></a></h1>
<pre><code class="language-cpp">public:
void MarkResourceChanged(
    UObject* Resource
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-56"><a class="header" href="#specifiers-56">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<hr />
<p>Marks given resource as changed.</p>
<p>Useful if user wants to create reactive systems and/or UI that should
only trigger when given resource changes. The reason why user has to
manually mark resources as changed is for optimizations purposes, to
mark deliberate changes in resources instead of markin them
automatically, to avoid a lot of boilerplate of that automation, when
most of the times systems and UI do not require to ask for changes.</p>
<p>Use <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#resourcedidchanged"><strong><code>USystemsWorld::ResourceDidChanged</code></strong></a> to ask if some
resource has changed.</p>
<hr />
<h1 id="arguments-122"><a class="header" href="#arguments-122"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="resource-1"><a class="header" href="#resource-1"><strong><code>Resource</code></strong></a></h2>
<pre><code class="language-cpp">UObject* Resource
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="process"><a class="header" href="#process"><strong><code>Process</code></strong></a></h1>
<pre><code class="language-cpp">public:
void Process();
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-57"><a class="header" href="#specifiers-57">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<hr />
<p>Process systems world.</p>
<p>It performs:</p>
<ul>
<li>unregistering of removed components and/or actors.</li>
<li>registering of added components and/or actors.</li>
<li>run systems logic.</li>
</ul>
<p>In case of registry not being sealed at the time of calling this method,
none of steps above are gonna be performed.</p>
<p>This method is called automatically for global systems world managed by
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsSubsystem.html"><strong><code>USystemsSubsystem</code></strong></a>, but in case of user managing systems
world on their own, user can do:</p>
<pre><code class="language-cpp">	auto* Systems = NewObject&lt;USystemsWorld&gt;(this, USystemsWorld::StaticClass());

	// [Systems world setup...]

	Systems-&gt;Process();
</code></pre>
</details>
</li>
<li>
<h1 id="query"><a class="header" href="#query"><strong><code>Query</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class... T&gt;
TQuery&lt;T...&gt; Query();
</code></pre>
<details>
<hr />
<p>Acquires lazy-iterator to query actor components.</p>
<p>More about iterators in <a href="reference/classes//Unreal-Systems-Architecture/systems/book/architecture/iterators.html">this architecture book
page</a>.</p>
<p>Queries allow to yield tuples of actor and their components, and only
those that comply to given query signature, so there is no iteration
over any actor that do not have given component types - actors and
components are registered to buckets called archetypes, and archetypes
are unique as long as their signature is unique. Signature is
constructed from types provided to query, as well as from types
registered to systems world that belong to the same actor. Systems
architecture focuses on performing queries as fast as possible and not
iterating over actors that do not need to be queried was a priority.</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html"><strong><code>TQuery</code></strong></a></p>
<h1 id="note-63"><a class="header" href="#note-63">Note</a></h1>
<blockquote>
<p>Returned query iterator has always actor put as first item of item
tuple and then follow requested components. So <code>Systems-&gt;Query&lt;A, B, C&gt;()</code> iterator will yield given tuple <code>TTuple&lt;AActor*, A*, B*, C*&gt;</code></p>
</blockquote>
<h1 id="example-87"><a class="header" href="#example-87">Example</a></h1>
<pre><code class="language-cpp">	const auto Count = static_cast&lt;int&gt;(Systems.Query&lt;UBoidComponent&gt;().Count());
	const auto Difference = Count - EXPECTED_POPULATION_NUMBER;

	if (Difference &gt; 0)
	{
		Systems.Query&lt;UBoidComponent&gt;()
			.Take(Difference)
			.ForEach(
				[](auto&amp; QueryItem)
				{
					auto* Actor = QueryItem.Get&lt;0&gt;();

					Actor-&gt;Destroy();
				});
	}
</code></pre>
</details>
</li>
<li>
<h1 id="registercomponent"><a class="header" href="#registercomponent"><strong><code>RegisterComponent</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class T&gt;
bool RegisterComponent();
</code></pre>
<details>
<hr />
<p>Register component type.</p>
<p>Templated shortcut for <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#registercomponentraw"><strong><code>USystemsWorld::RegisterComponentRaw</code></strong></a></p>
<p>See <strong><code>UActorComponent</code></strong></p>
<h1 id="return-10"><a class="header" href="#return-10">Return</a></h1>
<p>True if component was successfully installed (registry is not sealed and
registry haven't reached its capacity).</p>
<h1 id="note-64"><a class="header" href="#note-64">Note</a></h1>
<blockquote>
<p><code>T</code> has to be a component that inherits from <strong><code>UActorComponent</code></strong></p>
</blockquote>
<h1 id="example-88"><a class="header" href="#example-88">Example</a></h1>
<pre><code class="language-cpp">Systems.RegisterComponent&lt;USomeComponent&gt;();
</code></pre>
</details>
</li>
<li>
<h1 id="registercomponentraw"><a class="header" href="#registercomponentraw"><strong><code>RegisterComponentRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool RegisterComponentRaw(
    const UClass* Type
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-58"><a class="header" href="#specifiers-58">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<h3 id="meta-specifiers-19"><a class="header" href="#meta-specifiers-19">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Register Component</em></li>
</ul>
<hr />
<p>Register component type.</p>
<p>Prior to <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/structs/FArchetypeSignature.html"><strong><code>FArchetypeSignature</code></strong></a> being usable for queries and
other architecture parts, it has to be able to identify components and
for that they has to be registered by their class.</p>
<p>See <strong><code>UActorComponent</code></strong></p>
<h1 id="return-11"><a class="header" href="#return-11">Return</a></h1>
<p>True if component was successfully installed (registry is not sealed and
registry haven't reached its capacity).</p>
<h1 id="example-89"><a class="header" href="#example-89">Example</a></h1>
<pre><code class="language-cpp">Systems.RegisterComponentRaw(USomeComponent::StaticClass());
</code></pre>
<hr />
<h1 id="arguments-123"><a class="header" href="#arguments-123"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="type-9"><a class="header" href="#type-9"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">const UClass* Type
</code></pre>
<p>Class of component that has to inherit from <strong><code>UActorComponent</code></strong></p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="removecomponent-1"><a class="header" href="#removecomponent-1"><strong><code>RemoveComponent</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool RemoveComponent(
    UActorComponent* Component
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-59"><a class="header" href="#specifiers-59">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<hr />
<p>Remove actor component from registry.</p>
<p>Called in <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsActorComponent.html#endplay"><strong><code>USystemsActorComponent::EndPlay</code></strong></a> and
<a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsSceneComponent.html#endplay"><strong><code>USystemsSceneComponent::EndPlay</code></strong></a> methods so user doesn't have
to, but in case of user dynamically adding actor component to achieve
support for behavior toggling, removing components from registry can be
achieved with this method.</p>
<h1 id="note-65"><a class="header" href="#note-65">Note</a></h1>
<blockquote>
<p>Actor components are not unregistered immediatelly to avoid undefined
behavior or eve game crashes when performing this while iterating
over systems world queries - rather the are queued and unregistered
after all systems complete their run on current game tick.</p>
</blockquote>
<h1 id="return-12"><a class="header" href="#return-12">Return</a></h1>
<p>True if both actor and component are valid.</p>
<h1 id="example-90"><a class="header" href="#example-90">Example</a></h1>
<pre><code class="language-cpp">void ASomeActor::ToggleTagComponent(USystemsWorld&amp; Systems, UTagComponent* Tag)
{
	this-&gt;bTagEnabled = !this-&gt;bTagEnabled;
	if (this-&gt;bTagEnabled)
	{
		Systems.AddComponent(this, Tag);
	}
	else
	{
		Systems.RemoveComponent(this, Tag);
	}
}
</code></pre>
<hr />
<h1 id="arguments-124"><a class="header" href="#arguments-124"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="component-7"><a class="header" href="#component-7"><strong><code>Component</code></strong></a></h2>
<pre><code class="language-cpp">UActorComponent* Component
</code></pre>
<p>Component to be unregistered.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="resource-2"><a class="header" href="#resource-2"><strong><code>Resource</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename T&gt;
T* Resource();
</code></pre>
<details>
<hr />
<p>Tries to get pointer to resource by its type.</p>
<h1 id="return-13"><a class="header" href="#return-13">Return</a></h1>
<p>Pointer to resource or <code>nullptr</code> in case resource does not exist in
registry.</p>
<h1 id="example-91"><a class="header" href="#example-91">Example</a></h1>
<pre><code class="language-cpp">Systems.Resource&lt;UInventory&gt;()-&gt;AddItem(FItem{FItemType::Sword});
</code></pre>
</details>
</li>
<li>
<h1 id="resourcedidchanged"><a class="header" href="#resourcedidchanged"><strong><code>ResourceDidChanged</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class T&gt;
bool ResourceDidChanged() const;
</code></pre>
<details>
<hr />
<p>Tells if given resource type did changed in last game tick.</p>
<p>Handy wrapper for <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#resourcedidchangedraw"><strong><code>USystemsWorld::ResourceDidChangedRaw</code></strong></a>.</p>
</details>
</li>
<li>
<h1 id="resourcedidchangedraw"><a class="header" href="#resourcedidchangedraw"><strong><code>ResourceDidChangedRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
bool ResourceDidChangedRaw(
    const UClass* Type
) const;
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-60"><a class="header" href="#specifiers-60">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<hr />
<p>Tells if given resource type did changed in last game tick.</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#markresourcechanged"><strong><code>USystemsWorld::MarkResourceChanged</code></strong></a>.</p>
<hr />
<h1 id="arguments-125"><a class="header" href="#arguments-125"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="type-10"><a class="header" href="#type-10"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">const UClass* Type
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="resourceraw"><a class="header" href="#resourceraw"><strong><code>ResourceRaw</code></strong></a></h1>
<pre><code class="language-cpp">public:
UObject* ResourceRaw(
    const UClass* Type
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-61"><a class="header" href="#specifiers-61">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintPure</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<h3 id="meta-specifiers-20"><a class="header" href="#meta-specifiers-20">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Get Resource</em></li>
<li><strong>DeterminesOutputType</strong> = <em>Type</em></li>
</ul>
<hr />
<p>Tries to get pointer to resource by its class.</p>
<h1 id="return-14"><a class="header" href="#return-14">Return</a></h1>
<p>Pointer to resource or <code>nullptr</code> in case resource does not exist in
registry.</p>
<h1 id="example-92"><a class="header" href="#example-92">Example</a></h1>
<pre><code class="language-cpp">auto* Inventory = Cast&lt;UInventory&gt;(Systems.ResourceRaw());
if (IsValid(Inventory))
{
	Inventory-&gt;AddItem(FItem{FItemType::Sword});
}
</code></pre>
<hr />
<h1 id="arguments-126"><a class="header" href="#arguments-126"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="type-11"><a class="header" href="#type-11"><strong><code>Type</code></strong></a></h2>
<pre><code class="language-cpp">const UClass* Type
</code></pre>
<p>Resource class.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="sealandinitialize"><a class="header" href="#sealandinitialize"><strong><code>SealAndInitialize</code></strong></a></h1>
<pre><code class="language-cpp">public:
void SealAndInitialize();
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-62"><a class="header" href="#specifiers-62">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<hr />
<p>Seal registry and initialize installed systems.</p>
<p>Method called by: <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsSubsystem.html#acquiresystemsworld"><strong><code>USystemsSubsystem::AcquireSystemsWorld</code></strong></a>.</p>
<p>When user doesn't use <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/USystemsSubsystem.html"><strong><code>USystemsSubsystem</code></strong></a> as global systems
world registry, or wants to handle systems world on their own, user
should call this method after systems world setup (registering
components, installation of systems and resources) and then call this
method.</p>
<h1 id="note-66"><a class="header" href="#note-66">Note</a></h1>
<blockquote>
<p>After calling this method, no further successful system or resource
installation i possible, so make sure to install systems world
components before sealing systems world!</p>
</blockquote>
<h1 id="example-93"><a class="header" href="#example-93">Example</a></h1>
<pre><code class="language-cpp">	auto* Systems = NewObject&lt;USystemsWorld&gt;(this, USystemsWorld::StaticClass());
	if (IsValid(Systems) == false)
	{
		Systems-&gt;InstallResource&lt;USomeResource&gt;();

		Systems-&gt;InstallLambdaSystem(SomeSystem, FInstallSystemOptions(&quot;Something&quot;));

		Systems-&gt;SealAndInitialize();
	}
</code></pre>
</details>
</li>
<li>
<h1 id="spawnquery"><a class="header" href="#spawnquery"><strong><code>SpawnQuery</code></strong></a></h1>
<pre><code class="language-cpp">public:
UDynamicQuery* SpawnQuery(
    const UClass* BundleType
);
</code></pre>
<details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-63"><a class="header" href="#specifiers-63">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Systems</em></li>
</ul>
<h3 id="meta-specifiers-21"><a class="header" href="#meta-specifiers-21">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Query</em></li>
<li><strong>DevelopmentOnly</strong></li>
</ul>
<hr />
<p>Acquires lazy-iterator to dynamically queried actor components.</p>
<p>Because user cannot use templated types in blueprints, dynamic queries
are a way to query systems world in blueprints. Also dynamic queries do
not implement lazy-iterators so they are definitely not an ergonomic way
to iterate over actor components and should be avoided in favor of
<strong><code>USystems::Query</code></strong>.</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/classes/UDynamicQuery.html"><strong><code>UDynamicQuery</code></strong></a></p>
<hr />
<h1 id="arguments-127"><a class="header" href="#arguments-127"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="bundletype"><a class="header" href="#bundletype"><strong><code>BundleType</code></strong></a></h2>
<pre><code class="language-cpp">const UClass* BundleType
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="taggedquery"><a class="header" href="#taggedquery"><strong><code>TaggedQuery</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;class... T&gt;
TTaggedQuery&lt;T...&gt; TaggedQuery();
</code></pre>
<details>
<hr />
<p>Acquires lazy-iterator to query actor components with additional tag
components.</p>
<p>The difference between <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/structs/TQuery.html"><strong><code>TQuery</code></strong></a> is that tagged queries
allows to request existance of additional components on actor, ones that
are not required for query to access - useful when user do not require
any data of given components.</p>
<p>See <a href="reference/classes//Unreal-Systems-Architecture/systems/reference/structs/TTaggedQuery.html"><strong><code>TTaggedQuery</code></strong></a></p>
<h1 id="example-94"><a class="header" href="#example-94">Example</a></h1>
<pre><code class="language-cpp">	Systems.TaggedQuery&lt;UVelocityComponent&gt;().With&lt;UBoidComponent&gt;().Iter().ForEach(
		[](auto&amp; QueryItem)
		{
			auto* Actor = QueryItem.Get&lt;0&gt;();
			const auto* Velocity = QueryItem.Get&lt;1&gt;();
			const auto Position = Actor-&gt;GetActorLocation();

			Actor-&gt;SetActorLocation(Position + Velocity-&gt;Value * DletaTime);
		});
</code></pre>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<ul>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/functions/IterGenerate.html"><code>IterGenerate</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/functions/IterOnce.html"><code>IterOnce</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/functions/IterRange.html"><code>IterRange</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/functions/IterRepeat.html"><code>IterRepeat</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/functions/IterStd.html"><code>IterStd</code></a></li>
<li><a href="reference//Unreal-Systems-Architecture/systems/reference/reference/functions/IterStdConst.html"><code>IterStdConst</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-itergenerate"><a class="header" href="#function-itergenerate"><strong>Function: <code>IterGenerate</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename T, typename F&gt;
TIterGenerate&lt;T, F&gt; IterGenerate(
    F Functor
);
</code></pre>
<hr />
<p>Iterator that generates values infinitely.</p>
<p>Useful for example for yielding random values, or anything that user would
want to generate procedurally. It is useful to combine it with <code>Take</code>
iterator to limit number of iterations in loop or for collecting values it
yields.</p>
<h1 id="example-95"><a class="header" href="#example-95">Example</a></h1>
<pre><code class="language-cpp">// [?, ?, ?, ?, ?]
const TArray&lt;int&gt; Result = IterGenerate&lt;int&gt;([]() { return FMath::Rand(); }).Take(5).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-128"><a class="header" href="#arguments-128"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="functor-1"><a class="header" href="#functor-1"><strong><code>Functor</code></strong></a></h2>
<pre><code class="language-cpp">F Functor
</code></pre>
<p>Functor that should comply to signature: <code>T()</code>.</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-iteronce"><a class="header" href="#function-iteronce"><strong>Function: <code>IterOnce</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename T&gt;
TIterOnce&lt;T&gt; IterOnce(
    T Value
);
</code></pre>
<hr />
<p>Iterator that yields one value only once.</p>
<p>Useful to use for yielding &quot;leading/trailing/separator&quot; values in chains of
multiple iterators.</p>
<h1 id="example-96"><a class="header" href="#example-96">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4, -1, 5, 6, 7, 8, 9]
const TArray&lt;int&gt; Result = IterRange(0, 5).Chain(IterOnce(-1)).Chain(IterRange(5, 10)).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-129"><a class="header" href="#arguments-129"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="value-6"><a class="header" href="#value-6"><strong><code>Value</code></strong></a></h2>
<pre><code class="language-cpp">T Value
</code></pre>
<p>Value that iterator should yield once.</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-iterrange"><a class="header" href="#function-iterrange"><strong>Function: <code>IterRange</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename T&gt;
TIterRange&lt;T&gt; IterRange(
    T From,
    T To
);
</code></pre>
<hr />
<p>Iterator that yields range of values.</p>
<p>Range:</p>
<ul>
<li>inclusive lower bound.</li>
<li>exclusive upper bound.
For range from 0 to 5 it means yielding values: 0, 1, 2, 3, 4.</li>
</ul>
<h1 id="note-67"><a class="header" href="#note-67">Note</a></h1>
<blockquote>
<p>This iterator is value type agnostic, all it requires from type is for it
to implemen <code>operator++</code> and <code>operator-</code>;</p>
</blockquote>
<h1 id="example-97"><a class="header" href="#example-97">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
const TArray&lt;int&gt; Result = IterRange(0, 10).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-130"><a class="header" href="#arguments-130"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="from"><a class="header" href="#from"><strong><code>From</code></strong></a></h2>
<pre><code class="language-cpp">T From
</code></pre>
<p>Lower inclusive bound.</p>
</li>
<li>
<h2 id="to"><a class="header" href="#to"><strong><code>To</code></strong></a></h2>
<pre><code class="language-cpp">T To
</code></pre>
<p>Upper exclusive bound.</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-iterrepeat"><a class="header" href="#function-iterrepeat"><strong>Function: <code>IterRepeat</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename T&gt;
TIterRepeat&lt;T&gt; IterRepeat(
    T Value
);
</code></pre>
<hr />
<p>Iterator that yields one value infinitely.</p>
<p>Useful to combine it with <code>Take</code> iterator to avoid infinite loops or
collecting iterator values that never ends.</p>
<h1 id="example-98"><a class="header" href="#example-98">Example</a></h1>
<pre><code class="language-cpp">// [1, 1, 1, 1, 1]
const TArray&lt;int&gt; Result = IterRepeat(1).Take(5).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-131"><a class="header" href="#arguments-131"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="value-7"><a class="header" href="#value-7"><strong><code>Value</code></strong></a></h2>
<pre><code class="language-cpp">T Value
</code></pre>
<p>Value that iterator should yield infinitely.</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-iterstd"><a class="header" href="#function-iterstd"><strong>Function: <code>IterStd</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename T&gt;
TIterStd&lt;T&gt; IterStd(
    T&amp; Container
);
</code></pre>
<hr />
<p>Iterator that yields mutable values from standard Unreal Engine collections
(such as arrays, sets and maps).</p>
<h1 id="example-99"><a class="header" href="#example-99">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4]
TArray&lt;int&gt; Result = IterRange(0, 5).CollectArray();
// [0, 2, 4, 9, 16]
IterStd(Result).ForEach([](auto&amp; Value) { Value = Value * Value; });
</code></pre>
<hr />
<h1 id="arguments-132"><a class="header" href="#arguments-132"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="container"><a class="header" href="#container"><strong><code>Container</code></strong></a></h2>
<pre><code class="language-cpp">T&amp; Container
</code></pre>
<p>Reference to Unreal Engine collection.</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-iterstdconst"><a class="header" href="#function-iterstdconst"><strong>Function: <code>IterStdConst</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename T&gt;
TIterStdConst&lt;T&gt; IterStdConst(
    const T&amp; Container
);
</code></pre>
<hr />
<p>Iterator that yields immutable values from standard Unreal Engine
collections (such as arrays, sets and maps).</p>
<h1 id="example-100"><a class="header" href="#example-100">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
const TArray&lt;int&gt; ResultA = IterRange(0, 10).CollectArray();
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
const TArray&lt;int&gt; ResultB = IterStd(ResultA).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-133"><a class="header" href="#arguments-133"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="container-1"><a class="header" href="#container-1"><strong><code>Container</code></strong></a></h2>
<pre><code class="language-cpp">const T&amp; Container
</code></pre>
<p>Reference to Unreal Engine collection.</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.5</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
