<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TQuery - Systems - Modular and scalable game architecture for orthogonal game logic</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../documentation.html">Documentation</a></li><li class="chapter-item expanded "><a href="../../book/index.html">Book</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../book/getting_started.html">Getting started</a></li><li class="chapter-item expanded "><a href="../../book/architecture/index.html">Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../book/architecture/world.html">World</a></li><li class="chapter-item expanded "><a href="../../book/architecture/systems.html">Systems</a></li><li class="chapter-item expanded "><a href="../../book/architecture/components.html">Components</a></li><li class="chapter-item expanded "><a href="../../book/architecture/resources.html">Resources</a></li><li class="chapter-item expanded "><a href="../../book/architecture/subsystem.html">Subsystem</a></li><li class="chapter-item expanded "><a href="../../book/architecture/pipelines.html">Pipelines</a></li><li class="chapter-item expanded "><a href="../../book/architecture/iterators.html">Iterators</a></li><li class="chapter-item expanded "><a href="../../book/architecture/channels.html">Channels</a></li></ol></li><li class="chapter-item expanded "><a href="../../book/learning_materials/index.html">Learning materials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../book/learning_materials/tutorial/index.html">Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../book/learning_materials/tutorial/installation.html">Installation</a></li><li class="chapter-item expanded "><a href="../../book/learning_materials/tutorial/setup_component.html">Setup component</a></li><li class="chapter-item expanded "><a href="../../book/learning_materials/tutorial/setup_actor.html">Setup actor</a></li><li class="chapter-item expanded "><a href="../../book/learning_materials/tutorial/setup_system.html">Setup system</a></li><li class="chapter-item expanded "><a href="../../book/learning_materials/tutorial/setup_game.html">Setup game</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../reference.html">C++ API Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/structs.html">Structs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/structs/FActorsIter.html">FActorsIter</a></li><li class="chapter-item expanded "><a href="../../reference/structs/FArchetypeSignature.html">FArchetypeSignature</a></li><li class="chapter-item expanded "><a href="../../reference/structs/FInstallSystemOptions.html">FInstallSystemOptions</a></li><li class="chapter-item expanded "><a href="../../reference/structs/FMetronome.html">FMetronome</a></li><li class="chapter-item expanded "><a href="../../reference/structs/FSystemsPipelineAssetResource.html">FSystemsPipelineAssetResource</a></li><li class="chapter-item expanded "><a href="../../reference/structs/FSystemsPipelineComponent.html">FSystemsPipelineComponent</a></li><li class="chapter-item expanded "><a href="../../reference/structs/FSystemsPipelineResource.html">FSystemsPipelineResource</a></li><li class="chapter-item expanded "><a href="../../reference/structs/FSystemsPipelineSystem.html">FSystemsPipelineSystem</a></li><li class="chapter-item expanded "><a href="../../reference/structs/FSystemsPipelineTypeResource.html">FSystemsPipelineTypeResource</a></li><li class="chapter-item expanded "><a href="../../reference/structs/IterSizeHint.html">IterSizeHint</a></li><li class="chapter-item expanded "><a href="../../reference/structs/TQuery.html" class="active">TQuery</a></li><li class="chapter-item expanded "><a href="../../reference/structs/TReceiverChannel.html">TReceiverChannel</a></li><li class="chapter-item expanded "><a href="../../reference/structs/TResult.html">TResult</a></li><li class="chapter-item expanded "><a href="../../reference/structs/TSenderChannel.html">TSenderChannel</a></li><li class="chapter-item expanded "><a href="../../reference/structs/TTaggedQuery.html">TTaggedQuery</a></li></ol></li><li class="chapter-item expanded "><a href="../../reference/classes.html">Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/classes/ASystemsActor.html">ASystemsActor</a></li><li class="chapter-item expanded "><a href="../../reference/classes/ASystemsGameMode.html">ASystemsGameMode</a></li><li class="chapter-item expanded "><a href="../../reference/classes/ASystemsGameState.html">ASystemsGameState</a></li><li class="chapter-item expanded "><a href="../../reference/classes/ASystemsPawn.html">ASystemsPawn</a></li><li class="chapter-item expanded "><a href="../../reference/classes/FSystemsReflection.html">FSystemsReflection</a></li><li class="chapter-item expanded "><a href="../../reference/classes/UDynamicIterator.html">UDynamicIterator</a></li><li class="chapter-item expanded "><a href="../../reference/classes/UDynamicQuery.html">UDynamicQuery</a></li><li class="chapter-item expanded "><a href="../../reference/classes/ULambdaSystem.html">ULambdaSystem</a></li><li class="chapter-item expanded "><a href="../../reference/classes/UScriptableSystem.html">UScriptableSystem</a></li><li class="chapter-item expanded "><a href="../../reference/classes/USystem.html">USystem</a></li><li class="chapter-item expanded "><a href="../../reference/classes/USystemsActorComponent.html">USystemsActorComponent</a></li><li class="chapter-item expanded "><a href="../../reference/classes/USystemsGroupComponent.html">USystemsGroupComponent</a></li><li class="chapter-item expanded "><a href="../../reference/classes/USystemsPipeline.html">USystemsPipeline</a></li><li class="chapter-item expanded "><a href="../../reference/classes/USystemsReflection.html">USystemsReflection</a></li><li class="chapter-item expanded "><a href="../../reference/classes/USystemsSceneComponent.html">USystemsSceneComponent</a></li><li class="chapter-item expanded "><a href="../../reference/classes/USystemsStatics.html">USystemsStatics</a></li><li class="chapter-item expanded "><a href="../../reference/classes/USystemsSubsystem.html">USystemsSubsystem</a></li><li class="chapter-item expanded "><a href="../../reference/classes/USystemsWorld.html">USystemsWorld</a></li></ol></li><li class="chapter-item expanded "><a href="../../reference/functions.html">Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/functions/IterArray.html">IterArray</a></li><li class="chapter-item expanded "><a href="../../reference/functions/IterGenerate.html">IterGenerate</a></li><li class="chapter-item expanded "><a href="../../reference/functions/IterOnce.html">IterOnce</a></li><li class="chapter-item expanded "><a href="../../reference/functions/IterRange.html">IterRange</a></li><li class="chapter-item expanded "><a href="../../reference/functions/IterRepeat.html">IterRepeat</a></li><li class="chapter-item expanded "><a href="../../reference/functions/IterStd.html">IterStd</a></li><li class="chapter-item expanded "><a href="../../reference/functions/IterStdConst.html">IterStdConst</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Systems - Modular and scalable game architecture for orthogonal game logic</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="struct-tquery"><a class="header" href="#struct-tquery"><strong>Struct: <code>TQuery</code></strong></a></h1>
<pre><code class="language-cpp">template &lt;class... T&gt;
struct TQuery;
</code></pre>
<hr />
<p>Systems world query iterator.</p>
<p>Allows to iterate over actors and their components that comply to requested
types signature.</p>
<p>More about iterators in <a href="/Unreal-Systems-Architecture/systems/book/architecture/iterators.html">this architecture book
page</a>.</p>
<h1 id="note"><a class="header" href="#note">Note</a></h1>
<blockquote>
<p>User should rather construct queries with <a href="/Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#query"><strong><code>USystemsWorld::Query</code></strong></a>
instead o constructing queries by hand.</p>
</blockquote>
<blockquote>
<p>Returned query iterator has always put actor as first item of item tuple
and then follow requested components. So <code>Systems-&gt;Query&lt;A, B, C&gt;()</code>
iterator will yield given tuple <code>TTuple&lt;AActor*, A*, B*, C*&gt;</code></p>
</blockquote>
<h1 id="example"><a class="header" href="#example">Example</a></h1>
<pre><code class="language-cpp">	const auto Count = static_cast&lt;int&gt;(Systems.Query&lt;UBoidComponent&gt;().Count());
	const auto Difference = Count - EXPECTED_POPULATION_NUMBER;

	if (Difference &gt; 0)
	{
		for (auto&amp; QueryItem : Systems.Query&lt;UBoidComponent&gt;().Take(Difference))
		{
			auto* Actor = QueryItem.Get&lt;0&gt;();
			Actor-&gt;Destroy();
		}
	}
</code></pre>
<hr />
<h1 id="methods"><a class="header" href="#methods"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="adapt"><a class="header" href="#adapt"><strong><code>Adapt</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename ADAPTER&gt;
TIterAdapt&lt;Self, ADAPTER&gt; Adapt(
    ADAPTER Adapter
);
</code></pre>
<details>
<hr />
<p>Injects custom iterator adapter into the chain of iteration.</p>
<p>Useful only for really custom/advanced solutions that cannot be solved with
regular iterators.</p>
<h1 id="note-1"><a class="header" href="#note-1">Note</a></h1>
<blockquote>
<p><code>ADAPTER</code> should implement iterator adapter methods. Yielded values share
same type wit iterator that wraps this adapter.</p>
</blockquote>
<h1 id="example-1"><a class="header" href="#example-1">Example</a></h1>
<pre><code class="language-cpp">// [1, 3, 5, 7, 9]
const TArray&lt;int&gt; Result = IterRange(0, 10).Adapt(TIterOddAdapter&lt;int&gt;()).CollectArray();
</code></pre>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct TIterOddAdapter
{
public:
	template &lt;typename I&gt;
	TOptional&lt;T&gt; Next(I&amp; Iter)
	{
		Iter.Next();
		return Iter.Next();
	}

	template &lt;typename I&gt;
	IterSizeHint SizeHint(const I&amp; Iter) const
	{
		return Iter.SizeHint();
	}
};
</code></pre>
<hr />
<h1 id="arguments"><a class="header" href="#arguments"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="adapter"><a class="header" href="#adapter"><strong><code>Adapter</code></strong></a></h2>
<pre><code class="language-cpp">ADAPTER Adapter
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="all"><a class="header" href="#all"><strong><code>All</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
bool All(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Checks if all values yielded by this iterator passes predicate.</p>
<h1 id="note-2"><a class="header" href="#note-2">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-2"><a class="header" href="#example-2">Example</a></h1>
<pre><code class="language-cpp">// false
const bool Result = IterRange(0, 10).All([](const auto&amp; Value) { return Value &gt; 5; });
</code></pre>
<hr />
<h1 id="arguments-1"><a class="header" href="#arguments-1"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func"><a class="header" href="#func"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="any"><a class="header" href="#any"><strong><code>Any</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
bool Any(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Checks if any value yielded by this iterator passes predicate.</p>
<h1 id="note-3"><a class="header" href="#note-3">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-3"><a class="header" href="#example-3">Example</a></h1>
<pre><code class="language-cpp">// true
const bool Result = IterRange(0, 10).Any([](const auto&amp; Value) { return Value &gt; 5; });
</code></pre>
<hr />
<h1 id="arguments-2"><a class="header" href="#arguments-2"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-1"><a class="header" href="#func-1"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="cast"><a class="header" href="#cast"><strong><code>Cast</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT&gt;
TIterCast&lt;typename RESULT, Self&gt; Cast();
</code></pre>
<details>
<hr />
<p>Casts yielded values to another type.</p>
<p>Commonly used as a shourtcut for mapping between types using target type
constructor.</p>
<h1 id="note-4"><a class="header" href="#note-4">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is type that this iterator will yield after casting.</p>
</blockquote>
<h1 id="example-4"><a class="header" href="#example-4">Example</a></h1>
<pre><code class="language-cpp">// [0.0, 1.0, 2.0, 3.0, 4.0]
const TArray&lt;float&gt; Result = IterRange(0, 5).Cast&lt;float&gt;().CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="chain"><a class="header" href="#chain"><strong><code>Chain</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename ITER&gt;
TIterChain&lt;Self, ITER&gt; Chain(
    ITER&amp;&amp; Iter
);
</code></pre>
<details>
<hr />
<p>Appends another iterator at the end of this iterator.</p>
<p>Useful for combining results of different iterators that yield same value
type.</p>
<h1 id="note-5"><a class="header" href="#note-5">Note</a></h1>
<blockquote>
<p><code>ITER</code> should implement iterator methods. Yielded values share same type
with this iterato value type.</p>
</blockquote>
<h1 id="example-5"><a class="header" href="#example-5">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4, -5, -4, -3, -2, -1]
const TArray&lt;int&gt; Result = IterRange(0, 5).Chain(IterRange(-5, 0)).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-3"><a class="header" href="#arguments-3"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="iter"><a class="header" href="#iter"><strong><code>Iter</code></strong></a></h2>
<pre><code class="language-cpp">ITER&amp;&amp; Iter
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="collectarray"><a class="header" href="#collectarray"><strong><code>CollectArray</code></strong></a></h1>
<pre><code class="language-cpp">public:
TArray&lt;Item&gt; CollectArray();
</code></pre>
<details>
<hr />
<p>Consumes iterator and returns an array with its values.</p>
<h1 id="example-6"><a class="header" href="#example-6">Example</a></h1>
<pre><code class="language-cpp">const TArray&lt;int&gt; Result = IterRange(0, 10).CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="collectintoarray"><a class="header" href="#collectintoarray"><strong><code>CollectIntoArray</code></strong></a></h1>
<pre><code class="language-cpp">public:
void CollectIntoArray(
    TArray&lt;Item&gt;&amp; Result
);
</code></pre>
<details>
<hr />
<p>Consumes iterator and stores its values into provided array.</p>
<h1 id="example-7"><a class="header" href="#example-7">Example</a></h1>
<pre><code class="language-cpp">TArray&lt;int&gt; Result();
IterRange(0, 10).CollectIntoArray(Result);
</code></pre>
<hr />
<h1 id="arguments-4"><a class="header" href="#arguments-4"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="result"><a class="header" href="#result"><strong><code>Result</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;Item&gt;&amp; Result
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="collectintoset"><a class="header" href="#collectintoset"><strong><code>CollectIntoSet</code></strong></a></h1>
<pre><code class="language-cpp">public:
void CollectIntoSet(
    TSet&lt;Item&gt;&amp; Result
);
</code></pre>
<details>
<hr />
<p>Consumes iterator and stores its values into provided set.</p>
<h1 id="example-8"><a class="header" href="#example-8">Example</a></h1>
<pre><code class="language-cpp">TSet&lt;int&gt; Result();
IterRange(0, 10).CollectIntoSet(Result);
</code></pre>
<hr />
<h1 id="arguments-5"><a class="header" href="#arguments-5"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="result-1"><a class="header" href="#result-1"><strong><code>Result</code></strong></a></h2>
<pre><code class="language-cpp">TSet&lt;Item&gt;&amp; Result
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="collectset"><a class="header" href="#collectset"><strong><code>CollectSet</code></strong></a></h1>
<pre><code class="language-cpp">public:
TSet&lt;Item&gt; CollectSet();
</code></pre>
<details>
<hr />
<p>Consumes iterator and returns a set with its values.</p>
<h1 id="example-9"><a class="header" href="#example-9">Example</a></h1>
<pre><code class="language-cpp">const TArray&lt;int&gt; Result = IterRange(0, 10).CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="comparedby"><a class="header" href="#comparedby"><strong><code>ComparedBy</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TOptional&lt;Item&gt; ComparedBy(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Finds iterator value that compared to other items gets greater &quot;score&quot;.</p>
<p>Headline is rather vague, but what it actually does is user can do finding
min/max value with this iterator consumer.</p>
<h1 id="note-6"><a class="header" href="#note-6">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item A, I::Item B)</code> where <code>A</code> holds current value yielded by iterator and <code>B</code> is
the one that has best &quot;score&quot; so far.</p>
</blockquote>
<h1 id="example-10"><a class="header" href="#example-10">Example</a></h1>
<pre><code class="language-cpp">// 42
const int Result = IterRange(0, 42).ComparedBy([](const auto A, const auto B) { return A &gt; B; });
</code></pre>
<hr />
<h1 id="arguments-6"><a class="header" href="#arguments-6"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-2"><a class="header" href="#func-2"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="count"><a class="header" href="#count"><strong><code>Count</code></strong></a></h1>
<pre><code class="language-cpp">public:
uint32 Count();
</code></pre>
<details>
<hr />
<p>Returns exact number of items that iterator can yield.</p>
<h1 id="example-11"><a class="header" href="#example-11">Example</a></h1>
<pre><code class="language-cpp">// 10
const uint32 Result = IterRange(0, 10).Count();
</code></pre>
</details>
</li>
<li>
<h1 id="enumerate"><a class="header" href="#enumerate"><strong><code>Enumerate</code></strong></a></h1>
<pre><code class="language-cpp">public:
TIterEnumerate&lt;Self&gt; Enumerate();
</code></pre>
<details>
<hr />
<p>Enumerates values in this iterator.</p>
<p>Useful for reading index of element/iteration.</p>
<h1 id="note-7"><a class="header" href="#note-7">Note</a></h1>
<blockquote>
<p>Yielded values have type: <code>TTuple&lt;uint32, Item&gt;</code>, which means this
iterator yields tuple o index-value pair.</p>
</blockquote>
<h1 id="example-12"><a class="header" href="#example-12">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4]
const TArray&lt;int&gt; Result =
	IterRepeat(42).Enumerate().Map&lt;int&gt;([](const auto&amp; Pair) { return Pair.Get&lt;0&gt;(); }).Take(5).CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="filter"><a class="header" href="#filter"><strong><code>Filter</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TIterFilter&lt;Self, typename FUNCTOR&gt; Filter(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Filters values in the iterator by predicate.</p>
<h1 id="note-8"><a class="header" href="#note-8">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to this function signature: <code>bool(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-13"><a class="header" href="#example-13">Example</a></h1>
<pre><code class="language-cpp">// [0, 2, 4, 6, 8]
const TArray&lt;int&gt; Result = IterRange(0, 10).Filter([](const auto&amp; Value) { return Value % 2 == 0; }).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-7"><a class="header" href="#arguments-7"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-3"><a class="header" href="#func-3"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="filtermap"><a class="header" href="#filtermap"><strong><code>FilterMap</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT, typename FUNCTOR&gt;
TIterFilterMap&lt;typename RESULT, Self, typename FUNCTOR&gt; FilterMap(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Filters values in the iterator by predicate and maps them to another type.</p>
<h1 id="note-9"><a class="header" href="#note-9">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is a type of values yielded by this iterator that maps into.
<code>FUNCTOR</code> should comply to this function signature:
<code>TOptional&lt;RESULT&gt;(const I::Item&amp; Value)</code> Returning some value means
pasing it to next iterator, returning none means we omit thi value.</p>
</blockquote>
<h1 id="example-14"><a class="header" href="#example-14">Example</a></h1>
<pre><code class="language-cpp">// [0.0, 2.0, 4.0, 6.0, 8.0]
const TArray&lt;float&gt; I = IterRange(0, 10)
							.FilterMap&lt;float&gt;(
								[](const auto&amp; Value)
								{
									if (Value % 2 == 0)
									{
										return TOptional&lt;float&gt;(static_cast&lt;float&gt;(Value));
									}
									else
									{
										return TOptional&lt;float&gt;();
									}
								})
							.CollectArray();
</code></pre>
<hr />
<h1 id="arguments-8"><a class="header" href="#arguments-8"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-4"><a class="header" href="#func-4"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="find"><a class="header" href="#find"><strong><code>Find</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TOptional&lt;Item&gt; Find(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Finds and returns value in this iterator that passes <code>FUNCTOR</code> predicate.</p>
<h1 id="note-10"><a class="header" href="#note-10">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>bool(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-15"><a class="header" href="#example-15">Example</a></h1>
<pre><code class="language-cpp">// 5
const TOptional&lt;int&gt; Result = IterRange(0, 10).Find([](const auto&amp; Value) { return Value &gt;= 5; });
</code></pre>
<hr />
<h1 id="arguments-9"><a class="header" href="#arguments-9"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-5"><a class="header" href="#func-5"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="findmap"><a class="header" href="#findmap"><strong><code>FindMap</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT, typename FUNCTOR&gt;
TOptional&lt;RESULT&gt; FindMap(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Finds and returns value in this iterator that passes <code>FUNCTOR</code> predicate,
mapped to another type.</p>
<h1 id="note-11"><a class="header" href="#note-11">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature:
<code>TOptional&lt;Item&gt;(I::Item Value)</code> where <code>Value</code> holds current value
yielded by iterator. <code>RESULT</code> is the returned type and use should always
return <code>TOptional&lt;RESULT&gt;</code> in the predicate where some value means &quot;found&quot;
an none means &quot;not found&quot;.</p>
</blockquote>
<h1 id="example-16"><a class="header" href="#example-16">Example</a></h1>
<pre><code class="language-cpp">// 5.0
const TOptional&lt;float&gt; Result = IterRange(0, 10).FindMap&lt;float&gt;(
	[](const auto&amp; Value)
	{
		if (Value &gt;= 5)
		{
			return TOptional&lt;float&gt;(static_cast&lt;float&gt;(Value));
		}
		else
		{
			return TOptional&lt;float&gt;();
		}
	});
</code></pre>
<hr />
<h1 id="arguments-10"><a class="header" href="#arguments-10"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-6"><a class="header" href="#func-6"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="first"><a class="header" href="#first"><strong><code>First</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; First();
</code></pre>
<details>
<hr />
<p>Returns first item in the iterator.</p>
<p>This is an equivalent of calling <a href="/Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#next"><strong><code>TQuery::Next</code></strong></a>.</p>
<h1 id="example-17"><a class="header" href="#example-17">Example</a></h1>
<pre><code class="language-cpp">// 5
const int Result = IterRange(5, 10).First();
</code></pre>
</details>
</li>
<li>
<h1 id="flatten"><a class="header" href="#flatten"><strong><code>Flatten</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT&gt;
TIterFlatten&lt;typename RESULT, Self&gt; Flatten();
</code></pre>
<details>
<hr />
<p>Flattens nested iterators.</p>
<p>Imagine you have an iterator that yields another iterators, such as arrays
of arrays.</p>
<h1 id="note-12"><a class="header" href="#note-12">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is a type of values yielded by this iterator - it should be the
same as nested iterator value type (c++ won't accept that syntax, hence we
have to provide a <code>RESULT</code> type and ensure it's the same), <code>FUNCTOR</code>
should comply to this function signature: <code>RESULT(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-18"><a class="header" href="#example-18">Example</a></h1>
<pre><code class="language-cpp">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
const TArray&lt;int&gt; P =
	IterGenerate&lt;TIterRange&lt;int&gt;&gt;([]() { return IterRange(0, 5); }).Take(2).Flatten&lt;int&gt;().CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="fold"><a class="header" href="#fold"><strong><code>Fold</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
Item Fold(
    Item Start,
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Folds iterator into single value.</p>
<p>Folding basically means going through all iterator items and collapsing them
into single value. Example of folding can be sum/accumulation, or min/max,
or anything like that - although for ones mentioned there are existing
optimized iterator consumers: <a href="/Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#sum"><strong><code>TQuery::Sum</code></strong></a> and
<a href="/Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#comparedby"><strong><code>TQuery::ComparedBy</code></strong></a>.</p>
<h1 id="note-13"><a class="header" href="#note-13">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is the returned type, same as <code>Start</code> argument used as initial
accumulator. <code>FUNCTOR</code> should comply to given function signature: <code>Item(Item Accumulator, I::Item Value)</code> where <code>Accumulator</code> argument holds result of
previous iteration, and <code>Value</code> holds curren value yielded by iterator.
<code>Start</code> argument holds value passed to first iteratio <code>Accumulator</code>.</p>
</blockquote>
<h1 id="example-19"><a class="header" href="#example-19">Example</a></h1>
<pre><code class="language-cpp">// 45
const int Result = IterRange(0, 10).Fold(0, [](const auto&amp; Accum, const auto&amp; Value) { return Accum + Value; });
</code></pre>
<hr />
<h1 id="arguments-11"><a class="header" href="#arguments-11"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="start"><a class="header" href="#start"><strong><code>Start</code></strong></a></h2>
<pre><code class="language-cpp">Item Start
</code></pre>
</li>
<li>
<h2 id="func-7"><a class="header" href="#func-7"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="foreach"><a class="header" href="#foreach"><strong><code>ForEach</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
void ForEach(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Consumes iterator and yields its values for user to process.</p>
<p>This is equivalent of:</p>
<pre><code class="language-cpp">auto Iter = IterRange(0, 9);
while (const auto Value = Iter.Next())
{
	const auto Squared = Value * Value;
	UE_LOG(LogTemp, Warning, TEXT(&quot;Squared value: %i&quot;), Squared);
}
</code></pre>
<h1 id="note-14"><a class="header" href="#note-14">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to given function signature: <code>void(I::Item Value)</code> where <code>Value</code> holds current value yielded by iterator.</p>
</blockquote>
<h1 id="example-20"><a class="header" href="#example-20">Example</a></h1>
<pre><code class="language-cpp">for (const auto Value : IterRange(0, 9))
{
	const auto Squared = Value * Value;
	UE_LOG(LogTemp, Warning, TEXT(&quot;Squared value: %i&quot;), Squared);
}
</code></pre>
<hr />
<h1 id="arguments-12"><a class="header" href="#arguments-12"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-8"><a class="header" href="#func-8"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="inspect"><a class="header" href="#inspect"><strong><code>Inspect</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename FUNCTOR&gt;
TIterInspect&lt;Self, typename FUNCTOR&gt; Inspect(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Inspects yielded values.</p>
<p>Useful when debugging iterators to for example log what values are yielded
at which iterator chain stage.</p>
<h1 id="note-15"><a class="header" href="#note-15">Note</a></h1>
<blockquote>
<p><code>FUNCTOR</code> should comply to this function signature: <code>void(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-21"><a class="header" href="#example-21">Example</a></h1>
<pre><code class="language-cpp">// [0, 2, 4, 6, 8]
const TArray&lt;int&gt; Result = IterRange(0, 10)
							   .Inspect(
								   [](const auto&amp; Value)
								   {
									   // Prints values: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
									   UE_LOG(LogTemp, Warning, TEXT(&quot;Inspected item before: %i&quot;), Value);
								   })
							   .Filter([](const auto&amp; Value) { return Value % 2 == 0; })
							   .Inspect(
								   [](const auto&amp; Value)
								   {
									   // Prints values: 0, 2, 4, 6, 8.
									   UE_LOG(LogTemp, Warning, TEXT(&quot;Inspected item after: %i&quot;), Value);
								   })
							   .CollectArray();
</code></pre>
<hr />
<h1 id="arguments-13"><a class="header" href="#arguments-13"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-9"><a class="header" href="#func-9"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="last"><a class="header" href="#last"><strong><code>Last</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; Last();
</code></pre>
<details>
<hr />
<p>Returns last item in the iterator.</p>
<h1 id="example-22"><a class="header" href="#example-22">Example</a></h1>
<pre><code class="language-cpp">// 4
const int Result = IterRange(0, 4).Last();
</code></pre>
</details>
</li>
<li>
<h1 id="map"><a class="header" href="#map"><strong><code>Map</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename RESULT, typename FUNCTOR&gt;
TIterMap&lt;typename RESULT, Self, typename FUNCTOR&gt; Map(
    FUNCTOR Func
);
</code></pre>
<details>
<hr />
<p>Maps yielded values to another type.</p>
<p>Commonly used for data transformations for use in later stages of iteration.</p>
<h1 id="note-16"><a class="header" href="#note-16">Note</a></h1>
<blockquote>
<p><code>RESULT</code> is type that this iterator will yield after data transformations.
<code>FUNCTOR</code> should comply to this function signature: <code>RESULT(const I::Item&amp; Value)</code>.</p>
</blockquote>
<h1 id="example-23"><a class="header" href="#example-23">Example</a></h1>
<pre><code class="language-cpp">// [0.0, 4.0, 16.0, 36.0, 64.0]
const TArray&lt;float&gt; Result = IterRange(0, 10)
								 .Filter([](const auto&amp; Value) { return Value % 2 == 0; })
								 .Map&lt;float&gt;([](const auto&amp; Value) { return static_cast&lt;float&gt;(Value * Value); })
								 .CollectArray();
</code></pre>
<hr />
<h1 id="arguments-14"><a class="header" href="#arguments-14"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="func-10"><a class="header" href="#func-10"><strong><code>Func</code></strong></a></h2>
<pre><code class="language-cpp">FUNCTOR Func
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="next"><a class="header" href="#next"><strong><code>Next</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; Next();
</code></pre>
<details>
<hr />
<p>Yields tuple to next actors component set.</p>
<p>Usually user would rather want to use iterator methods for ergonomic
iteration over the query, but in case user has valid reasons to handle
iteration different way, this is the single point that performs
iteration and yields an item.</p>
<h1 id="example-24"><a class="header" href="#example-24">Example</a></h1>
<pre><code class="language-cpp">	auto Query = Systems.Query&lt;UShiaComponent&gt;();
	while (auto&amp; QueryItem = Query.Next())
	{
		// Note that we do not check if QueryItem optional value is set.
		// `while` loop perform these checks for us, hence we use it
		// instead of standard `for` loop.
		auto* Actor = QueryItem.GetValue().Get&lt;0&gt;();
		auto* Shia = QueryItem.GetValue().Get&lt;1&gt;();

		Shia-&gt;JustDoIt(Actor);
	}
</code></pre>
</details>
</li>
<li>
<h1 id="nth"><a class="header" href="#nth"><strong><code>Nth</code></strong></a></h1>
<pre><code class="language-cpp">public:
TOptional&lt;Item&gt; Nth(
    uint32 Index
);
</code></pre>
<details>
<hr />
<p>Returns Nth item in the iterator.</p>
<h1 id="example-25"><a class="header" href="#example-25">Example</a></h1>
<pre><code class="language-cpp">// 5
const TOptional&lt;int&gt; Result = IterRange(0, 10).Nth(5);
</code></pre>
<hr />
<h1 id="arguments-15"><a class="header" href="#arguments-15"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="index"><a class="header" href="#index"><strong><code>Index</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Index
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="sizehint"><a class="header" href="#sizehint"><strong><code>SizeHint</code></strong></a></h1>
<pre><code class="language-cpp">public:
IterSizeHint SizeHint() const;
</code></pre>
<details>
<hr />
<p>Gets hint about minimum and optional maximum items count this iterator
can yield.</p>
<p>Used internally by lazy-iterators, but in case user would like to
implement their own iterators, or iterator consumers, or just wants to
preallocate some memory for later consumed iterator items, this method
is really useful for these usecases.</p>
<p>See <a href="/Unreal-Systems-Architecture/systems/reference/structs/IterSizeHint.html"><strong><code>IterSizeHint</code></strong></a>.</p>
<h1 id="example-26"><a class="header" href="#example-26">Example</a></h1>
<pre><code class="language-cpp">template &lt;typename I&gt;
void IterCollectIntoArray(I&amp;&amp; Iterator, TArray&lt;typename I::Item&gt;&amp; Result)
{
	const auto SizeHint = Iterator.SizeHint();
	const auto Capacity = SizeHint.Maximum.IsSet() ? SizeHint.Maximum.GetValue() : SizeHint.Minimum;
	Result.Reserve(Result.Num() + Capacity);
	while (auto QueryItem = Iterator.Next())
	{
		Result.Add(QueryItem.GetValue());
	}
}
</code></pre>
</details>
</li>
<li>
<h1 id="skip"><a class="header" href="#skip"><strong><code>Skip</code></strong></a></h1>
<pre><code class="language-cpp">public:
TIterSkip&lt;Self&gt; Skip(
    uint32 Count
);
</code></pre>
<details>
<hr />
<p>Skips iteration by number of elements.</p>
<p>It's worth noting that this is one-shot skip, not repeated one, which means
if we yield iterator of 10 elements and we skip 2 iterations, then it will
skip just 2 values and yield rest 8.</p>
<h1 id="example-27"><a class="header" href="#example-27">Example</a></h1>
<pre><code class="language-cpp">// [3, 4, 5, 6, 7]
const TArray&lt;int&gt; Result = IterRange(0, 10).Skip(3).Take(5).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-16"><a class="header" href="#arguments-16"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="count-1"><a class="header" href="#count-1"><strong><code>Count</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Count
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="sum"><a class="header" href="#sum"><strong><code>Sum</code></strong></a></h1>
<pre><code class="language-cpp">public:
Item Sum(
    Item InitialValue
);
</code></pre>
<details>
<hr />
<p>Returns sum of values that iterator can yield.</p>
<h1 id="note-17"><a class="header" href="#note-17">Note</a></h1>
<blockquote>
<p>Make sure that type of iterator values actually implement <code>operator+</code>!
Also since iterator can work on non-numerical types, user has to provide
initial value, tha makes it work like <a href="/Unreal-Systems-Architecture/systems/reference/structs/TQuery.html#fold"><strong><code>TQuery::Fold</code></strong></a>.</p>
</blockquote>
<h1 id="example-28"><a class="header" href="#example-28">Example</a></h1>
<pre><code class="language-cpp">// 45
const int Return = IterRange(0, 10).Sum(0);
</code></pre>
<p>This is equivalent of:</p>
<pre><code class="language-cpp">// 45
const int Result = IterRange(0, 10).Fold(0, [](const auto&amp; Accum, const auto&amp; Value) { return Accum + Value; });
</code></pre>
<hr />
<h1 id="arguments-17"><a class="header" href="#arguments-17"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="initialvalue"><a class="header" href="#initialvalue"><strong><code>InitialValue</code></strong></a></h2>
<pre><code class="language-cpp">Item InitialValue
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="tquery"><a class="header" href="#tquery"><strong><code>TQuery</code></strong></a></h1>
<pre><code class="language-cpp">public:
TQuery(
    USystemsWorld* Systems
);
</code></pre>
<details>
<hr />
<p>Constructs query from systems.</p>
<p>An equivalent of calling <a href="/Unreal-Systems-Architecture/systems/reference/classes/USystemsWorld.html#query"><strong><code>USystemsWorld::Query</code></strong></a></p>
<hr />
<h1 id="arguments-18"><a class="header" href="#arguments-18"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="systems"><a class="header" href="#systems"><strong><code>Systems</code></strong></a></h2>
<pre><code class="language-cpp">USystemsWorld* Systems
</code></pre>
<p>Pointer to systems world of which actor components user wants to
iterate on.</p>
</li>
</ul>
</details>
</li>
<li>
<h1 id="take"><a class="header" href="#take"><strong><code>Take</code></strong></a></h1>
<pre><code class="language-cpp">public:
TIterTake&lt;Self&gt; Take(
    uint32 Count
);
</code></pre>
<details>
<hr />
<p>Limits iterator to at most number of iterations.</p>
<p>If we create an iterator that yields 10 values and we tell it to take 5,
then it will stop iterating after next 5 values (or less, depends if there
is enough values left in iterator).</p>
<h1 id="example-29"><a class="header" href="#example-29">Example</a></h1>
<pre><code class="language-cpp">// [3, 4, 5, 6, 7]
const TArray&lt;int&gt; Result = IterRange(0, 10).Skip(3).Take(5).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-19"><a class="header" href="#arguments-19"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="count-2"><a class="header" href="#count-2"><strong><code>Count</code></strong></a></h2>
<pre><code class="language-cpp">uint32 Count
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="views"><a class="header" href="#views"><strong><code>Views</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;uint32 COUNT&gt;
TIterViews&lt;Self, COUNT&gt; Views();
</code></pre>
<details>
<hr />
<p>Yields sequences of consecutive views over set of values.</p>
<p>If we create an iterator that yields 5 integer values and we tell it to view
2 at the same time, then it will yield <code>TArrayView</code> with values: <code>[0, 1], [1, 2], [2, 3], [3, 4]</code>.</p>
<h1 id="example-30"><a class="header" href="#example-30">Example</a></h1>
<pre><code class="language-cpp">// [(0, 1), (1, 2), (2, 3), (3, 4)]
const TArray&lt;TTuple&lt;int, int&gt;&gt; Result =
	IterRange(0, 5)
		.Views&lt;2&gt;()
		.Map&lt;TTuple&lt;int, int&gt;&gt;([](const auto&amp; View) { return MakeTuple(View[0], View[1]); })
		.CollectArray();
</code></pre>
</details>
</li>
<li>
<h1 id="zip"><a class="header" href="#zip"><strong><code>Zip</code></strong></a></h1>
<pre><code class="language-cpp">public:
template &lt;typename ITER&gt;
TIterZip&lt;Self, ITER&gt; Zip(
    ITER&amp;&amp; Iter
);
</code></pre>
<details>
<hr />
<p>Combines two iterators to make one that yields pair of both iterator values
at the same time.</p>
<h1 id="example-31"><a class="header" href="#example-31">Example</a></h1>
<pre><code class="language-cpp">// [(0, -5), (1, -4), (2, -3), (3, -2), (4, -1)]
const TArray&lt;TTuple&lt;int, int&gt;&gt; Result = IterRange(0, 5).Zip(IterRange(-5, 0)).CollectArray();
</code></pre>
<hr />
<h1 id="arguments-20"><a class="header" href="#arguments-20"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="iter-1"><a class="header" href="#iter-1"><strong><code>Iter</code></strong></a></h2>
<pre><code class="language-cpp">ITER&amp;&amp; Iter
</code></pre>
</li>
</ul>
</details>
</li>
<li>
<h1 id="begin"><a class="header" href="#begin"><strong><code>begin</code></strong></a></h1>
<pre><code class="language-cpp">public:
TStlIterator&lt;Self&gt; begin();
</code></pre>
<details>
<hr />
<p>Allows this iterator to be used in <code>for-in</code> loop.</p>
<h1 id="example-32"><a class="header" href="#example-32">Example</a></h1>
<pre><code class="language-cpp">// 0
// 1
// 2
// 3
// 4
for (auto Value : IterRange(0, 5))
{
	UE_LOG(LogTemp, Info, TEXT(&quot;%i&quot;), Value);
}
</code></pre>
</details>
</li>
<li>
<h1 id="end"><a class="header" href="#end"><strong><code>end</code></strong></a></h1>
<pre><code class="language-cpp">public:
TStlIterator&lt;Self&gt; end();
</code></pre>
<details>
<hr />
<p>Allows this iterator to be used in <code>for-in</code> loop.</p>
<h1 id="example-33"><a class="header" href="#example-33">Example</a></h1>
<pre><code class="language-cpp">// 0
// 1
// 2
// 3
// 4
for (auto Value : IterRange(0, 5))
{
	UE_LOG(LogTemp, Info, TEXT(&quot;%i&quot;), Value);
}
</code></pre>
</details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.8</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../reference/structs/IterSizeHint.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../reference/structs/TReceiverChannel.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../reference/structs/IterSizeHint.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../reference/structs/TReceiverChannel.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
